
/**
 * Client
**/

import * as runtime from './runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model blocks
 * 
 */
export type blocks = {
  index_block_hash: Buffer
  block_hash: Buffer
  block_height: number
  burn_block_time: number
  burn_block_hash: Buffer
  burn_block_height: number
  miner_txid: Buffer
  parent_index_block_hash: Buffer
  parent_block_hash: Buffer
  parent_microblock_hash: Buffer
  parent_microblock_sequence: number
  canonical: boolean
  execution_cost_read_count: bigint
  execution_cost_read_length: bigint
  execution_cost_runtime: bigint
  execution_cost_write_count: bigint
  execution_cost_write_length: bigint
}

/**
 * Model burnchain_rewards
 * 
 */
export type burnchain_rewards = {
  id: number
  canonical: boolean
  burn_block_hash: Buffer
  burn_block_height: number
  burn_amount: Prisma.Decimal
  reward_recipient: string
  reward_amount: Prisma.Decimal
  reward_index: number
}

/**
 * Model config_state
 * 
 */
export type config_state = {
  id: boolean
  bns_names_onchain_imported: boolean
  bns_subdomains_imported: boolean
  token_offering_imported: boolean
}

/**
 * Model ContractLogs
 * 
 */
export type ContractLogs = {
  id: number
  event_index: number
  tx_id: Buffer
  tx_index: number
  block_height: number
  index_block_hash: Buffer
  parent_index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_canonical: boolean
  canonical: boolean
  contract_identifier: string
  topic: string
  value: Buffer
}

/**
 * Model event_observer_requests
 * 
 */
export type event_observer_requests = {
  id: bigint
  receive_timestamp: Date
  event_path: string
  payload: Prisma.JsonValue
}

/**
 * Model faucet_requests
 * 
 */
export type faucet_requests = {
  id: number
  currency: string
  address: string
  ip: string
  occurred_at: bigint
}

/**
 * Model ft_events
 * 
 */
export type ft_events = {
  id: number
  event_index: number
  tx_id: Buffer
  tx_index: number
  block_height: number
  index_block_hash: Buffer
  parent_index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_canonical: boolean
  canonical: boolean
  asset_event_type_id: number
  asset_identifier: string
  amount: Prisma.Decimal
  sender: string | null
  recipient: string | null
}

/**
 * Model ft_metadata
 * 
 */
export type ft_metadata = {
  id: number
  name: string
  token_uri: string
  description: string
  image_uri: string
  image_canonical_uri: string
  contract_id: string
  symbol: string
  decimals: number
  tx_id: Buffer
  sender_address: string
}

/**
 * Model mempool_txs
 * 
 */
export type mempool_txs = {
  id: number
  pruned: boolean
  tx_id: Buffer
  type_id: number
  anchor_mode: number
  status: number
  post_conditions: Buffer
  nonce: number
  fee_rate: bigint
  sponsored: boolean
  sponsor_address: string | null
  sponsor_nonce: number | null
  sender_address: string
  origin_hash_mode: number
  raw_tx: Buffer
  receipt_time: number
  receipt_block_height: number
  token_transfer_recipient_address: string | null
  token_transfer_amount: bigint | null
  token_transfer_memo: Buffer | null
  smart_contract_clarity_version: number | null
  smart_contract_contract_id: string | null
  smart_contract_source_code: string | null
  contract_call_contract_id: string | null
  contract_call_function_name: string | null
  contract_call_function_args: Buffer | null
  poison_microblock_header_1: Buffer | null
  poison_microblock_header_2: Buffer | null
  coinbase_payload: Buffer | null
  coinbase_alt_recipient: string | null
  tx_size: number
}

/**
 * Model microblocks
 * 
 */
export type microblocks = {
  id: bigint
  receive_timestamp: Date
  canonical: boolean
  microblock_canonical: boolean
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_parent_hash: Buffer
  index_block_hash: Buffer
  parent_index_block_hash: Buffer
  block_height: number
  parent_block_height: number
  parent_block_hash: Buffer
  parent_burn_block_height: number
  parent_burn_block_time: number
  parent_burn_block_hash: Buffer
  block_hash: Buffer
}

/**
 * Model miner_rewards
 * 
 */
export type miner_rewards = {
  id: number
  block_hash: Buffer
  index_block_hash: Buffer
  from_index_block_hash: Buffer
  mature_block_height: number
  canonical: boolean
  recipient: string
  miner_address: string | null
  coinbase_amount: Prisma.Decimal
  tx_fees_anchored: Prisma.Decimal
  tx_fees_streamed_confirmed: Prisma.Decimal
  tx_fees_streamed_produced: Prisma.Decimal
}

/**
 * Model names
 * 
 */
export type names = {
  id: number
  name: string
  address: string
  registered_at: number
  expire_block: number
  zonefile_hash: string
  namespace_id: string
  grace_period: string | null
  renewal_deadline: number | null
  resolver: string | null
  tx_id: Buffer | null
  tx_index: number
  event_index: number | null
  status: string | null
  canonical: boolean
  index_block_hash: Buffer | null
  parent_index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_canonical: boolean
}

/**
 * Model namespaces
 * 
 */
export type namespaces = {
  id: number
  namespace_id: string
  launched_at: number | null
  address: string
  reveal_block: number
  ready_block: number
  buckets: string
  base: Prisma.Decimal
  coeff: Prisma.Decimal
  nonalpha_discount: number
  no_vowel_discount: number
  lifetime: number
  status: string | null
  tx_id: Buffer | null
  tx_index: number
  canonical: boolean
  index_block_hash: Buffer | null
  parent_index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_canonical: boolean
}

/**
 * Model nft_events
 * 
 */
export type nft_events = {
  id: number
  event_index: number
  tx_id: Buffer
  tx_index: number
  block_height: number
  index_block_hash: Buffer
  parent_index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_canonical: boolean
  canonical: boolean
  asset_event_type_id: number
  asset_identifier: string
  value: Buffer
  sender: string | null
  recipient: string | null
}

/**
 * Model nft_metadata
 * 
 */
export type nft_metadata = {
  id: number
  name: string
  token_uri: string
  description: string
  image_uri: string
  image_canonical_uri: string
  contract_id: string
  tx_id: Buffer
  sender_address: string
}

/**
 * Model pgmigrations
 * 
 */
export type pgmigrations = {
  id: number
  name: string
  run_on: Date
}

/**
 * Model pox2_events
 * 
 */
export type pox2_events = {
  id: bigint
  event_index: number
  tx_id: Buffer
  tx_index: number
  block_height: number
  index_block_hash: Buffer
  parent_index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_canonical: boolean
  canonical: boolean
  stacker: string
  locked: Prisma.Decimal
  balance: Prisma.Decimal
  burnchain_unlock_height: bigint
  name: string
  pox_addr: string | null
  pox_addr_raw: Buffer | null
  first_cycle_locked: Prisma.Decimal | null
  first_unlocked_cycle: Prisma.Decimal | null
  lock_period: Prisma.Decimal | null
  lock_amount: Prisma.Decimal | null
  start_burn_height: Prisma.Decimal | null
  unlock_burn_height: Prisma.Decimal | null
  delegator: string | null
  increase_by: Prisma.Decimal | null
  total_locked: Prisma.Decimal | null
  extend_count: Prisma.Decimal | null
  reward_cycle: Prisma.Decimal | null
  amount_ustx: Prisma.Decimal | null
}

/**
 * Model pox_state
 * 
 */
export type pox_state = {
  id: boolean
  pox_v1_unlock_height: number
}

/**
 * Model principal_stx_txs
 * 
 */
export type principal_stx_txs = {
  id: number
  principal: string
  tx_id: Buffer
  block_height: number
  index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  tx_index: number
  canonical: boolean
  microblock_canonical: boolean
}

/**
 * Model reward_slot_holders
 * 
 */
export type reward_slot_holders = {
  id: number
  canonical: boolean
  burn_block_hash: Buffer
  burn_block_height: number
  address: string
  slot_index: number
}

/**
 * Model smart_contracts
 * 
 */
export type smart_contracts = {
  id: number
  tx_id: Buffer
  canonical: boolean
  contract_id: string
  block_height: number
  index_block_hash: Buffer
  parent_index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_canonical: boolean
  clarity_version: number | null
  source_code: string
  abi: Prisma.JsonValue
}

/**
 * Model stx_events
 * 
 */
export type stx_events = {
  id: number
  event_index: number
  tx_id: Buffer
  tx_index: number
  block_height: number
  index_block_hash: Buffer
  parent_index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_canonical: boolean
  canonical: boolean
  asset_event_type_id: number
  amount: bigint
  sender: string | null
  recipient: string | null
  memo: Buffer | null
}

/**
 * Model stx_lock_events
 * 
 */
export type stx_lock_events = {
  id: number
  event_index: number
  tx_id: Buffer
  tx_index: number
  block_height: number
  index_block_hash: Buffer
  parent_index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_canonical: boolean
  canonical: boolean
  locked_amount: Prisma.Decimal
  unlock_height: number
  locked_address: string
  contract_name: string
}

/**
 * Model subdomains
 * 
 */
export type subdomains = {
  id: number
  name: string
  namespace_id: string
  fully_qualified_subdomain: string
  owner: string
  zonefile_hash: string
  parent_zonefile_hash: string
  parent_zonefile_index: number
  tx_index: number
  block_height: number
  zonefile_offset: number | null
  resolver: string | null
  tx_id: Buffer | null
  canonical: boolean
  index_block_hash: Buffer | null
  parent_index_block_hash: Buffer
  microblock_hash: Buffer
  microblock_sequence: number
  microblock_canonical: boolean
}

/**
 * Model token_metadata_queue
 * 
 */
export type token_metadata_queue = {
  queue_id: number
  tx_id: Buffer
  contract_id: string
  contract_abi: string
  block_height: number
  processed: boolean
  retry_count: number
}

/**
 * Model token_offering_locked
 * 
 */
export type token_offering_locked = {
  id: number
  address: string
  value: bigint
  block: number
}

/**
 * Model txs
 * 
 */
export type txs = {
  id: number
  tx_id: Buffer
  tx_index: number
  raw_result: Buffer
  index_block_hash: Buffer
  block_hash: Buffer
  block_height: number
  parent_block_hash: Buffer
  burn_block_time: number
  parent_burn_block_time: number
  type_id: number
  anchor_mode: number
  status: number
  canonical: boolean
  post_conditions: Buffer
  nonce: number
  fee_rate: bigint
  sponsored: boolean
  sponsor_address: string | null
  sponsor_nonce: number | null
  sender_address: string
  origin_hash_mode: number
  event_count: number
  execution_cost_read_count: bigint
  execution_cost_read_length: bigint
  execution_cost_runtime: bigint
  execution_cost_write_count: bigint
  execution_cost_write_length: bigint
  raw_tx: Buffer
  microblock_canonical: boolean
  microblock_sequence: number
  microblock_hash: Buffer
  parent_index_block_hash: Buffer
  token_transfer_recipient_address: string | null
  token_transfer_amount: bigint | null
  token_transfer_memo: Buffer | null
  smart_contract_clarity_version: number | null
  smart_contract_contract_id: string | null
  smart_contract_source_code: string | null
  contract_call_contract_id: string | null
  contract_call_function_name: string | null
  contract_call_function_args: Buffer | null
  poison_microblock_header_1: Buffer | null
  poison_microblock_header_2: Buffer | null
  coinbase_payload: Buffer | null
  coinbase_alt_recipient: string | null
}

/**
 * Model zonefiles
 * 
 */
export type zonefiles = {
  id: number
  name: string
  zonefile: string
  zonefile_hash: string
  tx_id: Buffer | null
  index_block_hash: Buffer | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Blocks
 * const blocks = await prisma.blocks.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Blocks
   * const blocks = await prisma.blocks.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.blocks`: Exposes CRUD operations for the **blocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.blocks.findMany()
    * ```
    */
  get blocks(): Prisma.blocksDelegate<GlobalReject>;

  /**
   * `prisma.burnchain_rewards`: Exposes CRUD operations for the **burnchain_rewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Burnchain_rewards
    * const burnchain_rewards = await prisma.burnchain_rewards.findMany()
    * ```
    */
  get burnchain_rewards(): Prisma.burnchain_rewardsDelegate<GlobalReject>;

  /**
   * `prisma.config_state`: Exposes CRUD operations for the **config_state** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Config_states
    * const config_states = await prisma.config_state.findMany()
    * ```
    */
  get config_state(): Prisma.config_stateDelegate<GlobalReject>;

  /**
   * `prisma.contractLogs`: Exposes CRUD operations for the **ContractLogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractLogs
    * const contractLogs = await prisma.contractLogs.findMany()
    * ```
    */
  get contractLogs(): Prisma.ContractLogsDelegate<GlobalReject>;

  /**
   * `prisma.event_observer_requests`: Exposes CRUD operations for the **event_observer_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Event_observer_requests
    * const event_observer_requests = await prisma.event_observer_requests.findMany()
    * ```
    */
  get event_observer_requests(): Prisma.event_observer_requestsDelegate<GlobalReject>;

  /**
   * `prisma.faucet_requests`: Exposes CRUD operations for the **faucet_requests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Faucet_requests
    * const faucet_requests = await prisma.faucet_requests.findMany()
    * ```
    */
  get faucet_requests(): Prisma.faucet_requestsDelegate<GlobalReject>;

  /**
   * `prisma.ft_events`: Exposes CRUD operations for the **ft_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ft_events
    * const ft_events = await prisma.ft_events.findMany()
    * ```
    */
  get ft_events(): Prisma.ft_eventsDelegate<GlobalReject>;

  /**
   * `prisma.ft_metadata`: Exposes CRUD operations for the **ft_metadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ft_metadata
    * const ft_metadata = await prisma.ft_metadata.findMany()
    * ```
    */
  get ft_metadata(): Prisma.ft_metadataDelegate<GlobalReject>;

  /**
   * `prisma.mempool_txs`: Exposes CRUD operations for the **mempool_txs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mempool_txs
    * const mempool_txs = await prisma.mempool_txs.findMany()
    * ```
    */
  get mempool_txs(): Prisma.mempool_txsDelegate<GlobalReject>;

  /**
   * `prisma.microblocks`: Exposes CRUD operations for the **microblocks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Microblocks
    * const microblocks = await prisma.microblocks.findMany()
    * ```
    */
  get microblocks(): Prisma.microblocksDelegate<GlobalReject>;

  /**
   * `prisma.miner_rewards`: Exposes CRUD operations for the **miner_rewards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Miner_rewards
    * const miner_rewards = await prisma.miner_rewards.findMany()
    * ```
    */
  get miner_rewards(): Prisma.miner_rewardsDelegate<GlobalReject>;

  /**
   * `prisma.names`: Exposes CRUD operations for the **names** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Names
    * const names = await prisma.names.findMany()
    * ```
    */
  get names(): Prisma.namesDelegate<GlobalReject>;

  /**
   * `prisma.namespaces`: Exposes CRUD operations for the **namespaces** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Namespaces
    * const namespaces = await prisma.namespaces.findMany()
    * ```
    */
  get namespaces(): Prisma.namespacesDelegate<GlobalReject>;

  /**
   * `prisma.nft_events`: Exposes CRUD operations for the **nft_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nft_events
    * const nft_events = await prisma.nft_events.findMany()
    * ```
    */
  get nft_events(): Prisma.nft_eventsDelegate<GlobalReject>;

  /**
   * `prisma.nft_metadata`: Exposes CRUD operations for the **nft_metadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nft_metadata
    * const nft_metadata = await prisma.nft_metadata.findMany()
    * ```
    */
  get nft_metadata(): Prisma.nft_metadataDelegate<GlobalReject>;

  /**
   * `prisma.pgmigrations`: Exposes CRUD operations for the **pgmigrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pgmigrations
    * const pgmigrations = await prisma.pgmigrations.findMany()
    * ```
    */
  get pgmigrations(): Prisma.pgmigrationsDelegate<GlobalReject>;

  /**
   * `prisma.pox2_events`: Exposes CRUD operations for the **pox2_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pox2_events
    * const pox2_events = await prisma.pox2_events.findMany()
    * ```
    */
  get pox2_events(): Prisma.pox2_eventsDelegate<GlobalReject>;

  /**
   * `prisma.pox_state`: Exposes CRUD operations for the **pox_state** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pox_states
    * const pox_states = await prisma.pox_state.findMany()
    * ```
    */
  get pox_state(): Prisma.pox_stateDelegate<GlobalReject>;

  /**
   * `prisma.principal_stx_txs`: Exposes CRUD operations for the **principal_stx_txs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Principal_stx_txs
    * const principal_stx_txs = await prisma.principal_stx_txs.findMany()
    * ```
    */
  get principal_stx_txs(): Prisma.principal_stx_txsDelegate<GlobalReject>;

  /**
   * `prisma.reward_slot_holders`: Exposes CRUD operations for the **reward_slot_holders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reward_slot_holders
    * const reward_slot_holders = await prisma.reward_slot_holders.findMany()
    * ```
    */
  get reward_slot_holders(): Prisma.reward_slot_holdersDelegate<GlobalReject>;

  /**
   * `prisma.smart_contracts`: Exposes CRUD operations for the **smart_contracts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Smart_contracts
    * const smart_contracts = await prisma.smart_contracts.findMany()
    * ```
    */
  get smart_contracts(): Prisma.smart_contractsDelegate<GlobalReject>;

  /**
   * `prisma.stx_events`: Exposes CRUD operations for the **stx_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stx_events
    * const stx_events = await prisma.stx_events.findMany()
    * ```
    */
  get stx_events(): Prisma.stx_eventsDelegate<GlobalReject>;

  /**
   * `prisma.stx_lock_events`: Exposes CRUD operations for the **stx_lock_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stx_lock_events
    * const stx_lock_events = await prisma.stx_lock_events.findMany()
    * ```
    */
  get stx_lock_events(): Prisma.stx_lock_eventsDelegate<GlobalReject>;

  /**
   * `prisma.subdomains`: Exposes CRUD operations for the **subdomains** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subdomains
    * const subdomains = await prisma.subdomains.findMany()
    * ```
    */
  get subdomains(): Prisma.subdomainsDelegate<GlobalReject>;

  /**
   * `prisma.token_metadata_queue`: Exposes CRUD operations for the **token_metadata_queue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Token_metadata_queues
    * const token_metadata_queues = await prisma.token_metadata_queue.findMany()
    * ```
    */
  get token_metadata_queue(): Prisma.token_metadata_queueDelegate<GlobalReject>;

  /**
   * `prisma.token_offering_locked`: Exposes CRUD operations for the **token_offering_locked** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Token_offering_lockeds
    * const token_offering_lockeds = await prisma.token_offering_locked.findMany()
    * ```
    */
  get token_offering_locked(): Prisma.token_offering_lockedDelegate<GlobalReject>;

  /**
   * `prisma.txs`: Exposes CRUD operations for the **txs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Txs
    * const txs = await prisma.txs.findMany()
    * ```
    */
  get txs(): Prisma.txsDelegate<GlobalReject>;

  /**
   * `prisma.zonefiles`: Exposes CRUD operations for the **zonefiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zonefiles
    * const zonefiles = await prisma.zonefiles.findMany()
    * ```
    */
  get zonefiles(): Prisma.zonefilesDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.7.1
   * Query Engine version: 272861e07ab64f234d3ffc4094e32bd61775599c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    blocks: 'blocks',
    burnchain_rewards: 'burnchain_rewards',
    config_state: 'config_state',
    ContractLogs: 'ContractLogs',
    event_observer_requests: 'event_observer_requests',
    faucet_requests: 'faucet_requests',
    ft_events: 'ft_events',
    ft_metadata: 'ft_metadata',
    mempool_txs: 'mempool_txs',
    microblocks: 'microblocks',
    miner_rewards: 'miner_rewards',
    names: 'names',
    namespaces: 'namespaces',
    nft_events: 'nft_events',
    nft_metadata: 'nft_metadata',
    pgmigrations: 'pgmigrations',
    pox2_events: 'pox2_events',
    pox_state: 'pox_state',
    principal_stx_txs: 'principal_stx_txs',
    reward_slot_holders: 'reward_slot_holders',
    smart_contracts: 'smart_contracts',
    stx_events: 'stx_events',
    stx_lock_events: 'stx_lock_events',
    subdomains: 'subdomains',
    token_metadata_queue: 'token_metadata_queue',
    token_offering_locked: 'token_offering_locked',
    txs: 'txs',
    zonefiles: 'zonefiles'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model blocks
   */


  export type AggregateBlocks = {
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  export type BlocksAvgAggregateOutputType = {
    block_height: number | null
    burn_block_time: number | null
    burn_block_height: number | null
    parent_microblock_sequence: number | null
    execution_cost_read_count: number | null
    execution_cost_read_length: number | null
    execution_cost_runtime: number | null
    execution_cost_write_count: number | null
    execution_cost_write_length: number | null
  }

  export type BlocksSumAggregateOutputType = {
    block_height: number | null
    burn_block_time: number | null
    burn_block_height: number | null
    parent_microblock_sequence: number | null
    execution_cost_read_count: bigint | null
    execution_cost_read_length: bigint | null
    execution_cost_runtime: bigint | null
    execution_cost_write_count: bigint | null
    execution_cost_write_length: bigint | null
  }

  export type BlocksMinAggregateOutputType = {
    index_block_hash: Buffer | null
    block_hash: Buffer | null
    block_height: number | null
    burn_block_time: number | null
    burn_block_hash: Buffer | null
    burn_block_height: number | null
    miner_txid: Buffer | null
    parent_index_block_hash: Buffer | null
    parent_block_hash: Buffer | null
    parent_microblock_hash: Buffer | null
    parent_microblock_sequence: number | null
    canonical: boolean | null
    execution_cost_read_count: bigint | null
    execution_cost_read_length: bigint | null
    execution_cost_runtime: bigint | null
    execution_cost_write_count: bigint | null
    execution_cost_write_length: bigint | null
  }

  export type BlocksMaxAggregateOutputType = {
    index_block_hash: Buffer | null
    block_hash: Buffer | null
    block_height: number | null
    burn_block_time: number | null
    burn_block_hash: Buffer | null
    burn_block_height: number | null
    miner_txid: Buffer | null
    parent_index_block_hash: Buffer | null
    parent_block_hash: Buffer | null
    parent_microblock_hash: Buffer | null
    parent_microblock_sequence: number | null
    canonical: boolean | null
    execution_cost_read_count: bigint | null
    execution_cost_read_length: bigint | null
    execution_cost_runtime: bigint | null
    execution_cost_write_count: bigint | null
    execution_cost_write_length: bigint | null
  }

  export type BlocksCountAggregateOutputType = {
    index_block_hash: number
    block_hash: number
    block_height: number
    burn_block_time: number
    burn_block_hash: number
    burn_block_height: number
    miner_txid: number
    parent_index_block_hash: number
    parent_block_hash: number
    parent_microblock_hash: number
    parent_microblock_sequence: number
    canonical: number
    execution_cost_read_count: number
    execution_cost_read_length: number
    execution_cost_runtime: number
    execution_cost_write_count: number
    execution_cost_write_length: number
    _all: number
  }


  export type BlocksAvgAggregateInputType = {
    block_height?: true
    burn_block_time?: true
    burn_block_height?: true
    parent_microblock_sequence?: true
    execution_cost_read_count?: true
    execution_cost_read_length?: true
    execution_cost_runtime?: true
    execution_cost_write_count?: true
    execution_cost_write_length?: true
  }

  export type BlocksSumAggregateInputType = {
    block_height?: true
    burn_block_time?: true
    burn_block_height?: true
    parent_microblock_sequence?: true
    execution_cost_read_count?: true
    execution_cost_read_length?: true
    execution_cost_runtime?: true
    execution_cost_write_count?: true
    execution_cost_write_length?: true
  }

  export type BlocksMinAggregateInputType = {
    index_block_hash?: true
    block_hash?: true
    block_height?: true
    burn_block_time?: true
    burn_block_hash?: true
    burn_block_height?: true
    miner_txid?: true
    parent_index_block_hash?: true
    parent_block_hash?: true
    parent_microblock_hash?: true
    parent_microblock_sequence?: true
    canonical?: true
    execution_cost_read_count?: true
    execution_cost_read_length?: true
    execution_cost_runtime?: true
    execution_cost_write_count?: true
    execution_cost_write_length?: true
  }

  export type BlocksMaxAggregateInputType = {
    index_block_hash?: true
    block_hash?: true
    block_height?: true
    burn_block_time?: true
    burn_block_hash?: true
    burn_block_height?: true
    miner_txid?: true
    parent_index_block_hash?: true
    parent_block_hash?: true
    parent_microblock_hash?: true
    parent_microblock_sequence?: true
    canonical?: true
    execution_cost_read_count?: true
    execution_cost_read_length?: true
    execution_cost_runtime?: true
    execution_cost_write_count?: true
    execution_cost_write_length?: true
  }

  export type BlocksCountAggregateInputType = {
    index_block_hash?: true
    block_hash?: true
    block_height?: true
    burn_block_time?: true
    burn_block_hash?: true
    burn_block_height?: true
    miner_txid?: true
    parent_index_block_hash?: true
    parent_block_hash?: true
    parent_microblock_hash?: true
    parent_microblock_sequence?: true
    canonical?: true
    execution_cost_read_count?: true
    execution_cost_read_length?: true
    execution_cost_runtime?: true
    execution_cost_write_count?: true
    execution_cost_write_length?: true
    _all?: true
  }

  export type BlocksAggregateArgs = {
    /**
     * Filter which blocks to aggregate.
     * 
    **/
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     * 
    **/
    orderBy?: Enumerable<blocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blocks
    **/
    _count?: true | BlocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlocksMaxAggregateInputType
  }

  export type GetBlocksAggregateType<T extends BlocksAggregateArgs> = {
        [P in keyof T & keyof AggregateBlocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlocks[P]>
      : GetScalarType<T[P], AggregateBlocks[P]>
  }




  export type BlocksGroupByArgs = {
    where?: blocksWhereInput
    orderBy?: Enumerable<blocksOrderByWithAggregationInput>
    by: Array<BlocksScalarFieldEnum>
    having?: blocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlocksCountAggregateInputType | true
    _avg?: BlocksAvgAggregateInputType
    _sum?: BlocksSumAggregateInputType
    _min?: BlocksMinAggregateInputType
    _max?: BlocksMaxAggregateInputType
  }


  export type BlocksGroupByOutputType = {
    index_block_hash: Buffer
    block_hash: Buffer
    block_height: number
    burn_block_time: number
    burn_block_hash: Buffer
    burn_block_height: number
    miner_txid: Buffer
    parent_index_block_hash: Buffer
    parent_block_hash: Buffer
    parent_microblock_hash: Buffer
    parent_microblock_sequence: number
    canonical: boolean
    execution_cost_read_count: bigint
    execution_cost_read_length: bigint
    execution_cost_runtime: bigint
    execution_cost_write_count: bigint
    execution_cost_write_length: bigint
    _count: BlocksCountAggregateOutputType | null
    _avg: BlocksAvgAggregateOutputType | null
    _sum: BlocksSumAggregateOutputType | null
    _min: BlocksMinAggregateOutputType | null
    _max: BlocksMaxAggregateOutputType | null
  }

  type GetBlocksGroupByPayload<T extends BlocksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<BlocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlocksGroupByOutputType[P]>
            : GetScalarType<T[P], BlocksGroupByOutputType[P]>
        }
      >
    >


  export type blocksSelect = {
    index_block_hash?: boolean
    block_hash?: boolean
    block_height?: boolean
    burn_block_time?: boolean
    burn_block_hash?: boolean
    burn_block_height?: boolean
    miner_txid?: boolean
    parent_index_block_hash?: boolean
    parent_block_hash?: boolean
    parent_microblock_hash?: boolean
    parent_microblock_sequence?: boolean
    canonical?: boolean
    execution_cost_read_count?: boolean
    execution_cost_read_length?: boolean
    execution_cost_runtime?: boolean
    execution_cost_write_count?: boolean
    execution_cost_write_length?: boolean
  }


  export type blocksGetPayload<S extends boolean | null | undefined | blocksArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? blocks :
    S extends undefined ? never :
    S extends { include: any } & (blocksArgs | blocksFindManyArgs)
    ? blocks 
    : S extends { select: any } & (blocksArgs | blocksFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof blocks ? blocks[P] : never
  } 
      : blocks


  type blocksCountArgs = Merge<
    Omit<blocksFindManyArgs, 'select' | 'include'> & {
      select?: BlocksCountAggregateInputType | true
    }
  >

  export interface blocksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Blocks that matches the filter.
     * @param {blocksFindUniqueArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends blocksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, blocksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'blocks'> extends True ? Prisma__blocksClient<blocksGetPayload<T>> : Prisma__blocksClient<blocksGetPayload<T> | null, null>

    /**
     * Find one Blocks that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {blocksFindUniqueOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends blocksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, blocksFindUniqueOrThrowArgs>
    ): Prisma__blocksClient<blocksGetPayload<T>>

    /**
     * Find the first Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends blocksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, blocksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'blocks'> extends True ? Prisma__blocksClient<blocksGetPayload<T>> : Prisma__blocksClient<blocksGetPayload<T> | null, null>

    /**
     * Find the first Blocks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindFirstOrThrowArgs} args - Arguments to find a Blocks
     * @example
     * // Get one Blocks
     * const blocks = await prisma.blocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends blocksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, blocksFindFirstOrThrowArgs>
    ): Prisma__blocksClient<blocksGetPayload<T>>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.blocks.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.blocks.findMany({ take: 10 })
     * 
     * // Only select the `index_block_hash`
     * const blocksWithIndex_block_hashOnly = await prisma.blocks.findMany({ select: { index_block_hash: true } })
     * 
    **/
    findMany<T extends blocksFindManyArgs>(
      args?: SelectSubset<T, blocksFindManyArgs>
    ): PrismaPromise<Array<blocksGetPayload<T>>>

    /**
     * Create a Blocks.
     * @param {blocksCreateArgs} args - Arguments to create a Blocks.
     * @example
     * // Create one Blocks
     * const Blocks = await prisma.blocks.create({
     *   data: {
     *     // ... data to create a Blocks
     *   }
     * })
     * 
    **/
    create<T extends blocksCreateArgs>(
      args: SelectSubset<T, blocksCreateArgs>
    ): Prisma__blocksClient<blocksGetPayload<T>>

    /**
     * Create many Blocks.
     *     @param {blocksCreateManyArgs} args - Arguments to create many Blocks.
     *     @example
     *     // Create many Blocks
     *     const blocks = await prisma.blocks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends blocksCreateManyArgs>(
      args?: SelectSubset<T, blocksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Blocks.
     * @param {blocksDeleteArgs} args - Arguments to delete one Blocks.
     * @example
     * // Delete one Blocks
     * const Blocks = await prisma.blocks.delete({
     *   where: {
     *     // ... filter to delete one Blocks
     *   }
     * })
     * 
    **/
    delete<T extends blocksDeleteArgs>(
      args: SelectSubset<T, blocksDeleteArgs>
    ): Prisma__blocksClient<blocksGetPayload<T>>

    /**
     * Update one Blocks.
     * @param {blocksUpdateArgs} args - Arguments to update one Blocks.
     * @example
     * // Update one Blocks
     * const blocks = await prisma.blocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends blocksUpdateArgs>(
      args: SelectSubset<T, blocksUpdateArgs>
    ): Prisma__blocksClient<blocksGetPayload<T>>

    /**
     * Delete zero or more Blocks.
     * @param {blocksDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.blocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends blocksDeleteManyArgs>(
      args?: SelectSubset<T, blocksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const blocks = await prisma.blocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends blocksUpdateManyArgs>(
      args: SelectSubset<T, blocksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Blocks.
     * @param {blocksUpsertArgs} args - Arguments to update or create a Blocks.
     * @example
     * // Update or create a Blocks
     * const blocks = await prisma.blocks.upsert({
     *   create: {
     *     // ... data to create a Blocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blocks we want to update
     *   }
     * })
    **/
    upsert<T extends blocksUpsertArgs>(
      args: SelectSubset<T, blocksUpsertArgs>
    ): Prisma__blocksClient<blocksGetPayload<T>>

    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blocksCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.blocks.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends blocksCountArgs>(
      args?: Subset<T, blocksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlocksAggregateArgs>(args: Subset<T, BlocksAggregateArgs>): PrismaPromise<GetBlocksAggregateType<T>>

    /**
     * Group by Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlocksGroupByArgs['orderBy'] }
        : { orderBy?: BlocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlocksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for blocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__blocksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * blocks base type for findUnique actions
   */
  export type blocksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the blocks
     * 
    **/
    select?: blocksSelect | null
    /**
     * Filter, which blocks to fetch.
     * 
    **/
    where: blocksWhereUniqueInput
  }

  /**
   * blocks: findUnique
   */
  export interface blocksFindUniqueArgs extends blocksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * blocks findUniqueOrThrow
   */
  export type blocksFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the blocks
     * 
    **/
    select?: blocksSelect | null
    /**
     * Filter, which blocks to fetch.
     * 
    **/
    where: blocksWhereUniqueInput
  }


  /**
   * blocks base type for findFirst actions
   */
  export type blocksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the blocks
     * 
    **/
    select?: blocksSelect | null
    /**
     * Filter, which blocks to fetch.
     * 
    **/
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     * 
    **/
    orderBy?: Enumerable<blocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     * 
    **/
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     * 
    **/
    distinct?: Enumerable<BlocksScalarFieldEnum>
  }

  /**
   * blocks: findFirst
   */
  export interface blocksFindFirstArgs extends blocksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * blocks findFirstOrThrow
   */
  export type blocksFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the blocks
     * 
    **/
    select?: blocksSelect | null
    /**
     * Filter, which blocks to fetch.
     * 
    **/
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     * 
    **/
    orderBy?: Enumerable<blocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blocks.
     * 
    **/
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blocks.
     * 
    **/
    distinct?: Enumerable<BlocksScalarFieldEnum>
  }


  /**
   * blocks findMany
   */
  export type blocksFindManyArgs = {
    /**
     * Select specific fields to fetch from the blocks
     * 
    **/
    select?: blocksSelect | null
    /**
     * Filter, which blocks to fetch.
     * 
    **/
    where?: blocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blocks to fetch.
     * 
    **/
    orderBy?: Enumerable<blocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blocks.
     * 
    **/
    cursor?: blocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blocks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<BlocksScalarFieldEnum>
  }


  /**
   * blocks create
   */
  export type blocksCreateArgs = {
    /**
     * Select specific fields to fetch from the blocks
     * 
    **/
    select?: blocksSelect | null
    /**
     * The data needed to create a blocks.
     * 
    **/
    data: XOR<blocksCreateInput, blocksUncheckedCreateInput>
  }


  /**
   * blocks createMany
   */
  export type blocksCreateManyArgs = {
    /**
     * The data used to create many blocks.
     * 
    **/
    data: Enumerable<blocksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * blocks update
   */
  export type blocksUpdateArgs = {
    /**
     * Select specific fields to fetch from the blocks
     * 
    **/
    select?: blocksSelect | null
    /**
     * The data needed to update a blocks.
     * 
    **/
    data: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
    /**
     * Choose, which blocks to update.
     * 
    **/
    where: blocksWhereUniqueInput
  }


  /**
   * blocks updateMany
   */
  export type blocksUpdateManyArgs = {
    /**
     * The data used to update blocks.
     * 
    **/
    data: XOR<blocksUpdateManyMutationInput, blocksUncheckedUpdateManyInput>
    /**
     * Filter which blocks to update
     * 
    **/
    where?: blocksWhereInput
  }


  /**
   * blocks upsert
   */
  export type blocksUpsertArgs = {
    /**
     * Select specific fields to fetch from the blocks
     * 
    **/
    select?: blocksSelect | null
    /**
     * The filter to search for the blocks to update in case it exists.
     * 
    **/
    where: blocksWhereUniqueInput
    /**
     * In case the blocks found by the `where` argument doesn't exist, create a new blocks with this data.
     * 
    **/
    create: XOR<blocksCreateInput, blocksUncheckedCreateInput>
    /**
     * In case the blocks was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<blocksUpdateInput, blocksUncheckedUpdateInput>
  }


  /**
   * blocks delete
   */
  export type blocksDeleteArgs = {
    /**
     * Select specific fields to fetch from the blocks
     * 
    **/
    select?: blocksSelect | null
    /**
     * Filter which blocks to delete.
     * 
    **/
    where: blocksWhereUniqueInput
  }


  /**
   * blocks deleteMany
   */
  export type blocksDeleteManyArgs = {
    /**
     * Filter which blocks to delete
     * 
    **/
    where?: blocksWhereInput
  }


  /**
   * blocks without action
   */
  export type blocksArgs = {
    /**
     * Select specific fields to fetch from the blocks
     * 
    **/
    select?: blocksSelect | null
  }



  /**
   * Model burnchain_rewards
   */


  export type AggregateBurnchain_rewards = {
    _count: Burnchain_rewardsCountAggregateOutputType | null
    _avg: Burnchain_rewardsAvgAggregateOutputType | null
    _sum: Burnchain_rewardsSumAggregateOutputType | null
    _min: Burnchain_rewardsMinAggregateOutputType | null
    _max: Burnchain_rewardsMaxAggregateOutputType | null
  }

  export type Burnchain_rewardsAvgAggregateOutputType = {
    id: number | null
    burn_block_height: number | null
    burn_amount: Decimal | null
    reward_amount: Decimal | null
    reward_index: number | null
  }

  export type Burnchain_rewardsSumAggregateOutputType = {
    id: number | null
    burn_block_height: number | null
    burn_amount: Decimal | null
    reward_amount: Decimal | null
    reward_index: number | null
  }

  export type Burnchain_rewardsMinAggregateOutputType = {
    id: number | null
    canonical: boolean | null
    burn_block_hash: Buffer | null
    burn_block_height: number | null
    burn_amount: Decimal | null
    reward_recipient: string | null
    reward_amount: Decimal | null
    reward_index: number | null
  }

  export type Burnchain_rewardsMaxAggregateOutputType = {
    id: number | null
    canonical: boolean | null
    burn_block_hash: Buffer | null
    burn_block_height: number | null
    burn_amount: Decimal | null
    reward_recipient: string | null
    reward_amount: Decimal | null
    reward_index: number | null
  }

  export type Burnchain_rewardsCountAggregateOutputType = {
    id: number
    canonical: number
    burn_block_hash: number
    burn_block_height: number
    burn_amount: number
    reward_recipient: number
    reward_amount: number
    reward_index: number
    _all: number
  }


  export type Burnchain_rewardsAvgAggregateInputType = {
    id?: true
    burn_block_height?: true
    burn_amount?: true
    reward_amount?: true
    reward_index?: true
  }

  export type Burnchain_rewardsSumAggregateInputType = {
    id?: true
    burn_block_height?: true
    burn_amount?: true
    reward_amount?: true
    reward_index?: true
  }

  export type Burnchain_rewardsMinAggregateInputType = {
    id?: true
    canonical?: true
    burn_block_hash?: true
    burn_block_height?: true
    burn_amount?: true
    reward_recipient?: true
    reward_amount?: true
    reward_index?: true
  }

  export type Burnchain_rewardsMaxAggregateInputType = {
    id?: true
    canonical?: true
    burn_block_hash?: true
    burn_block_height?: true
    burn_amount?: true
    reward_recipient?: true
    reward_amount?: true
    reward_index?: true
  }

  export type Burnchain_rewardsCountAggregateInputType = {
    id?: true
    canonical?: true
    burn_block_hash?: true
    burn_block_height?: true
    burn_amount?: true
    reward_recipient?: true
    reward_amount?: true
    reward_index?: true
    _all?: true
  }

  export type Burnchain_rewardsAggregateArgs = {
    /**
     * Filter which burnchain_rewards to aggregate.
     * 
    **/
    where?: burnchain_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of burnchain_rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<burnchain_rewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: burnchain_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` burnchain_rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` burnchain_rewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned burnchain_rewards
    **/
    _count?: true | Burnchain_rewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Burnchain_rewardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Burnchain_rewardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Burnchain_rewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Burnchain_rewardsMaxAggregateInputType
  }

  export type GetBurnchain_rewardsAggregateType<T extends Burnchain_rewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateBurnchain_rewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBurnchain_rewards[P]>
      : GetScalarType<T[P], AggregateBurnchain_rewards[P]>
  }




  export type Burnchain_rewardsGroupByArgs = {
    where?: burnchain_rewardsWhereInput
    orderBy?: Enumerable<burnchain_rewardsOrderByWithAggregationInput>
    by: Array<Burnchain_rewardsScalarFieldEnum>
    having?: burnchain_rewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Burnchain_rewardsCountAggregateInputType | true
    _avg?: Burnchain_rewardsAvgAggregateInputType
    _sum?: Burnchain_rewardsSumAggregateInputType
    _min?: Burnchain_rewardsMinAggregateInputType
    _max?: Burnchain_rewardsMaxAggregateInputType
  }


  export type Burnchain_rewardsGroupByOutputType = {
    id: number
    canonical: boolean
    burn_block_hash: Buffer
    burn_block_height: number
    burn_amount: Decimal
    reward_recipient: string
    reward_amount: Decimal
    reward_index: number
    _count: Burnchain_rewardsCountAggregateOutputType | null
    _avg: Burnchain_rewardsAvgAggregateOutputType | null
    _sum: Burnchain_rewardsSumAggregateOutputType | null
    _min: Burnchain_rewardsMinAggregateOutputType | null
    _max: Burnchain_rewardsMaxAggregateOutputType | null
  }

  type GetBurnchain_rewardsGroupByPayload<T extends Burnchain_rewardsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Burnchain_rewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Burnchain_rewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Burnchain_rewardsGroupByOutputType[P]>
            : GetScalarType<T[P], Burnchain_rewardsGroupByOutputType[P]>
        }
      >
    >


  export type burnchain_rewardsSelect = {
    id?: boolean
    canonical?: boolean
    burn_block_hash?: boolean
    burn_block_height?: boolean
    burn_amount?: boolean
    reward_recipient?: boolean
    reward_amount?: boolean
    reward_index?: boolean
  }


  export type burnchain_rewardsGetPayload<S extends boolean | null | undefined | burnchain_rewardsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? burnchain_rewards :
    S extends undefined ? never :
    S extends { include: any } & (burnchain_rewardsArgs | burnchain_rewardsFindManyArgs)
    ? burnchain_rewards 
    : S extends { select: any } & (burnchain_rewardsArgs | burnchain_rewardsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof burnchain_rewards ? burnchain_rewards[P] : never
  } 
      : burnchain_rewards


  type burnchain_rewardsCountArgs = Merge<
    Omit<burnchain_rewardsFindManyArgs, 'select' | 'include'> & {
      select?: Burnchain_rewardsCountAggregateInputType | true
    }
  >

  export interface burnchain_rewardsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Burnchain_rewards that matches the filter.
     * @param {burnchain_rewardsFindUniqueArgs} args - Arguments to find a Burnchain_rewards
     * @example
     * // Get one Burnchain_rewards
     * const burnchain_rewards = await prisma.burnchain_rewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends burnchain_rewardsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, burnchain_rewardsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'burnchain_rewards'> extends True ? Prisma__burnchain_rewardsClient<burnchain_rewardsGetPayload<T>> : Prisma__burnchain_rewardsClient<burnchain_rewardsGetPayload<T> | null, null>

    /**
     * Find one Burnchain_rewards that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {burnchain_rewardsFindUniqueOrThrowArgs} args - Arguments to find a Burnchain_rewards
     * @example
     * // Get one Burnchain_rewards
     * const burnchain_rewards = await prisma.burnchain_rewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends burnchain_rewardsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, burnchain_rewardsFindUniqueOrThrowArgs>
    ): Prisma__burnchain_rewardsClient<burnchain_rewardsGetPayload<T>>

    /**
     * Find the first Burnchain_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {burnchain_rewardsFindFirstArgs} args - Arguments to find a Burnchain_rewards
     * @example
     * // Get one Burnchain_rewards
     * const burnchain_rewards = await prisma.burnchain_rewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends burnchain_rewardsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, burnchain_rewardsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'burnchain_rewards'> extends True ? Prisma__burnchain_rewardsClient<burnchain_rewardsGetPayload<T>> : Prisma__burnchain_rewardsClient<burnchain_rewardsGetPayload<T> | null, null>

    /**
     * Find the first Burnchain_rewards that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {burnchain_rewardsFindFirstOrThrowArgs} args - Arguments to find a Burnchain_rewards
     * @example
     * // Get one Burnchain_rewards
     * const burnchain_rewards = await prisma.burnchain_rewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends burnchain_rewardsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, burnchain_rewardsFindFirstOrThrowArgs>
    ): Prisma__burnchain_rewardsClient<burnchain_rewardsGetPayload<T>>

    /**
     * Find zero or more Burnchain_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {burnchain_rewardsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Burnchain_rewards
     * const burnchain_rewards = await prisma.burnchain_rewards.findMany()
     * 
     * // Get first 10 Burnchain_rewards
     * const burnchain_rewards = await prisma.burnchain_rewards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const burnchain_rewardsWithIdOnly = await prisma.burnchain_rewards.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends burnchain_rewardsFindManyArgs>(
      args?: SelectSubset<T, burnchain_rewardsFindManyArgs>
    ): PrismaPromise<Array<burnchain_rewardsGetPayload<T>>>

    /**
     * Create a Burnchain_rewards.
     * @param {burnchain_rewardsCreateArgs} args - Arguments to create a Burnchain_rewards.
     * @example
     * // Create one Burnchain_rewards
     * const Burnchain_rewards = await prisma.burnchain_rewards.create({
     *   data: {
     *     // ... data to create a Burnchain_rewards
     *   }
     * })
     * 
    **/
    create<T extends burnchain_rewardsCreateArgs>(
      args: SelectSubset<T, burnchain_rewardsCreateArgs>
    ): Prisma__burnchain_rewardsClient<burnchain_rewardsGetPayload<T>>

    /**
     * Create many Burnchain_rewards.
     *     @param {burnchain_rewardsCreateManyArgs} args - Arguments to create many Burnchain_rewards.
     *     @example
     *     // Create many Burnchain_rewards
     *     const burnchain_rewards = await prisma.burnchain_rewards.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends burnchain_rewardsCreateManyArgs>(
      args?: SelectSubset<T, burnchain_rewardsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Burnchain_rewards.
     * @param {burnchain_rewardsDeleteArgs} args - Arguments to delete one Burnchain_rewards.
     * @example
     * // Delete one Burnchain_rewards
     * const Burnchain_rewards = await prisma.burnchain_rewards.delete({
     *   where: {
     *     // ... filter to delete one Burnchain_rewards
     *   }
     * })
     * 
    **/
    delete<T extends burnchain_rewardsDeleteArgs>(
      args: SelectSubset<T, burnchain_rewardsDeleteArgs>
    ): Prisma__burnchain_rewardsClient<burnchain_rewardsGetPayload<T>>

    /**
     * Update one Burnchain_rewards.
     * @param {burnchain_rewardsUpdateArgs} args - Arguments to update one Burnchain_rewards.
     * @example
     * // Update one Burnchain_rewards
     * const burnchain_rewards = await prisma.burnchain_rewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends burnchain_rewardsUpdateArgs>(
      args: SelectSubset<T, burnchain_rewardsUpdateArgs>
    ): Prisma__burnchain_rewardsClient<burnchain_rewardsGetPayload<T>>

    /**
     * Delete zero or more Burnchain_rewards.
     * @param {burnchain_rewardsDeleteManyArgs} args - Arguments to filter Burnchain_rewards to delete.
     * @example
     * // Delete a few Burnchain_rewards
     * const { count } = await prisma.burnchain_rewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends burnchain_rewardsDeleteManyArgs>(
      args?: SelectSubset<T, burnchain_rewardsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Burnchain_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {burnchain_rewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Burnchain_rewards
     * const burnchain_rewards = await prisma.burnchain_rewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends burnchain_rewardsUpdateManyArgs>(
      args: SelectSubset<T, burnchain_rewardsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Burnchain_rewards.
     * @param {burnchain_rewardsUpsertArgs} args - Arguments to update or create a Burnchain_rewards.
     * @example
     * // Update or create a Burnchain_rewards
     * const burnchain_rewards = await prisma.burnchain_rewards.upsert({
     *   create: {
     *     // ... data to create a Burnchain_rewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Burnchain_rewards we want to update
     *   }
     * })
    **/
    upsert<T extends burnchain_rewardsUpsertArgs>(
      args: SelectSubset<T, burnchain_rewardsUpsertArgs>
    ): Prisma__burnchain_rewardsClient<burnchain_rewardsGetPayload<T>>

    /**
     * Count the number of Burnchain_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {burnchain_rewardsCountArgs} args - Arguments to filter Burnchain_rewards to count.
     * @example
     * // Count the number of Burnchain_rewards
     * const count = await prisma.burnchain_rewards.count({
     *   where: {
     *     // ... the filter for the Burnchain_rewards we want to count
     *   }
     * })
    **/
    count<T extends burnchain_rewardsCountArgs>(
      args?: Subset<T, burnchain_rewardsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Burnchain_rewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Burnchain_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Burnchain_rewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Burnchain_rewardsAggregateArgs>(args: Subset<T, Burnchain_rewardsAggregateArgs>): PrismaPromise<GetBurnchain_rewardsAggregateType<T>>

    /**
     * Group by Burnchain_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Burnchain_rewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Burnchain_rewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Burnchain_rewardsGroupByArgs['orderBy'] }
        : { orderBy?: Burnchain_rewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Burnchain_rewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBurnchain_rewardsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for burnchain_rewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__burnchain_rewardsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * burnchain_rewards base type for findUnique actions
   */
  export type burnchain_rewardsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the burnchain_rewards
     * 
    **/
    select?: burnchain_rewardsSelect | null
    /**
     * Filter, which burnchain_rewards to fetch.
     * 
    **/
    where: burnchain_rewardsWhereUniqueInput
  }

  /**
   * burnchain_rewards: findUnique
   */
  export interface burnchain_rewardsFindUniqueArgs extends burnchain_rewardsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * burnchain_rewards findUniqueOrThrow
   */
  export type burnchain_rewardsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the burnchain_rewards
     * 
    **/
    select?: burnchain_rewardsSelect | null
    /**
     * Filter, which burnchain_rewards to fetch.
     * 
    **/
    where: burnchain_rewardsWhereUniqueInput
  }


  /**
   * burnchain_rewards base type for findFirst actions
   */
  export type burnchain_rewardsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the burnchain_rewards
     * 
    **/
    select?: burnchain_rewardsSelect | null
    /**
     * Filter, which burnchain_rewards to fetch.
     * 
    **/
    where?: burnchain_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of burnchain_rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<burnchain_rewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for burnchain_rewards.
     * 
    **/
    cursor?: burnchain_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` burnchain_rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` burnchain_rewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of burnchain_rewards.
     * 
    **/
    distinct?: Enumerable<Burnchain_rewardsScalarFieldEnum>
  }

  /**
   * burnchain_rewards: findFirst
   */
  export interface burnchain_rewardsFindFirstArgs extends burnchain_rewardsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * burnchain_rewards findFirstOrThrow
   */
  export type burnchain_rewardsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the burnchain_rewards
     * 
    **/
    select?: burnchain_rewardsSelect | null
    /**
     * Filter, which burnchain_rewards to fetch.
     * 
    **/
    where?: burnchain_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of burnchain_rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<burnchain_rewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for burnchain_rewards.
     * 
    **/
    cursor?: burnchain_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` burnchain_rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` burnchain_rewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of burnchain_rewards.
     * 
    **/
    distinct?: Enumerable<Burnchain_rewardsScalarFieldEnum>
  }


  /**
   * burnchain_rewards findMany
   */
  export type burnchain_rewardsFindManyArgs = {
    /**
     * Select specific fields to fetch from the burnchain_rewards
     * 
    **/
    select?: burnchain_rewardsSelect | null
    /**
     * Filter, which burnchain_rewards to fetch.
     * 
    **/
    where?: burnchain_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of burnchain_rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<burnchain_rewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing burnchain_rewards.
     * 
    **/
    cursor?: burnchain_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` burnchain_rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` burnchain_rewards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Burnchain_rewardsScalarFieldEnum>
  }


  /**
   * burnchain_rewards create
   */
  export type burnchain_rewardsCreateArgs = {
    /**
     * Select specific fields to fetch from the burnchain_rewards
     * 
    **/
    select?: burnchain_rewardsSelect | null
    /**
     * The data needed to create a burnchain_rewards.
     * 
    **/
    data: XOR<burnchain_rewardsCreateInput, burnchain_rewardsUncheckedCreateInput>
  }


  /**
   * burnchain_rewards createMany
   */
  export type burnchain_rewardsCreateManyArgs = {
    /**
     * The data used to create many burnchain_rewards.
     * 
    **/
    data: Enumerable<burnchain_rewardsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * burnchain_rewards update
   */
  export type burnchain_rewardsUpdateArgs = {
    /**
     * Select specific fields to fetch from the burnchain_rewards
     * 
    **/
    select?: burnchain_rewardsSelect | null
    /**
     * The data needed to update a burnchain_rewards.
     * 
    **/
    data: XOR<burnchain_rewardsUpdateInput, burnchain_rewardsUncheckedUpdateInput>
    /**
     * Choose, which burnchain_rewards to update.
     * 
    **/
    where: burnchain_rewardsWhereUniqueInput
  }


  /**
   * burnchain_rewards updateMany
   */
  export type burnchain_rewardsUpdateManyArgs = {
    /**
     * The data used to update burnchain_rewards.
     * 
    **/
    data: XOR<burnchain_rewardsUpdateManyMutationInput, burnchain_rewardsUncheckedUpdateManyInput>
    /**
     * Filter which burnchain_rewards to update
     * 
    **/
    where?: burnchain_rewardsWhereInput
  }


  /**
   * burnchain_rewards upsert
   */
  export type burnchain_rewardsUpsertArgs = {
    /**
     * Select specific fields to fetch from the burnchain_rewards
     * 
    **/
    select?: burnchain_rewardsSelect | null
    /**
     * The filter to search for the burnchain_rewards to update in case it exists.
     * 
    **/
    where: burnchain_rewardsWhereUniqueInput
    /**
     * In case the burnchain_rewards found by the `where` argument doesn't exist, create a new burnchain_rewards with this data.
     * 
    **/
    create: XOR<burnchain_rewardsCreateInput, burnchain_rewardsUncheckedCreateInput>
    /**
     * In case the burnchain_rewards was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<burnchain_rewardsUpdateInput, burnchain_rewardsUncheckedUpdateInput>
  }


  /**
   * burnchain_rewards delete
   */
  export type burnchain_rewardsDeleteArgs = {
    /**
     * Select specific fields to fetch from the burnchain_rewards
     * 
    **/
    select?: burnchain_rewardsSelect | null
    /**
     * Filter which burnchain_rewards to delete.
     * 
    **/
    where: burnchain_rewardsWhereUniqueInput
  }


  /**
   * burnchain_rewards deleteMany
   */
  export type burnchain_rewardsDeleteManyArgs = {
    /**
     * Filter which burnchain_rewards to delete
     * 
    **/
    where?: burnchain_rewardsWhereInput
  }


  /**
   * burnchain_rewards without action
   */
  export type burnchain_rewardsArgs = {
    /**
     * Select specific fields to fetch from the burnchain_rewards
     * 
    **/
    select?: burnchain_rewardsSelect | null
  }



  /**
   * Model config_state
   */


  export type AggregateConfig_state = {
    _count: Config_stateCountAggregateOutputType | null
    _min: Config_stateMinAggregateOutputType | null
    _max: Config_stateMaxAggregateOutputType | null
  }

  export type Config_stateMinAggregateOutputType = {
    id: boolean | null
    bns_names_onchain_imported: boolean | null
    bns_subdomains_imported: boolean | null
    token_offering_imported: boolean | null
  }

  export type Config_stateMaxAggregateOutputType = {
    id: boolean | null
    bns_names_onchain_imported: boolean | null
    bns_subdomains_imported: boolean | null
    token_offering_imported: boolean | null
  }

  export type Config_stateCountAggregateOutputType = {
    id: number
    bns_names_onchain_imported: number
    bns_subdomains_imported: number
    token_offering_imported: number
    _all: number
  }


  export type Config_stateMinAggregateInputType = {
    id?: true
    bns_names_onchain_imported?: true
    bns_subdomains_imported?: true
    token_offering_imported?: true
  }

  export type Config_stateMaxAggregateInputType = {
    id?: true
    bns_names_onchain_imported?: true
    bns_subdomains_imported?: true
    token_offering_imported?: true
  }

  export type Config_stateCountAggregateInputType = {
    id?: true
    bns_names_onchain_imported?: true
    bns_subdomains_imported?: true
    token_offering_imported?: true
    _all?: true
  }

  export type Config_stateAggregateArgs = {
    /**
     * Filter which config_state to aggregate.
     * 
    **/
    where?: config_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of config_states to fetch.
     * 
    **/
    orderBy?: Enumerable<config_stateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: config_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` config_states from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` config_states.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned config_states
    **/
    _count?: true | Config_stateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Config_stateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Config_stateMaxAggregateInputType
  }

  export type GetConfig_stateAggregateType<T extends Config_stateAggregateArgs> = {
        [P in keyof T & keyof AggregateConfig_state]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfig_state[P]>
      : GetScalarType<T[P], AggregateConfig_state[P]>
  }




  export type Config_stateGroupByArgs = {
    where?: config_stateWhereInput
    orderBy?: Enumerable<config_stateOrderByWithAggregationInput>
    by: Array<Config_stateScalarFieldEnum>
    having?: config_stateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Config_stateCountAggregateInputType | true
    _min?: Config_stateMinAggregateInputType
    _max?: Config_stateMaxAggregateInputType
  }


  export type Config_stateGroupByOutputType = {
    id: boolean
    bns_names_onchain_imported: boolean
    bns_subdomains_imported: boolean
    token_offering_imported: boolean
    _count: Config_stateCountAggregateOutputType | null
    _min: Config_stateMinAggregateOutputType | null
    _max: Config_stateMaxAggregateOutputType | null
  }

  type GetConfig_stateGroupByPayload<T extends Config_stateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Config_stateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Config_stateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Config_stateGroupByOutputType[P]>
            : GetScalarType<T[P], Config_stateGroupByOutputType[P]>
        }
      >
    >


  export type config_stateSelect = {
    id?: boolean
    bns_names_onchain_imported?: boolean
    bns_subdomains_imported?: boolean
    token_offering_imported?: boolean
  }


  export type config_stateGetPayload<S extends boolean | null | undefined | config_stateArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? config_state :
    S extends undefined ? never :
    S extends { include: any } & (config_stateArgs | config_stateFindManyArgs)
    ? config_state 
    : S extends { select: any } & (config_stateArgs | config_stateFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof config_state ? config_state[P] : never
  } 
      : config_state


  type config_stateCountArgs = Merge<
    Omit<config_stateFindManyArgs, 'select' | 'include'> & {
      select?: Config_stateCountAggregateInputType | true
    }
  >

  export interface config_stateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Config_state that matches the filter.
     * @param {config_stateFindUniqueArgs} args - Arguments to find a Config_state
     * @example
     * // Get one Config_state
     * const config_state = await prisma.config_state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends config_stateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, config_stateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'config_state'> extends True ? Prisma__config_stateClient<config_stateGetPayload<T>> : Prisma__config_stateClient<config_stateGetPayload<T> | null, null>

    /**
     * Find one Config_state that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {config_stateFindUniqueOrThrowArgs} args - Arguments to find a Config_state
     * @example
     * // Get one Config_state
     * const config_state = await prisma.config_state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends config_stateFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, config_stateFindUniqueOrThrowArgs>
    ): Prisma__config_stateClient<config_stateGetPayload<T>>

    /**
     * Find the first Config_state that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {config_stateFindFirstArgs} args - Arguments to find a Config_state
     * @example
     * // Get one Config_state
     * const config_state = await prisma.config_state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends config_stateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, config_stateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'config_state'> extends True ? Prisma__config_stateClient<config_stateGetPayload<T>> : Prisma__config_stateClient<config_stateGetPayload<T> | null, null>

    /**
     * Find the first Config_state that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {config_stateFindFirstOrThrowArgs} args - Arguments to find a Config_state
     * @example
     * // Get one Config_state
     * const config_state = await prisma.config_state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends config_stateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, config_stateFindFirstOrThrowArgs>
    ): Prisma__config_stateClient<config_stateGetPayload<T>>

    /**
     * Find zero or more Config_states that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {config_stateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Config_states
     * const config_states = await prisma.config_state.findMany()
     * 
     * // Get first 10 Config_states
     * const config_states = await prisma.config_state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const config_stateWithIdOnly = await prisma.config_state.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends config_stateFindManyArgs>(
      args?: SelectSubset<T, config_stateFindManyArgs>
    ): PrismaPromise<Array<config_stateGetPayload<T>>>

    /**
     * Create a Config_state.
     * @param {config_stateCreateArgs} args - Arguments to create a Config_state.
     * @example
     * // Create one Config_state
     * const Config_state = await prisma.config_state.create({
     *   data: {
     *     // ... data to create a Config_state
     *   }
     * })
     * 
    **/
    create<T extends config_stateCreateArgs>(
      args: SelectSubset<T, config_stateCreateArgs>
    ): Prisma__config_stateClient<config_stateGetPayload<T>>

    /**
     * Create many Config_states.
     *     @param {config_stateCreateManyArgs} args - Arguments to create many Config_states.
     *     @example
     *     // Create many Config_states
     *     const config_state = await prisma.config_state.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends config_stateCreateManyArgs>(
      args?: SelectSubset<T, config_stateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Config_state.
     * @param {config_stateDeleteArgs} args - Arguments to delete one Config_state.
     * @example
     * // Delete one Config_state
     * const Config_state = await prisma.config_state.delete({
     *   where: {
     *     // ... filter to delete one Config_state
     *   }
     * })
     * 
    **/
    delete<T extends config_stateDeleteArgs>(
      args: SelectSubset<T, config_stateDeleteArgs>
    ): Prisma__config_stateClient<config_stateGetPayload<T>>

    /**
     * Update one Config_state.
     * @param {config_stateUpdateArgs} args - Arguments to update one Config_state.
     * @example
     * // Update one Config_state
     * const config_state = await prisma.config_state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends config_stateUpdateArgs>(
      args: SelectSubset<T, config_stateUpdateArgs>
    ): Prisma__config_stateClient<config_stateGetPayload<T>>

    /**
     * Delete zero or more Config_states.
     * @param {config_stateDeleteManyArgs} args - Arguments to filter Config_states to delete.
     * @example
     * // Delete a few Config_states
     * const { count } = await prisma.config_state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends config_stateDeleteManyArgs>(
      args?: SelectSubset<T, config_stateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Config_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {config_stateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Config_states
     * const config_state = await prisma.config_state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends config_stateUpdateManyArgs>(
      args: SelectSubset<T, config_stateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Config_state.
     * @param {config_stateUpsertArgs} args - Arguments to update or create a Config_state.
     * @example
     * // Update or create a Config_state
     * const config_state = await prisma.config_state.upsert({
     *   create: {
     *     // ... data to create a Config_state
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Config_state we want to update
     *   }
     * })
    **/
    upsert<T extends config_stateUpsertArgs>(
      args: SelectSubset<T, config_stateUpsertArgs>
    ): Prisma__config_stateClient<config_stateGetPayload<T>>

    /**
     * Count the number of Config_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {config_stateCountArgs} args - Arguments to filter Config_states to count.
     * @example
     * // Count the number of Config_states
     * const count = await prisma.config_state.count({
     *   where: {
     *     // ... the filter for the Config_states we want to count
     *   }
     * })
    **/
    count<T extends config_stateCountArgs>(
      args?: Subset<T, config_stateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Config_stateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Config_state.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Config_stateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Config_stateAggregateArgs>(args: Subset<T, Config_stateAggregateArgs>): PrismaPromise<GetConfig_stateAggregateType<T>>

    /**
     * Group by Config_state.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Config_stateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Config_stateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Config_stateGroupByArgs['orderBy'] }
        : { orderBy?: Config_stateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Config_stateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfig_stateGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for config_state.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__config_stateClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * config_state base type for findUnique actions
   */
  export type config_stateFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the config_state
     * 
    **/
    select?: config_stateSelect | null
    /**
     * Filter, which config_state to fetch.
     * 
    **/
    where: config_stateWhereUniqueInput
  }

  /**
   * config_state: findUnique
   */
  export interface config_stateFindUniqueArgs extends config_stateFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * config_state findUniqueOrThrow
   */
  export type config_stateFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the config_state
     * 
    **/
    select?: config_stateSelect | null
    /**
     * Filter, which config_state to fetch.
     * 
    **/
    where: config_stateWhereUniqueInput
  }


  /**
   * config_state base type for findFirst actions
   */
  export type config_stateFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the config_state
     * 
    **/
    select?: config_stateSelect | null
    /**
     * Filter, which config_state to fetch.
     * 
    **/
    where?: config_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of config_states to fetch.
     * 
    **/
    orderBy?: Enumerable<config_stateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for config_states.
     * 
    **/
    cursor?: config_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` config_states from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` config_states.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of config_states.
     * 
    **/
    distinct?: Enumerable<Config_stateScalarFieldEnum>
  }

  /**
   * config_state: findFirst
   */
  export interface config_stateFindFirstArgs extends config_stateFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * config_state findFirstOrThrow
   */
  export type config_stateFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the config_state
     * 
    **/
    select?: config_stateSelect | null
    /**
     * Filter, which config_state to fetch.
     * 
    **/
    where?: config_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of config_states to fetch.
     * 
    **/
    orderBy?: Enumerable<config_stateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for config_states.
     * 
    **/
    cursor?: config_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` config_states from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` config_states.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of config_states.
     * 
    **/
    distinct?: Enumerable<Config_stateScalarFieldEnum>
  }


  /**
   * config_state findMany
   */
  export type config_stateFindManyArgs = {
    /**
     * Select specific fields to fetch from the config_state
     * 
    **/
    select?: config_stateSelect | null
    /**
     * Filter, which config_states to fetch.
     * 
    **/
    where?: config_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of config_states to fetch.
     * 
    **/
    orderBy?: Enumerable<config_stateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing config_states.
     * 
    **/
    cursor?: config_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` config_states from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` config_states.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Config_stateScalarFieldEnum>
  }


  /**
   * config_state create
   */
  export type config_stateCreateArgs = {
    /**
     * Select specific fields to fetch from the config_state
     * 
    **/
    select?: config_stateSelect | null
    /**
     * The data needed to create a config_state.
     * 
    **/
    data: XOR<config_stateCreateInput, config_stateUncheckedCreateInput>
  }


  /**
   * config_state createMany
   */
  export type config_stateCreateManyArgs = {
    /**
     * The data used to create many config_states.
     * 
    **/
    data: Enumerable<config_stateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * config_state update
   */
  export type config_stateUpdateArgs = {
    /**
     * Select specific fields to fetch from the config_state
     * 
    **/
    select?: config_stateSelect | null
    /**
     * The data needed to update a config_state.
     * 
    **/
    data: XOR<config_stateUpdateInput, config_stateUncheckedUpdateInput>
    /**
     * Choose, which config_state to update.
     * 
    **/
    where: config_stateWhereUniqueInput
  }


  /**
   * config_state updateMany
   */
  export type config_stateUpdateManyArgs = {
    /**
     * The data used to update config_states.
     * 
    **/
    data: XOR<config_stateUpdateManyMutationInput, config_stateUncheckedUpdateManyInput>
    /**
     * Filter which config_states to update
     * 
    **/
    where?: config_stateWhereInput
  }


  /**
   * config_state upsert
   */
  export type config_stateUpsertArgs = {
    /**
     * Select specific fields to fetch from the config_state
     * 
    **/
    select?: config_stateSelect | null
    /**
     * The filter to search for the config_state to update in case it exists.
     * 
    **/
    where: config_stateWhereUniqueInput
    /**
     * In case the config_state found by the `where` argument doesn't exist, create a new config_state with this data.
     * 
    **/
    create: XOR<config_stateCreateInput, config_stateUncheckedCreateInput>
    /**
     * In case the config_state was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<config_stateUpdateInput, config_stateUncheckedUpdateInput>
  }


  /**
   * config_state delete
   */
  export type config_stateDeleteArgs = {
    /**
     * Select specific fields to fetch from the config_state
     * 
    **/
    select?: config_stateSelect | null
    /**
     * Filter which config_state to delete.
     * 
    **/
    where: config_stateWhereUniqueInput
  }


  /**
   * config_state deleteMany
   */
  export type config_stateDeleteManyArgs = {
    /**
     * Filter which config_states to delete
     * 
    **/
    where?: config_stateWhereInput
  }


  /**
   * config_state without action
   */
  export type config_stateArgs = {
    /**
     * Select specific fields to fetch from the config_state
     * 
    **/
    select?: config_stateSelect | null
  }



  /**
   * Model ContractLogs
   */


  export type AggregateContractLogs = {
    _count: ContractLogsCountAggregateOutputType | null
    _avg: ContractLogsAvgAggregateOutputType | null
    _sum: ContractLogsSumAggregateOutputType | null
    _min: ContractLogsMinAggregateOutputType | null
    _max: ContractLogsMaxAggregateOutputType | null
  }

  export type ContractLogsAvgAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
  }

  export type ContractLogsSumAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
  }

  export type ContractLogsMinAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    contract_identifier: string | null
    topic: string | null
    value: Buffer | null
  }

  export type ContractLogsMaxAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    contract_identifier: string | null
    topic: string | null
    value: Buffer | null
  }

  export type ContractLogsCountAggregateOutputType = {
    id: number
    event_index: number
    tx_id: number
    tx_index: number
    block_height: number
    index_block_hash: number
    parent_index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    microblock_canonical: number
    canonical: number
    contract_identifier: number
    topic: number
    value: number
    _all: number
  }


  export type ContractLogsAvgAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
  }

  export type ContractLogsSumAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
  }

  export type ContractLogsMinAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    contract_identifier?: true
    topic?: true
    value?: true
  }

  export type ContractLogsMaxAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    contract_identifier?: true
    topic?: true
    value?: true
  }

  export type ContractLogsCountAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    contract_identifier?: true
    topic?: true
    value?: true
    _all?: true
  }

  export type ContractLogsAggregateArgs = {
    /**
     * Filter which ContractLogs to aggregate.
     * 
    **/
    where?: ContractLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ContractLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractLogs
    **/
    _count?: true | ContractLogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractLogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractLogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractLogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractLogsMaxAggregateInputType
  }

  export type GetContractLogsAggregateType<T extends ContractLogsAggregateArgs> = {
        [P in keyof T & keyof AggregateContractLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractLogs[P]>
      : GetScalarType<T[P], AggregateContractLogs[P]>
  }




  export type ContractLogsGroupByArgs = {
    where?: ContractLogsWhereInput
    orderBy?: Enumerable<ContractLogsOrderByWithAggregationInput>
    by: Array<ContractLogsScalarFieldEnum>
    having?: ContractLogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractLogsCountAggregateInputType | true
    _avg?: ContractLogsAvgAggregateInputType
    _sum?: ContractLogsSumAggregateInputType
    _min?: ContractLogsMinAggregateInputType
    _max?: ContractLogsMaxAggregateInputType
  }


  export type ContractLogsGroupByOutputType = {
    id: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    contract_identifier: string
    topic: string
    value: Buffer
    _count: ContractLogsCountAggregateOutputType | null
    _avg: ContractLogsAvgAggregateOutputType | null
    _sum: ContractLogsSumAggregateOutputType | null
    _min: ContractLogsMinAggregateOutputType | null
    _max: ContractLogsMaxAggregateOutputType | null
  }

  type GetContractLogsGroupByPayload<T extends ContractLogsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ContractLogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractLogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractLogsGroupByOutputType[P]>
            : GetScalarType<T[P], ContractLogsGroupByOutputType[P]>
        }
      >
    >


  export type ContractLogsSelect = {
    id?: boolean
    event_index?: boolean
    tx_id?: boolean
    tx_index?: boolean
    block_height?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_canonical?: boolean
    canonical?: boolean
    contract_identifier?: boolean
    topic?: boolean
    value?: boolean
  }


  export type ContractLogsGetPayload<S extends boolean | null | undefined | ContractLogsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ContractLogs :
    S extends undefined ? never :
    S extends { include: any } & (ContractLogsArgs | ContractLogsFindManyArgs)
    ? ContractLogs 
    : S extends { select: any } & (ContractLogsArgs | ContractLogsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ContractLogs ? ContractLogs[P] : never
  } 
      : ContractLogs


  type ContractLogsCountArgs = Merge<
    Omit<ContractLogsFindManyArgs, 'select' | 'include'> & {
      select?: ContractLogsCountAggregateInputType | true
    }
  >

  export interface ContractLogsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ContractLogs that matches the filter.
     * @param {ContractLogsFindUniqueArgs} args - Arguments to find a ContractLogs
     * @example
     * // Get one ContractLogs
     * const contractLogs = await prisma.contractLogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ContractLogsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ContractLogsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ContractLogs'> extends True ? Prisma__ContractLogsClient<ContractLogsGetPayload<T>> : Prisma__ContractLogsClient<ContractLogsGetPayload<T> | null, null>

    /**
     * Find one ContractLogs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ContractLogsFindUniqueOrThrowArgs} args - Arguments to find a ContractLogs
     * @example
     * // Get one ContractLogs
     * const contractLogs = await prisma.contractLogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ContractLogsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ContractLogsFindUniqueOrThrowArgs>
    ): Prisma__ContractLogsClient<ContractLogsGetPayload<T>>

    /**
     * Find the first ContractLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractLogsFindFirstArgs} args - Arguments to find a ContractLogs
     * @example
     * // Get one ContractLogs
     * const contractLogs = await prisma.contractLogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ContractLogsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ContractLogsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ContractLogs'> extends True ? Prisma__ContractLogsClient<ContractLogsGetPayload<T>> : Prisma__ContractLogsClient<ContractLogsGetPayload<T> | null, null>

    /**
     * Find the first ContractLogs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractLogsFindFirstOrThrowArgs} args - Arguments to find a ContractLogs
     * @example
     * // Get one ContractLogs
     * const contractLogs = await prisma.contractLogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ContractLogsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ContractLogsFindFirstOrThrowArgs>
    ): Prisma__ContractLogsClient<ContractLogsGetPayload<T>>

    /**
     * Find zero or more ContractLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractLogsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractLogs
     * const contractLogs = await prisma.contractLogs.findMany()
     * 
     * // Get first 10 ContractLogs
     * const contractLogs = await prisma.contractLogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractLogsWithIdOnly = await prisma.contractLogs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ContractLogsFindManyArgs>(
      args?: SelectSubset<T, ContractLogsFindManyArgs>
    ): PrismaPromise<Array<ContractLogsGetPayload<T>>>

    /**
     * Create a ContractLogs.
     * @param {ContractLogsCreateArgs} args - Arguments to create a ContractLogs.
     * @example
     * // Create one ContractLogs
     * const ContractLogs = await prisma.contractLogs.create({
     *   data: {
     *     // ... data to create a ContractLogs
     *   }
     * })
     * 
    **/
    create<T extends ContractLogsCreateArgs>(
      args: SelectSubset<T, ContractLogsCreateArgs>
    ): Prisma__ContractLogsClient<ContractLogsGetPayload<T>>

    /**
     * Create many ContractLogs.
     *     @param {ContractLogsCreateManyArgs} args - Arguments to create many ContractLogs.
     *     @example
     *     // Create many ContractLogs
     *     const contractLogs = await prisma.contractLogs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ContractLogsCreateManyArgs>(
      args?: SelectSubset<T, ContractLogsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ContractLogs.
     * @param {ContractLogsDeleteArgs} args - Arguments to delete one ContractLogs.
     * @example
     * // Delete one ContractLogs
     * const ContractLogs = await prisma.contractLogs.delete({
     *   where: {
     *     // ... filter to delete one ContractLogs
     *   }
     * })
     * 
    **/
    delete<T extends ContractLogsDeleteArgs>(
      args: SelectSubset<T, ContractLogsDeleteArgs>
    ): Prisma__ContractLogsClient<ContractLogsGetPayload<T>>

    /**
     * Update one ContractLogs.
     * @param {ContractLogsUpdateArgs} args - Arguments to update one ContractLogs.
     * @example
     * // Update one ContractLogs
     * const contractLogs = await prisma.contractLogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ContractLogsUpdateArgs>(
      args: SelectSubset<T, ContractLogsUpdateArgs>
    ): Prisma__ContractLogsClient<ContractLogsGetPayload<T>>

    /**
     * Delete zero or more ContractLogs.
     * @param {ContractLogsDeleteManyArgs} args - Arguments to filter ContractLogs to delete.
     * @example
     * // Delete a few ContractLogs
     * const { count } = await prisma.contractLogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ContractLogsDeleteManyArgs>(
      args?: SelectSubset<T, ContractLogsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractLogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractLogs
     * const contractLogs = await prisma.contractLogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ContractLogsUpdateManyArgs>(
      args: SelectSubset<T, ContractLogsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ContractLogs.
     * @param {ContractLogsUpsertArgs} args - Arguments to update or create a ContractLogs.
     * @example
     * // Update or create a ContractLogs
     * const contractLogs = await prisma.contractLogs.upsert({
     *   create: {
     *     // ... data to create a ContractLogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractLogs we want to update
     *   }
     * })
    **/
    upsert<T extends ContractLogsUpsertArgs>(
      args: SelectSubset<T, ContractLogsUpsertArgs>
    ): Prisma__ContractLogsClient<ContractLogsGetPayload<T>>

    /**
     * Count the number of ContractLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractLogsCountArgs} args - Arguments to filter ContractLogs to count.
     * @example
     * // Count the number of ContractLogs
     * const count = await prisma.contractLogs.count({
     *   where: {
     *     // ... the filter for the ContractLogs we want to count
     *   }
     * })
    **/
    count<T extends ContractLogsCountArgs>(
      args?: Subset<T, ContractLogsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractLogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractLogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractLogsAggregateArgs>(args: Subset<T, ContractLogsAggregateArgs>): PrismaPromise<GetContractLogsAggregateType<T>>

    /**
     * Group by ContractLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractLogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractLogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractLogsGroupByArgs['orderBy'] }
        : { orderBy?: ContractLogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractLogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractLogsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractLogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ContractLogsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ContractLogs base type for findUnique actions
   */
  export type ContractLogsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ContractLogs
     * 
    **/
    select?: ContractLogsSelect | null
    /**
     * Filter, which ContractLogs to fetch.
     * 
    **/
    where: ContractLogsWhereUniqueInput
  }

  /**
   * ContractLogs: findUnique
   */
  export interface ContractLogsFindUniqueArgs extends ContractLogsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ContractLogs findUniqueOrThrow
   */
  export type ContractLogsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ContractLogs
     * 
    **/
    select?: ContractLogsSelect | null
    /**
     * Filter, which ContractLogs to fetch.
     * 
    **/
    where: ContractLogsWhereUniqueInput
  }


  /**
   * ContractLogs base type for findFirst actions
   */
  export type ContractLogsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ContractLogs
     * 
    **/
    select?: ContractLogsSelect | null
    /**
     * Filter, which ContractLogs to fetch.
     * 
    **/
    where?: ContractLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractLogs.
     * 
    **/
    cursor?: ContractLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractLogs.
     * 
    **/
    distinct?: Enumerable<ContractLogsScalarFieldEnum>
  }

  /**
   * ContractLogs: findFirst
   */
  export interface ContractLogsFindFirstArgs extends ContractLogsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ContractLogs findFirstOrThrow
   */
  export type ContractLogsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ContractLogs
     * 
    **/
    select?: ContractLogsSelect | null
    /**
     * Filter, which ContractLogs to fetch.
     * 
    **/
    where?: ContractLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractLogs.
     * 
    **/
    cursor?: ContractLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractLogs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractLogs.
     * 
    **/
    distinct?: Enumerable<ContractLogsScalarFieldEnum>
  }


  /**
   * ContractLogs findMany
   */
  export type ContractLogsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ContractLogs
     * 
    **/
    select?: ContractLogsSelect | null
    /**
     * Filter, which ContractLogs to fetch.
     * 
    **/
    where?: ContractLogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractLogs to fetch.
     * 
    **/
    orderBy?: Enumerable<ContractLogsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractLogs.
     * 
    **/
    cursor?: ContractLogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractLogs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractLogs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ContractLogsScalarFieldEnum>
  }


  /**
   * ContractLogs create
   */
  export type ContractLogsCreateArgs = {
    /**
     * Select specific fields to fetch from the ContractLogs
     * 
    **/
    select?: ContractLogsSelect | null
    /**
     * The data needed to create a ContractLogs.
     * 
    **/
    data: XOR<ContractLogsCreateInput, ContractLogsUncheckedCreateInput>
  }


  /**
   * ContractLogs createMany
   */
  export type ContractLogsCreateManyArgs = {
    /**
     * The data used to create many ContractLogs.
     * 
    **/
    data: Enumerable<ContractLogsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ContractLogs update
   */
  export type ContractLogsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ContractLogs
     * 
    **/
    select?: ContractLogsSelect | null
    /**
     * The data needed to update a ContractLogs.
     * 
    **/
    data: XOR<ContractLogsUpdateInput, ContractLogsUncheckedUpdateInput>
    /**
     * Choose, which ContractLogs to update.
     * 
    **/
    where: ContractLogsWhereUniqueInput
  }


  /**
   * ContractLogs updateMany
   */
  export type ContractLogsUpdateManyArgs = {
    /**
     * The data used to update ContractLogs.
     * 
    **/
    data: XOR<ContractLogsUpdateManyMutationInput, ContractLogsUncheckedUpdateManyInput>
    /**
     * Filter which ContractLogs to update
     * 
    **/
    where?: ContractLogsWhereInput
  }


  /**
   * ContractLogs upsert
   */
  export type ContractLogsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ContractLogs
     * 
    **/
    select?: ContractLogsSelect | null
    /**
     * The filter to search for the ContractLogs to update in case it exists.
     * 
    **/
    where: ContractLogsWhereUniqueInput
    /**
     * In case the ContractLogs found by the `where` argument doesn't exist, create a new ContractLogs with this data.
     * 
    **/
    create: XOR<ContractLogsCreateInput, ContractLogsUncheckedCreateInput>
    /**
     * In case the ContractLogs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ContractLogsUpdateInput, ContractLogsUncheckedUpdateInput>
  }


  /**
   * ContractLogs delete
   */
  export type ContractLogsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ContractLogs
     * 
    **/
    select?: ContractLogsSelect | null
    /**
     * Filter which ContractLogs to delete.
     * 
    **/
    where: ContractLogsWhereUniqueInput
  }


  /**
   * ContractLogs deleteMany
   */
  export type ContractLogsDeleteManyArgs = {
    /**
     * Filter which ContractLogs to delete
     * 
    **/
    where?: ContractLogsWhereInput
  }


  /**
   * ContractLogs without action
   */
  export type ContractLogsArgs = {
    /**
     * Select specific fields to fetch from the ContractLogs
     * 
    **/
    select?: ContractLogsSelect | null
  }



  /**
   * Model event_observer_requests
   */


  export type AggregateEvent_observer_requests = {
    _count: Event_observer_requestsCountAggregateOutputType | null
    _avg: Event_observer_requestsAvgAggregateOutputType | null
    _sum: Event_observer_requestsSumAggregateOutputType | null
    _min: Event_observer_requestsMinAggregateOutputType | null
    _max: Event_observer_requestsMaxAggregateOutputType | null
  }

  export type Event_observer_requestsAvgAggregateOutputType = {
    id: number | null
  }

  export type Event_observer_requestsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Event_observer_requestsMinAggregateOutputType = {
    id: bigint | null
    receive_timestamp: Date | null
    event_path: string | null
  }

  export type Event_observer_requestsMaxAggregateOutputType = {
    id: bigint | null
    receive_timestamp: Date | null
    event_path: string | null
  }

  export type Event_observer_requestsCountAggregateOutputType = {
    id: number
    receive_timestamp: number
    event_path: number
    payload: number
    _all: number
  }


  export type Event_observer_requestsAvgAggregateInputType = {
    id?: true
  }

  export type Event_observer_requestsSumAggregateInputType = {
    id?: true
  }

  export type Event_observer_requestsMinAggregateInputType = {
    id?: true
    receive_timestamp?: true
    event_path?: true
  }

  export type Event_observer_requestsMaxAggregateInputType = {
    id?: true
    receive_timestamp?: true
    event_path?: true
  }

  export type Event_observer_requestsCountAggregateInputType = {
    id?: true
    receive_timestamp?: true
    event_path?: true
    payload?: true
    _all?: true
  }

  export type Event_observer_requestsAggregateArgs = {
    /**
     * Filter which event_observer_requests to aggregate.
     * 
    **/
    where?: event_observer_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_observer_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<event_observer_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: event_observer_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_observer_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_observer_requests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned event_observer_requests
    **/
    _count?: true | Event_observer_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Event_observer_requestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Event_observer_requestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Event_observer_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Event_observer_requestsMaxAggregateInputType
  }

  export type GetEvent_observer_requestsAggregateType<T extends Event_observer_requestsAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent_observer_requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent_observer_requests[P]>
      : GetScalarType<T[P], AggregateEvent_observer_requests[P]>
  }




  export type Event_observer_requestsGroupByArgs = {
    where?: event_observer_requestsWhereInput
    orderBy?: Enumerable<event_observer_requestsOrderByWithAggregationInput>
    by: Array<Event_observer_requestsScalarFieldEnum>
    having?: event_observer_requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Event_observer_requestsCountAggregateInputType | true
    _avg?: Event_observer_requestsAvgAggregateInputType
    _sum?: Event_observer_requestsSumAggregateInputType
    _min?: Event_observer_requestsMinAggregateInputType
    _max?: Event_observer_requestsMaxAggregateInputType
  }


  export type Event_observer_requestsGroupByOutputType = {
    id: bigint
    receive_timestamp: Date
    event_path: string
    payload: JsonValue
    _count: Event_observer_requestsCountAggregateOutputType | null
    _avg: Event_observer_requestsAvgAggregateOutputType | null
    _sum: Event_observer_requestsSumAggregateOutputType | null
    _min: Event_observer_requestsMinAggregateOutputType | null
    _max: Event_observer_requestsMaxAggregateOutputType | null
  }

  type GetEvent_observer_requestsGroupByPayload<T extends Event_observer_requestsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Event_observer_requestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Event_observer_requestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Event_observer_requestsGroupByOutputType[P]>
            : GetScalarType<T[P], Event_observer_requestsGroupByOutputType[P]>
        }
      >
    >


  export type event_observer_requestsSelect = {
    id?: boolean
    receive_timestamp?: boolean
    event_path?: boolean
    payload?: boolean
  }


  export type event_observer_requestsGetPayload<S extends boolean | null | undefined | event_observer_requestsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? event_observer_requests :
    S extends undefined ? never :
    S extends { include: any } & (event_observer_requestsArgs | event_observer_requestsFindManyArgs)
    ? event_observer_requests 
    : S extends { select: any } & (event_observer_requestsArgs | event_observer_requestsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof event_observer_requests ? event_observer_requests[P] : never
  } 
      : event_observer_requests


  type event_observer_requestsCountArgs = Merge<
    Omit<event_observer_requestsFindManyArgs, 'select' | 'include'> & {
      select?: Event_observer_requestsCountAggregateInputType | true
    }
  >

  export interface event_observer_requestsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Event_observer_requests that matches the filter.
     * @param {event_observer_requestsFindUniqueArgs} args - Arguments to find a Event_observer_requests
     * @example
     * // Get one Event_observer_requests
     * const event_observer_requests = await prisma.event_observer_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends event_observer_requestsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, event_observer_requestsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'event_observer_requests'> extends True ? Prisma__event_observer_requestsClient<event_observer_requestsGetPayload<T>> : Prisma__event_observer_requestsClient<event_observer_requestsGetPayload<T> | null, null>

    /**
     * Find one Event_observer_requests that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {event_observer_requestsFindUniqueOrThrowArgs} args - Arguments to find a Event_observer_requests
     * @example
     * // Get one Event_observer_requests
     * const event_observer_requests = await prisma.event_observer_requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends event_observer_requestsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, event_observer_requestsFindUniqueOrThrowArgs>
    ): Prisma__event_observer_requestsClient<event_observer_requestsGetPayload<T>>

    /**
     * Find the first Event_observer_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_observer_requestsFindFirstArgs} args - Arguments to find a Event_observer_requests
     * @example
     * // Get one Event_observer_requests
     * const event_observer_requests = await prisma.event_observer_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends event_observer_requestsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, event_observer_requestsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'event_observer_requests'> extends True ? Prisma__event_observer_requestsClient<event_observer_requestsGetPayload<T>> : Prisma__event_observer_requestsClient<event_observer_requestsGetPayload<T> | null, null>

    /**
     * Find the first Event_observer_requests that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_observer_requestsFindFirstOrThrowArgs} args - Arguments to find a Event_observer_requests
     * @example
     * // Get one Event_observer_requests
     * const event_observer_requests = await prisma.event_observer_requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends event_observer_requestsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, event_observer_requestsFindFirstOrThrowArgs>
    ): Prisma__event_observer_requestsClient<event_observer_requestsGetPayload<T>>

    /**
     * Find zero or more Event_observer_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_observer_requestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Event_observer_requests
     * const event_observer_requests = await prisma.event_observer_requests.findMany()
     * 
     * // Get first 10 Event_observer_requests
     * const event_observer_requests = await prisma.event_observer_requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const event_observer_requestsWithIdOnly = await prisma.event_observer_requests.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends event_observer_requestsFindManyArgs>(
      args?: SelectSubset<T, event_observer_requestsFindManyArgs>
    ): PrismaPromise<Array<event_observer_requestsGetPayload<T>>>

    /**
     * Create a Event_observer_requests.
     * @param {event_observer_requestsCreateArgs} args - Arguments to create a Event_observer_requests.
     * @example
     * // Create one Event_observer_requests
     * const Event_observer_requests = await prisma.event_observer_requests.create({
     *   data: {
     *     // ... data to create a Event_observer_requests
     *   }
     * })
     * 
    **/
    create<T extends event_observer_requestsCreateArgs>(
      args: SelectSubset<T, event_observer_requestsCreateArgs>
    ): Prisma__event_observer_requestsClient<event_observer_requestsGetPayload<T>>

    /**
     * Create many Event_observer_requests.
     *     @param {event_observer_requestsCreateManyArgs} args - Arguments to create many Event_observer_requests.
     *     @example
     *     // Create many Event_observer_requests
     *     const event_observer_requests = await prisma.event_observer_requests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends event_observer_requestsCreateManyArgs>(
      args?: SelectSubset<T, event_observer_requestsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Event_observer_requests.
     * @param {event_observer_requestsDeleteArgs} args - Arguments to delete one Event_observer_requests.
     * @example
     * // Delete one Event_observer_requests
     * const Event_observer_requests = await prisma.event_observer_requests.delete({
     *   where: {
     *     // ... filter to delete one Event_observer_requests
     *   }
     * })
     * 
    **/
    delete<T extends event_observer_requestsDeleteArgs>(
      args: SelectSubset<T, event_observer_requestsDeleteArgs>
    ): Prisma__event_observer_requestsClient<event_observer_requestsGetPayload<T>>

    /**
     * Update one Event_observer_requests.
     * @param {event_observer_requestsUpdateArgs} args - Arguments to update one Event_observer_requests.
     * @example
     * // Update one Event_observer_requests
     * const event_observer_requests = await prisma.event_observer_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends event_observer_requestsUpdateArgs>(
      args: SelectSubset<T, event_observer_requestsUpdateArgs>
    ): Prisma__event_observer_requestsClient<event_observer_requestsGetPayload<T>>

    /**
     * Delete zero or more Event_observer_requests.
     * @param {event_observer_requestsDeleteManyArgs} args - Arguments to filter Event_observer_requests to delete.
     * @example
     * // Delete a few Event_observer_requests
     * const { count } = await prisma.event_observer_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends event_observer_requestsDeleteManyArgs>(
      args?: SelectSubset<T, event_observer_requestsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Event_observer_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_observer_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Event_observer_requests
     * const event_observer_requests = await prisma.event_observer_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends event_observer_requestsUpdateManyArgs>(
      args: SelectSubset<T, event_observer_requestsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Event_observer_requests.
     * @param {event_observer_requestsUpsertArgs} args - Arguments to update or create a Event_observer_requests.
     * @example
     * // Update or create a Event_observer_requests
     * const event_observer_requests = await prisma.event_observer_requests.upsert({
     *   create: {
     *     // ... data to create a Event_observer_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event_observer_requests we want to update
     *   }
     * })
    **/
    upsert<T extends event_observer_requestsUpsertArgs>(
      args: SelectSubset<T, event_observer_requestsUpsertArgs>
    ): Prisma__event_observer_requestsClient<event_observer_requestsGetPayload<T>>

    /**
     * Count the number of Event_observer_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {event_observer_requestsCountArgs} args - Arguments to filter Event_observer_requests to count.
     * @example
     * // Count the number of Event_observer_requests
     * const count = await prisma.event_observer_requests.count({
     *   where: {
     *     // ... the filter for the Event_observer_requests we want to count
     *   }
     * })
    **/
    count<T extends event_observer_requestsCountArgs>(
      args?: Subset<T, event_observer_requestsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Event_observer_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event_observer_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_observer_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Event_observer_requestsAggregateArgs>(args: Subset<T, Event_observer_requestsAggregateArgs>): PrismaPromise<GetEvent_observer_requestsAggregateType<T>>

    /**
     * Group by Event_observer_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Event_observer_requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Event_observer_requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Event_observer_requestsGroupByArgs['orderBy'] }
        : { orderBy?: Event_observer_requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Event_observer_requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvent_observer_requestsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for event_observer_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__event_observer_requestsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * event_observer_requests base type for findUnique actions
   */
  export type event_observer_requestsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the event_observer_requests
     * 
    **/
    select?: event_observer_requestsSelect | null
    /**
     * Filter, which event_observer_requests to fetch.
     * 
    **/
    where: event_observer_requestsWhereUniqueInput
  }

  /**
   * event_observer_requests: findUnique
   */
  export interface event_observer_requestsFindUniqueArgs extends event_observer_requestsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * event_observer_requests findUniqueOrThrow
   */
  export type event_observer_requestsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the event_observer_requests
     * 
    **/
    select?: event_observer_requestsSelect | null
    /**
     * Filter, which event_observer_requests to fetch.
     * 
    **/
    where: event_observer_requestsWhereUniqueInput
  }


  /**
   * event_observer_requests base type for findFirst actions
   */
  export type event_observer_requestsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the event_observer_requests
     * 
    **/
    select?: event_observer_requestsSelect | null
    /**
     * Filter, which event_observer_requests to fetch.
     * 
    **/
    where?: event_observer_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_observer_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<event_observer_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_observer_requests.
     * 
    **/
    cursor?: event_observer_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_observer_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_observer_requests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_observer_requests.
     * 
    **/
    distinct?: Enumerable<Event_observer_requestsScalarFieldEnum>
  }

  /**
   * event_observer_requests: findFirst
   */
  export interface event_observer_requestsFindFirstArgs extends event_observer_requestsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * event_observer_requests findFirstOrThrow
   */
  export type event_observer_requestsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the event_observer_requests
     * 
    **/
    select?: event_observer_requestsSelect | null
    /**
     * Filter, which event_observer_requests to fetch.
     * 
    **/
    where?: event_observer_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_observer_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<event_observer_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for event_observer_requests.
     * 
    **/
    cursor?: event_observer_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_observer_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_observer_requests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of event_observer_requests.
     * 
    **/
    distinct?: Enumerable<Event_observer_requestsScalarFieldEnum>
  }


  /**
   * event_observer_requests findMany
   */
  export type event_observer_requestsFindManyArgs = {
    /**
     * Select specific fields to fetch from the event_observer_requests
     * 
    **/
    select?: event_observer_requestsSelect | null
    /**
     * Filter, which event_observer_requests to fetch.
     * 
    **/
    where?: event_observer_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of event_observer_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<event_observer_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing event_observer_requests.
     * 
    **/
    cursor?: event_observer_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` event_observer_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` event_observer_requests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Event_observer_requestsScalarFieldEnum>
  }


  /**
   * event_observer_requests create
   */
  export type event_observer_requestsCreateArgs = {
    /**
     * Select specific fields to fetch from the event_observer_requests
     * 
    **/
    select?: event_observer_requestsSelect | null
    /**
     * The data needed to create a event_observer_requests.
     * 
    **/
    data: XOR<event_observer_requestsCreateInput, event_observer_requestsUncheckedCreateInput>
  }


  /**
   * event_observer_requests createMany
   */
  export type event_observer_requestsCreateManyArgs = {
    /**
     * The data used to create many event_observer_requests.
     * 
    **/
    data: Enumerable<event_observer_requestsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * event_observer_requests update
   */
  export type event_observer_requestsUpdateArgs = {
    /**
     * Select specific fields to fetch from the event_observer_requests
     * 
    **/
    select?: event_observer_requestsSelect | null
    /**
     * The data needed to update a event_observer_requests.
     * 
    **/
    data: XOR<event_observer_requestsUpdateInput, event_observer_requestsUncheckedUpdateInput>
    /**
     * Choose, which event_observer_requests to update.
     * 
    **/
    where: event_observer_requestsWhereUniqueInput
  }


  /**
   * event_observer_requests updateMany
   */
  export type event_observer_requestsUpdateManyArgs = {
    /**
     * The data used to update event_observer_requests.
     * 
    **/
    data: XOR<event_observer_requestsUpdateManyMutationInput, event_observer_requestsUncheckedUpdateManyInput>
    /**
     * Filter which event_observer_requests to update
     * 
    **/
    where?: event_observer_requestsWhereInput
  }


  /**
   * event_observer_requests upsert
   */
  export type event_observer_requestsUpsertArgs = {
    /**
     * Select specific fields to fetch from the event_observer_requests
     * 
    **/
    select?: event_observer_requestsSelect | null
    /**
     * The filter to search for the event_observer_requests to update in case it exists.
     * 
    **/
    where: event_observer_requestsWhereUniqueInput
    /**
     * In case the event_observer_requests found by the `where` argument doesn't exist, create a new event_observer_requests with this data.
     * 
    **/
    create: XOR<event_observer_requestsCreateInput, event_observer_requestsUncheckedCreateInput>
    /**
     * In case the event_observer_requests was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<event_observer_requestsUpdateInput, event_observer_requestsUncheckedUpdateInput>
  }


  /**
   * event_observer_requests delete
   */
  export type event_observer_requestsDeleteArgs = {
    /**
     * Select specific fields to fetch from the event_observer_requests
     * 
    **/
    select?: event_observer_requestsSelect | null
    /**
     * Filter which event_observer_requests to delete.
     * 
    **/
    where: event_observer_requestsWhereUniqueInput
  }


  /**
   * event_observer_requests deleteMany
   */
  export type event_observer_requestsDeleteManyArgs = {
    /**
     * Filter which event_observer_requests to delete
     * 
    **/
    where?: event_observer_requestsWhereInput
  }


  /**
   * event_observer_requests without action
   */
  export type event_observer_requestsArgs = {
    /**
     * Select specific fields to fetch from the event_observer_requests
     * 
    **/
    select?: event_observer_requestsSelect | null
  }



  /**
   * Model faucet_requests
   */


  export type AggregateFaucet_requests = {
    _count: Faucet_requestsCountAggregateOutputType | null
    _avg: Faucet_requestsAvgAggregateOutputType | null
    _sum: Faucet_requestsSumAggregateOutputType | null
    _min: Faucet_requestsMinAggregateOutputType | null
    _max: Faucet_requestsMaxAggregateOutputType | null
  }

  export type Faucet_requestsAvgAggregateOutputType = {
    id: number | null
    occurred_at: number | null
  }

  export type Faucet_requestsSumAggregateOutputType = {
    id: number | null
    occurred_at: bigint | null
  }

  export type Faucet_requestsMinAggregateOutputType = {
    id: number | null
    currency: string | null
    address: string | null
    ip: string | null
    occurred_at: bigint | null
  }

  export type Faucet_requestsMaxAggregateOutputType = {
    id: number | null
    currency: string | null
    address: string | null
    ip: string | null
    occurred_at: bigint | null
  }

  export type Faucet_requestsCountAggregateOutputType = {
    id: number
    currency: number
    address: number
    ip: number
    occurred_at: number
    _all: number
  }


  export type Faucet_requestsAvgAggregateInputType = {
    id?: true
    occurred_at?: true
  }

  export type Faucet_requestsSumAggregateInputType = {
    id?: true
    occurred_at?: true
  }

  export type Faucet_requestsMinAggregateInputType = {
    id?: true
    currency?: true
    address?: true
    ip?: true
    occurred_at?: true
  }

  export type Faucet_requestsMaxAggregateInputType = {
    id?: true
    currency?: true
    address?: true
    ip?: true
    occurred_at?: true
  }

  export type Faucet_requestsCountAggregateInputType = {
    id?: true
    currency?: true
    address?: true
    ip?: true
    occurred_at?: true
    _all?: true
  }

  export type Faucet_requestsAggregateArgs = {
    /**
     * Filter which faucet_requests to aggregate.
     * 
    **/
    where?: faucet_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faucet_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<faucet_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: faucet_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faucet_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faucet_requests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned faucet_requests
    **/
    _count?: true | Faucet_requestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Faucet_requestsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Faucet_requestsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Faucet_requestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Faucet_requestsMaxAggregateInputType
  }

  export type GetFaucet_requestsAggregateType<T extends Faucet_requestsAggregateArgs> = {
        [P in keyof T & keyof AggregateFaucet_requests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFaucet_requests[P]>
      : GetScalarType<T[P], AggregateFaucet_requests[P]>
  }




  export type Faucet_requestsGroupByArgs = {
    where?: faucet_requestsWhereInput
    orderBy?: Enumerable<faucet_requestsOrderByWithAggregationInput>
    by: Array<Faucet_requestsScalarFieldEnum>
    having?: faucet_requestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Faucet_requestsCountAggregateInputType | true
    _avg?: Faucet_requestsAvgAggregateInputType
    _sum?: Faucet_requestsSumAggregateInputType
    _min?: Faucet_requestsMinAggregateInputType
    _max?: Faucet_requestsMaxAggregateInputType
  }


  export type Faucet_requestsGroupByOutputType = {
    id: number
    currency: string
    address: string
    ip: string
    occurred_at: bigint
    _count: Faucet_requestsCountAggregateOutputType | null
    _avg: Faucet_requestsAvgAggregateOutputType | null
    _sum: Faucet_requestsSumAggregateOutputType | null
    _min: Faucet_requestsMinAggregateOutputType | null
    _max: Faucet_requestsMaxAggregateOutputType | null
  }

  type GetFaucet_requestsGroupByPayload<T extends Faucet_requestsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Faucet_requestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Faucet_requestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Faucet_requestsGroupByOutputType[P]>
            : GetScalarType<T[P], Faucet_requestsGroupByOutputType[P]>
        }
      >
    >


  export type faucet_requestsSelect = {
    id?: boolean
    currency?: boolean
    address?: boolean
    ip?: boolean
    occurred_at?: boolean
  }


  export type faucet_requestsGetPayload<S extends boolean | null | undefined | faucet_requestsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? faucet_requests :
    S extends undefined ? never :
    S extends { include: any } & (faucet_requestsArgs | faucet_requestsFindManyArgs)
    ? faucet_requests 
    : S extends { select: any } & (faucet_requestsArgs | faucet_requestsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof faucet_requests ? faucet_requests[P] : never
  } 
      : faucet_requests


  type faucet_requestsCountArgs = Merge<
    Omit<faucet_requestsFindManyArgs, 'select' | 'include'> & {
      select?: Faucet_requestsCountAggregateInputType | true
    }
  >

  export interface faucet_requestsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Faucet_requests that matches the filter.
     * @param {faucet_requestsFindUniqueArgs} args - Arguments to find a Faucet_requests
     * @example
     * // Get one Faucet_requests
     * const faucet_requests = await prisma.faucet_requests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends faucet_requestsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, faucet_requestsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'faucet_requests'> extends True ? Prisma__faucet_requestsClient<faucet_requestsGetPayload<T>> : Prisma__faucet_requestsClient<faucet_requestsGetPayload<T> | null, null>

    /**
     * Find one Faucet_requests that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {faucet_requestsFindUniqueOrThrowArgs} args - Arguments to find a Faucet_requests
     * @example
     * // Get one Faucet_requests
     * const faucet_requests = await prisma.faucet_requests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends faucet_requestsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, faucet_requestsFindUniqueOrThrowArgs>
    ): Prisma__faucet_requestsClient<faucet_requestsGetPayload<T>>

    /**
     * Find the first Faucet_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faucet_requestsFindFirstArgs} args - Arguments to find a Faucet_requests
     * @example
     * // Get one Faucet_requests
     * const faucet_requests = await prisma.faucet_requests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends faucet_requestsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, faucet_requestsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'faucet_requests'> extends True ? Prisma__faucet_requestsClient<faucet_requestsGetPayload<T>> : Prisma__faucet_requestsClient<faucet_requestsGetPayload<T> | null, null>

    /**
     * Find the first Faucet_requests that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faucet_requestsFindFirstOrThrowArgs} args - Arguments to find a Faucet_requests
     * @example
     * // Get one Faucet_requests
     * const faucet_requests = await prisma.faucet_requests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends faucet_requestsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, faucet_requestsFindFirstOrThrowArgs>
    ): Prisma__faucet_requestsClient<faucet_requestsGetPayload<T>>

    /**
     * Find zero or more Faucet_requests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faucet_requestsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Faucet_requests
     * const faucet_requests = await prisma.faucet_requests.findMany()
     * 
     * // Get first 10 Faucet_requests
     * const faucet_requests = await prisma.faucet_requests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const faucet_requestsWithIdOnly = await prisma.faucet_requests.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends faucet_requestsFindManyArgs>(
      args?: SelectSubset<T, faucet_requestsFindManyArgs>
    ): PrismaPromise<Array<faucet_requestsGetPayload<T>>>

    /**
     * Create a Faucet_requests.
     * @param {faucet_requestsCreateArgs} args - Arguments to create a Faucet_requests.
     * @example
     * // Create one Faucet_requests
     * const Faucet_requests = await prisma.faucet_requests.create({
     *   data: {
     *     // ... data to create a Faucet_requests
     *   }
     * })
     * 
    **/
    create<T extends faucet_requestsCreateArgs>(
      args: SelectSubset<T, faucet_requestsCreateArgs>
    ): Prisma__faucet_requestsClient<faucet_requestsGetPayload<T>>

    /**
     * Create many Faucet_requests.
     *     @param {faucet_requestsCreateManyArgs} args - Arguments to create many Faucet_requests.
     *     @example
     *     // Create many Faucet_requests
     *     const faucet_requests = await prisma.faucet_requests.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends faucet_requestsCreateManyArgs>(
      args?: SelectSubset<T, faucet_requestsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Faucet_requests.
     * @param {faucet_requestsDeleteArgs} args - Arguments to delete one Faucet_requests.
     * @example
     * // Delete one Faucet_requests
     * const Faucet_requests = await prisma.faucet_requests.delete({
     *   where: {
     *     // ... filter to delete one Faucet_requests
     *   }
     * })
     * 
    **/
    delete<T extends faucet_requestsDeleteArgs>(
      args: SelectSubset<T, faucet_requestsDeleteArgs>
    ): Prisma__faucet_requestsClient<faucet_requestsGetPayload<T>>

    /**
     * Update one Faucet_requests.
     * @param {faucet_requestsUpdateArgs} args - Arguments to update one Faucet_requests.
     * @example
     * // Update one Faucet_requests
     * const faucet_requests = await prisma.faucet_requests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends faucet_requestsUpdateArgs>(
      args: SelectSubset<T, faucet_requestsUpdateArgs>
    ): Prisma__faucet_requestsClient<faucet_requestsGetPayload<T>>

    /**
     * Delete zero or more Faucet_requests.
     * @param {faucet_requestsDeleteManyArgs} args - Arguments to filter Faucet_requests to delete.
     * @example
     * // Delete a few Faucet_requests
     * const { count } = await prisma.faucet_requests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends faucet_requestsDeleteManyArgs>(
      args?: SelectSubset<T, faucet_requestsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Faucet_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faucet_requestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Faucet_requests
     * const faucet_requests = await prisma.faucet_requests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends faucet_requestsUpdateManyArgs>(
      args: SelectSubset<T, faucet_requestsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Faucet_requests.
     * @param {faucet_requestsUpsertArgs} args - Arguments to update or create a Faucet_requests.
     * @example
     * // Update or create a Faucet_requests
     * const faucet_requests = await prisma.faucet_requests.upsert({
     *   create: {
     *     // ... data to create a Faucet_requests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Faucet_requests we want to update
     *   }
     * })
    **/
    upsert<T extends faucet_requestsUpsertArgs>(
      args: SelectSubset<T, faucet_requestsUpsertArgs>
    ): Prisma__faucet_requestsClient<faucet_requestsGetPayload<T>>

    /**
     * Count the number of Faucet_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {faucet_requestsCountArgs} args - Arguments to filter Faucet_requests to count.
     * @example
     * // Count the number of Faucet_requests
     * const count = await prisma.faucet_requests.count({
     *   where: {
     *     // ... the filter for the Faucet_requests we want to count
     *   }
     * })
    **/
    count<T extends faucet_requestsCountArgs>(
      args?: Subset<T, faucet_requestsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Faucet_requestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Faucet_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Faucet_requestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Faucet_requestsAggregateArgs>(args: Subset<T, Faucet_requestsAggregateArgs>): PrismaPromise<GetFaucet_requestsAggregateType<T>>

    /**
     * Group by Faucet_requests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Faucet_requestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Faucet_requestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Faucet_requestsGroupByArgs['orderBy'] }
        : { orderBy?: Faucet_requestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Faucet_requestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFaucet_requestsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for faucet_requests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__faucet_requestsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * faucet_requests base type for findUnique actions
   */
  export type faucet_requestsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the faucet_requests
     * 
    **/
    select?: faucet_requestsSelect | null
    /**
     * Filter, which faucet_requests to fetch.
     * 
    **/
    where: faucet_requestsWhereUniqueInput
  }

  /**
   * faucet_requests: findUnique
   */
  export interface faucet_requestsFindUniqueArgs extends faucet_requestsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * faucet_requests findUniqueOrThrow
   */
  export type faucet_requestsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the faucet_requests
     * 
    **/
    select?: faucet_requestsSelect | null
    /**
     * Filter, which faucet_requests to fetch.
     * 
    **/
    where: faucet_requestsWhereUniqueInput
  }


  /**
   * faucet_requests base type for findFirst actions
   */
  export type faucet_requestsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the faucet_requests
     * 
    **/
    select?: faucet_requestsSelect | null
    /**
     * Filter, which faucet_requests to fetch.
     * 
    **/
    where?: faucet_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faucet_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<faucet_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faucet_requests.
     * 
    **/
    cursor?: faucet_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faucet_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faucet_requests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faucet_requests.
     * 
    **/
    distinct?: Enumerable<Faucet_requestsScalarFieldEnum>
  }

  /**
   * faucet_requests: findFirst
   */
  export interface faucet_requestsFindFirstArgs extends faucet_requestsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * faucet_requests findFirstOrThrow
   */
  export type faucet_requestsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the faucet_requests
     * 
    **/
    select?: faucet_requestsSelect | null
    /**
     * Filter, which faucet_requests to fetch.
     * 
    **/
    where?: faucet_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faucet_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<faucet_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for faucet_requests.
     * 
    **/
    cursor?: faucet_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faucet_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faucet_requests.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of faucet_requests.
     * 
    **/
    distinct?: Enumerable<Faucet_requestsScalarFieldEnum>
  }


  /**
   * faucet_requests findMany
   */
  export type faucet_requestsFindManyArgs = {
    /**
     * Select specific fields to fetch from the faucet_requests
     * 
    **/
    select?: faucet_requestsSelect | null
    /**
     * Filter, which faucet_requests to fetch.
     * 
    **/
    where?: faucet_requestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of faucet_requests to fetch.
     * 
    **/
    orderBy?: Enumerable<faucet_requestsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing faucet_requests.
     * 
    **/
    cursor?: faucet_requestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` faucet_requests from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` faucet_requests.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Faucet_requestsScalarFieldEnum>
  }


  /**
   * faucet_requests create
   */
  export type faucet_requestsCreateArgs = {
    /**
     * Select specific fields to fetch from the faucet_requests
     * 
    **/
    select?: faucet_requestsSelect | null
    /**
     * The data needed to create a faucet_requests.
     * 
    **/
    data: XOR<faucet_requestsCreateInput, faucet_requestsUncheckedCreateInput>
  }


  /**
   * faucet_requests createMany
   */
  export type faucet_requestsCreateManyArgs = {
    /**
     * The data used to create many faucet_requests.
     * 
    **/
    data: Enumerable<faucet_requestsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * faucet_requests update
   */
  export type faucet_requestsUpdateArgs = {
    /**
     * Select specific fields to fetch from the faucet_requests
     * 
    **/
    select?: faucet_requestsSelect | null
    /**
     * The data needed to update a faucet_requests.
     * 
    **/
    data: XOR<faucet_requestsUpdateInput, faucet_requestsUncheckedUpdateInput>
    /**
     * Choose, which faucet_requests to update.
     * 
    **/
    where: faucet_requestsWhereUniqueInput
  }


  /**
   * faucet_requests updateMany
   */
  export type faucet_requestsUpdateManyArgs = {
    /**
     * The data used to update faucet_requests.
     * 
    **/
    data: XOR<faucet_requestsUpdateManyMutationInput, faucet_requestsUncheckedUpdateManyInput>
    /**
     * Filter which faucet_requests to update
     * 
    **/
    where?: faucet_requestsWhereInput
  }


  /**
   * faucet_requests upsert
   */
  export type faucet_requestsUpsertArgs = {
    /**
     * Select specific fields to fetch from the faucet_requests
     * 
    **/
    select?: faucet_requestsSelect | null
    /**
     * The filter to search for the faucet_requests to update in case it exists.
     * 
    **/
    where: faucet_requestsWhereUniqueInput
    /**
     * In case the faucet_requests found by the `where` argument doesn't exist, create a new faucet_requests with this data.
     * 
    **/
    create: XOR<faucet_requestsCreateInput, faucet_requestsUncheckedCreateInput>
    /**
     * In case the faucet_requests was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<faucet_requestsUpdateInput, faucet_requestsUncheckedUpdateInput>
  }


  /**
   * faucet_requests delete
   */
  export type faucet_requestsDeleteArgs = {
    /**
     * Select specific fields to fetch from the faucet_requests
     * 
    **/
    select?: faucet_requestsSelect | null
    /**
     * Filter which faucet_requests to delete.
     * 
    **/
    where: faucet_requestsWhereUniqueInput
  }


  /**
   * faucet_requests deleteMany
   */
  export type faucet_requestsDeleteManyArgs = {
    /**
     * Filter which faucet_requests to delete
     * 
    **/
    where?: faucet_requestsWhereInput
  }


  /**
   * faucet_requests without action
   */
  export type faucet_requestsArgs = {
    /**
     * Select specific fields to fetch from the faucet_requests
     * 
    **/
    select?: faucet_requestsSelect | null
  }



  /**
   * Model ft_events
   */


  export type AggregateFt_events = {
    _count: Ft_eventsCountAggregateOutputType | null
    _avg: Ft_eventsAvgAggregateOutputType | null
    _sum: Ft_eventsSumAggregateOutputType | null
    _min: Ft_eventsMinAggregateOutputType | null
    _max: Ft_eventsMaxAggregateOutputType | null
  }

  export type Ft_eventsAvgAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
    asset_event_type_id: number | null
    amount: Decimal | null
  }

  export type Ft_eventsSumAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
    asset_event_type_id: number | null
    amount: Decimal | null
  }

  export type Ft_eventsMinAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    asset_event_type_id: number | null
    asset_identifier: string | null
    amount: Decimal | null
    sender: string | null
    recipient: string | null
  }

  export type Ft_eventsMaxAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    asset_event_type_id: number | null
    asset_identifier: string | null
    amount: Decimal | null
    sender: string | null
    recipient: string | null
  }

  export type Ft_eventsCountAggregateOutputType = {
    id: number
    event_index: number
    tx_id: number
    tx_index: number
    block_height: number
    index_block_hash: number
    parent_index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    microblock_canonical: number
    canonical: number
    asset_event_type_id: number
    asset_identifier: number
    amount: number
    sender: number
    recipient: number
    _all: number
  }


  export type Ft_eventsAvgAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
    asset_event_type_id?: true
    amount?: true
  }

  export type Ft_eventsSumAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
    asset_event_type_id?: true
    amount?: true
  }

  export type Ft_eventsMinAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    asset_event_type_id?: true
    asset_identifier?: true
    amount?: true
    sender?: true
    recipient?: true
  }

  export type Ft_eventsMaxAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    asset_event_type_id?: true
    asset_identifier?: true
    amount?: true
    sender?: true
    recipient?: true
  }

  export type Ft_eventsCountAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    asset_event_type_id?: true
    asset_identifier?: true
    amount?: true
    sender?: true
    recipient?: true
    _all?: true
  }

  export type Ft_eventsAggregateArgs = {
    /**
     * Filter which ft_events to aggregate.
     * 
    **/
    where?: ft_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ft_events to fetch.
     * 
    **/
    orderBy?: Enumerable<ft_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ft_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ft_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ft_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ft_events
    **/
    _count?: true | Ft_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ft_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ft_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ft_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ft_eventsMaxAggregateInputType
  }

  export type GetFt_eventsAggregateType<T extends Ft_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateFt_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFt_events[P]>
      : GetScalarType<T[P], AggregateFt_events[P]>
  }




  export type Ft_eventsGroupByArgs = {
    where?: ft_eventsWhereInput
    orderBy?: Enumerable<ft_eventsOrderByWithAggregationInput>
    by: Array<Ft_eventsScalarFieldEnum>
    having?: ft_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ft_eventsCountAggregateInputType | true
    _avg?: Ft_eventsAvgAggregateInputType
    _sum?: Ft_eventsSumAggregateInputType
    _min?: Ft_eventsMinAggregateInputType
    _max?: Ft_eventsMaxAggregateInputType
  }


  export type Ft_eventsGroupByOutputType = {
    id: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    asset_identifier: string
    amount: Decimal
    sender: string | null
    recipient: string | null
    _count: Ft_eventsCountAggregateOutputType | null
    _avg: Ft_eventsAvgAggregateOutputType | null
    _sum: Ft_eventsSumAggregateOutputType | null
    _min: Ft_eventsMinAggregateOutputType | null
    _max: Ft_eventsMaxAggregateOutputType | null
  }

  type GetFt_eventsGroupByPayload<T extends Ft_eventsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Ft_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ft_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ft_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Ft_eventsGroupByOutputType[P]>
        }
      >
    >


  export type ft_eventsSelect = {
    id?: boolean
    event_index?: boolean
    tx_id?: boolean
    tx_index?: boolean
    block_height?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_canonical?: boolean
    canonical?: boolean
    asset_event_type_id?: boolean
    asset_identifier?: boolean
    amount?: boolean
    sender?: boolean
    recipient?: boolean
  }


  export type ft_eventsGetPayload<S extends boolean | null | undefined | ft_eventsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ft_events :
    S extends undefined ? never :
    S extends { include: any } & (ft_eventsArgs | ft_eventsFindManyArgs)
    ? ft_events 
    : S extends { select: any } & (ft_eventsArgs | ft_eventsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ft_events ? ft_events[P] : never
  } 
      : ft_events


  type ft_eventsCountArgs = Merge<
    Omit<ft_eventsFindManyArgs, 'select' | 'include'> & {
      select?: Ft_eventsCountAggregateInputType | true
    }
  >

  export interface ft_eventsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Ft_events that matches the filter.
     * @param {ft_eventsFindUniqueArgs} args - Arguments to find a Ft_events
     * @example
     * // Get one Ft_events
     * const ft_events = await prisma.ft_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ft_eventsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ft_eventsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ft_events'> extends True ? Prisma__ft_eventsClient<ft_eventsGetPayload<T>> : Prisma__ft_eventsClient<ft_eventsGetPayload<T> | null, null>

    /**
     * Find one Ft_events that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ft_eventsFindUniqueOrThrowArgs} args - Arguments to find a Ft_events
     * @example
     * // Get one Ft_events
     * const ft_events = await prisma.ft_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ft_eventsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ft_eventsFindUniqueOrThrowArgs>
    ): Prisma__ft_eventsClient<ft_eventsGetPayload<T>>

    /**
     * Find the first Ft_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ft_eventsFindFirstArgs} args - Arguments to find a Ft_events
     * @example
     * // Get one Ft_events
     * const ft_events = await prisma.ft_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ft_eventsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ft_eventsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ft_events'> extends True ? Prisma__ft_eventsClient<ft_eventsGetPayload<T>> : Prisma__ft_eventsClient<ft_eventsGetPayload<T> | null, null>

    /**
     * Find the first Ft_events that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ft_eventsFindFirstOrThrowArgs} args - Arguments to find a Ft_events
     * @example
     * // Get one Ft_events
     * const ft_events = await prisma.ft_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ft_eventsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ft_eventsFindFirstOrThrowArgs>
    ): Prisma__ft_eventsClient<ft_eventsGetPayload<T>>

    /**
     * Find zero or more Ft_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ft_eventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ft_events
     * const ft_events = await prisma.ft_events.findMany()
     * 
     * // Get first 10 Ft_events
     * const ft_events = await prisma.ft_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ft_eventsWithIdOnly = await prisma.ft_events.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ft_eventsFindManyArgs>(
      args?: SelectSubset<T, ft_eventsFindManyArgs>
    ): PrismaPromise<Array<ft_eventsGetPayload<T>>>

    /**
     * Create a Ft_events.
     * @param {ft_eventsCreateArgs} args - Arguments to create a Ft_events.
     * @example
     * // Create one Ft_events
     * const Ft_events = await prisma.ft_events.create({
     *   data: {
     *     // ... data to create a Ft_events
     *   }
     * })
     * 
    **/
    create<T extends ft_eventsCreateArgs>(
      args: SelectSubset<T, ft_eventsCreateArgs>
    ): Prisma__ft_eventsClient<ft_eventsGetPayload<T>>

    /**
     * Create many Ft_events.
     *     @param {ft_eventsCreateManyArgs} args - Arguments to create many Ft_events.
     *     @example
     *     // Create many Ft_events
     *     const ft_events = await prisma.ft_events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ft_eventsCreateManyArgs>(
      args?: SelectSubset<T, ft_eventsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ft_events.
     * @param {ft_eventsDeleteArgs} args - Arguments to delete one Ft_events.
     * @example
     * // Delete one Ft_events
     * const Ft_events = await prisma.ft_events.delete({
     *   where: {
     *     // ... filter to delete one Ft_events
     *   }
     * })
     * 
    **/
    delete<T extends ft_eventsDeleteArgs>(
      args: SelectSubset<T, ft_eventsDeleteArgs>
    ): Prisma__ft_eventsClient<ft_eventsGetPayload<T>>

    /**
     * Update one Ft_events.
     * @param {ft_eventsUpdateArgs} args - Arguments to update one Ft_events.
     * @example
     * // Update one Ft_events
     * const ft_events = await prisma.ft_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ft_eventsUpdateArgs>(
      args: SelectSubset<T, ft_eventsUpdateArgs>
    ): Prisma__ft_eventsClient<ft_eventsGetPayload<T>>

    /**
     * Delete zero or more Ft_events.
     * @param {ft_eventsDeleteManyArgs} args - Arguments to filter Ft_events to delete.
     * @example
     * // Delete a few Ft_events
     * const { count } = await prisma.ft_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ft_eventsDeleteManyArgs>(
      args?: SelectSubset<T, ft_eventsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ft_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ft_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ft_events
     * const ft_events = await prisma.ft_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ft_eventsUpdateManyArgs>(
      args: SelectSubset<T, ft_eventsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ft_events.
     * @param {ft_eventsUpsertArgs} args - Arguments to update or create a Ft_events.
     * @example
     * // Update or create a Ft_events
     * const ft_events = await prisma.ft_events.upsert({
     *   create: {
     *     // ... data to create a Ft_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ft_events we want to update
     *   }
     * })
    **/
    upsert<T extends ft_eventsUpsertArgs>(
      args: SelectSubset<T, ft_eventsUpsertArgs>
    ): Prisma__ft_eventsClient<ft_eventsGetPayload<T>>

    /**
     * Count the number of Ft_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ft_eventsCountArgs} args - Arguments to filter Ft_events to count.
     * @example
     * // Count the number of Ft_events
     * const count = await prisma.ft_events.count({
     *   where: {
     *     // ... the filter for the Ft_events we want to count
     *   }
     * })
    **/
    count<T extends ft_eventsCountArgs>(
      args?: Subset<T, ft_eventsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ft_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ft_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ft_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ft_eventsAggregateArgs>(args: Subset<T, Ft_eventsAggregateArgs>): PrismaPromise<GetFt_eventsAggregateType<T>>

    /**
     * Group by Ft_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ft_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ft_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ft_eventsGroupByArgs['orderBy'] }
        : { orderBy?: Ft_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ft_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFt_eventsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ft_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ft_eventsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ft_events base type for findUnique actions
   */
  export type ft_eventsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ft_events
     * 
    **/
    select?: ft_eventsSelect | null
    /**
     * Filter, which ft_events to fetch.
     * 
    **/
    where: ft_eventsWhereUniqueInput
  }

  /**
   * ft_events: findUnique
   */
  export interface ft_eventsFindUniqueArgs extends ft_eventsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ft_events findUniqueOrThrow
   */
  export type ft_eventsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ft_events
     * 
    **/
    select?: ft_eventsSelect | null
    /**
     * Filter, which ft_events to fetch.
     * 
    **/
    where: ft_eventsWhereUniqueInput
  }


  /**
   * ft_events base type for findFirst actions
   */
  export type ft_eventsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ft_events
     * 
    **/
    select?: ft_eventsSelect | null
    /**
     * Filter, which ft_events to fetch.
     * 
    **/
    where?: ft_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ft_events to fetch.
     * 
    **/
    orderBy?: Enumerable<ft_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ft_events.
     * 
    **/
    cursor?: ft_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ft_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ft_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ft_events.
     * 
    **/
    distinct?: Enumerable<Ft_eventsScalarFieldEnum>
  }

  /**
   * ft_events: findFirst
   */
  export interface ft_eventsFindFirstArgs extends ft_eventsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ft_events findFirstOrThrow
   */
  export type ft_eventsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ft_events
     * 
    **/
    select?: ft_eventsSelect | null
    /**
     * Filter, which ft_events to fetch.
     * 
    **/
    where?: ft_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ft_events to fetch.
     * 
    **/
    orderBy?: Enumerable<ft_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ft_events.
     * 
    **/
    cursor?: ft_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ft_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ft_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ft_events.
     * 
    **/
    distinct?: Enumerable<Ft_eventsScalarFieldEnum>
  }


  /**
   * ft_events findMany
   */
  export type ft_eventsFindManyArgs = {
    /**
     * Select specific fields to fetch from the ft_events
     * 
    **/
    select?: ft_eventsSelect | null
    /**
     * Filter, which ft_events to fetch.
     * 
    **/
    where?: ft_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ft_events to fetch.
     * 
    **/
    orderBy?: Enumerable<ft_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ft_events.
     * 
    **/
    cursor?: ft_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ft_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ft_events.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Ft_eventsScalarFieldEnum>
  }


  /**
   * ft_events create
   */
  export type ft_eventsCreateArgs = {
    /**
     * Select specific fields to fetch from the ft_events
     * 
    **/
    select?: ft_eventsSelect | null
    /**
     * The data needed to create a ft_events.
     * 
    **/
    data: XOR<ft_eventsCreateInput, ft_eventsUncheckedCreateInput>
  }


  /**
   * ft_events createMany
   */
  export type ft_eventsCreateManyArgs = {
    /**
     * The data used to create many ft_events.
     * 
    **/
    data: Enumerable<ft_eventsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ft_events update
   */
  export type ft_eventsUpdateArgs = {
    /**
     * Select specific fields to fetch from the ft_events
     * 
    **/
    select?: ft_eventsSelect | null
    /**
     * The data needed to update a ft_events.
     * 
    **/
    data: XOR<ft_eventsUpdateInput, ft_eventsUncheckedUpdateInput>
    /**
     * Choose, which ft_events to update.
     * 
    **/
    where: ft_eventsWhereUniqueInput
  }


  /**
   * ft_events updateMany
   */
  export type ft_eventsUpdateManyArgs = {
    /**
     * The data used to update ft_events.
     * 
    **/
    data: XOR<ft_eventsUpdateManyMutationInput, ft_eventsUncheckedUpdateManyInput>
    /**
     * Filter which ft_events to update
     * 
    **/
    where?: ft_eventsWhereInput
  }


  /**
   * ft_events upsert
   */
  export type ft_eventsUpsertArgs = {
    /**
     * Select specific fields to fetch from the ft_events
     * 
    **/
    select?: ft_eventsSelect | null
    /**
     * The filter to search for the ft_events to update in case it exists.
     * 
    **/
    where: ft_eventsWhereUniqueInput
    /**
     * In case the ft_events found by the `where` argument doesn't exist, create a new ft_events with this data.
     * 
    **/
    create: XOR<ft_eventsCreateInput, ft_eventsUncheckedCreateInput>
    /**
     * In case the ft_events was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ft_eventsUpdateInput, ft_eventsUncheckedUpdateInput>
  }


  /**
   * ft_events delete
   */
  export type ft_eventsDeleteArgs = {
    /**
     * Select specific fields to fetch from the ft_events
     * 
    **/
    select?: ft_eventsSelect | null
    /**
     * Filter which ft_events to delete.
     * 
    **/
    where: ft_eventsWhereUniqueInput
  }


  /**
   * ft_events deleteMany
   */
  export type ft_eventsDeleteManyArgs = {
    /**
     * Filter which ft_events to delete
     * 
    **/
    where?: ft_eventsWhereInput
  }


  /**
   * ft_events without action
   */
  export type ft_eventsArgs = {
    /**
     * Select specific fields to fetch from the ft_events
     * 
    **/
    select?: ft_eventsSelect | null
  }



  /**
   * Model ft_metadata
   */


  export type AggregateFt_metadata = {
    _count: Ft_metadataCountAggregateOutputType | null
    _avg: Ft_metadataAvgAggregateOutputType | null
    _sum: Ft_metadataSumAggregateOutputType | null
    _min: Ft_metadataMinAggregateOutputType | null
    _max: Ft_metadataMaxAggregateOutputType | null
  }

  export type Ft_metadataAvgAggregateOutputType = {
    id: number | null
    decimals: number | null
  }

  export type Ft_metadataSumAggregateOutputType = {
    id: number | null
    decimals: number | null
  }

  export type Ft_metadataMinAggregateOutputType = {
    id: number | null
    name: string | null
    token_uri: string | null
    description: string | null
    image_uri: string | null
    image_canonical_uri: string | null
    contract_id: string | null
    symbol: string | null
    decimals: number | null
    tx_id: Buffer | null
    sender_address: string | null
  }

  export type Ft_metadataMaxAggregateOutputType = {
    id: number | null
    name: string | null
    token_uri: string | null
    description: string | null
    image_uri: string | null
    image_canonical_uri: string | null
    contract_id: string | null
    symbol: string | null
    decimals: number | null
    tx_id: Buffer | null
    sender_address: string | null
  }

  export type Ft_metadataCountAggregateOutputType = {
    id: number
    name: number
    token_uri: number
    description: number
    image_uri: number
    image_canonical_uri: number
    contract_id: number
    symbol: number
    decimals: number
    tx_id: number
    sender_address: number
    _all: number
  }


  export type Ft_metadataAvgAggregateInputType = {
    id?: true
    decimals?: true
  }

  export type Ft_metadataSumAggregateInputType = {
    id?: true
    decimals?: true
  }

  export type Ft_metadataMinAggregateInputType = {
    id?: true
    name?: true
    token_uri?: true
    description?: true
    image_uri?: true
    image_canonical_uri?: true
    contract_id?: true
    symbol?: true
    decimals?: true
    tx_id?: true
    sender_address?: true
  }

  export type Ft_metadataMaxAggregateInputType = {
    id?: true
    name?: true
    token_uri?: true
    description?: true
    image_uri?: true
    image_canonical_uri?: true
    contract_id?: true
    symbol?: true
    decimals?: true
    tx_id?: true
    sender_address?: true
  }

  export type Ft_metadataCountAggregateInputType = {
    id?: true
    name?: true
    token_uri?: true
    description?: true
    image_uri?: true
    image_canonical_uri?: true
    contract_id?: true
    symbol?: true
    decimals?: true
    tx_id?: true
    sender_address?: true
    _all?: true
  }

  export type Ft_metadataAggregateArgs = {
    /**
     * Filter which ft_metadata to aggregate.
     * 
    **/
    where?: ft_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ft_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<ft_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ft_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ft_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ft_metadata.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ft_metadata
    **/
    _count?: true | Ft_metadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Ft_metadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Ft_metadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Ft_metadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Ft_metadataMaxAggregateInputType
  }

  export type GetFt_metadataAggregateType<T extends Ft_metadataAggregateArgs> = {
        [P in keyof T & keyof AggregateFt_metadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFt_metadata[P]>
      : GetScalarType<T[P], AggregateFt_metadata[P]>
  }




  export type Ft_metadataGroupByArgs = {
    where?: ft_metadataWhereInput
    orderBy?: Enumerable<ft_metadataOrderByWithAggregationInput>
    by: Array<Ft_metadataScalarFieldEnum>
    having?: ft_metadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Ft_metadataCountAggregateInputType | true
    _avg?: Ft_metadataAvgAggregateInputType
    _sum?: Ft_metadataSumAggregateInputType
    _min?: Ft_metadataMinAggregateInputType
    _max?: Ft_metadataMaxAggregateInputType
  }


  export type Ft_metadataGroupByOutputType = {
    id: number
    name: string
    token_uri: string
    description: string
    image_uri: string
    image_canonical_uri: string
    contract_id: string
    symbol: string
    decimals: number
    tx_id: Buffer
    sender_address: string
    _count: Ft_metadataCountAggregateOutputType | null
    _avg: Ft_metadataAvgAggregateOutputType | null
    _sum: Ft_metadataSumAggregateOutputType | null
    _min: Ft_metadataMinAggregateOutputType | null
    _max: Ft_metadataMaxAggregateOutputType | null
  }

  type GetFt_metadataGroupByPayload<T extends Ft_metadataGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Ft_metadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Ft_metadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Ft_metadataGroupByOutputType[P]>
            : GetScalarType<T[P], Ft_metadataGroupByOutputType[P]>
        }
      >
    >


  export type ft_metadataSelect = {
    id?: boolean
    name?: boolean
    token_uri?: boolean
    description?: boolean
    image_uri?: boolean
    image_canonical_uri?: boolean
    contract_id?: boolean
    symbol?: boolean
    decimals?: boolean
    tx_id?: boolean
    sender_address?: boolean
  }


  export type ft_metadataGetPayload<S extends boolean | null | undefined | ft_metadataArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ft_metadata :
    S extends undefined ? never :
    S extends { include: any } & (ft_metadataArgs | ft_metadataFindManyArgs)
    ? ft_metadata 
    : S extends { select: any } & (ft_metadataArgs | ft_metadataFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ft_metadata ? ft_metadata[P] : never
  } 
      : ft_metadata


  type ft_metadataCountArgs = Merge<
    Omit<ft_metadataFindManyArgs, 'select' | 'include'> & {
      select?: Ft_metadataCountAggregateInputType | true
    }
  >

  export interface ft_metadataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Ft_metadata that matches the filter.
     * @param {ft_metadataFindUniqueArgs} args - Arguments to find a Ft_metadata
     * @example
     * // Get one Ft_metadata
     * const ft_metadata = await prisma.ft_metadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ft_metadataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ft_metadataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ft_metadata'> extends True ? Prisma__ft_metadataClient<ft_metadataGetPayload<T>> : Prisma__ft_metadataClient<ft_metadataGetPayload<T> | null, null>

    /**
     * Find one Ft_metadata that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ft_metadataFindUniqueOrThrowArgs} args - Arguments to find a Ft_metadata
     * @example
     * // Get one Ft_metadata
     * const ft_metadata = await prisma.ft_metadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ft_metadataFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ft_metadataFindUniqueOrThrowArgs>
    ): Prisma__ft_metadataClient<ft_metadataGetPayload<T>>

    /**
     * Find the first Ft_metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ft_metadataFindFirstArgs} args - Arguments to find a Ft_metadata
     * @example
     * // Get one Ft_metadata
     * const ft_metadata = await prisma.ft_metadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ft_metadataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ft_metadataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ft_metadata'> extends True ? Prisma__ft_metadataClient<ft_metadataGetPayload<T>> : Prisma__ft_metadataClient<ft_metadataGetPayload<T> | null, null>

    /**
     * Find the first Ft_metadata that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ft_metadataFindFirstOrThrowArgs} args - Arguments to find a Ft_metadata
     * @example
     * // Get one Ft_metadata
     * const ft_metadata = await prisma.ft_metadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ft_metadataFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ft_metadataFindFirstOrThrowArgs>
    ): Prisma__ft_metadataClient<ft_metadataGetPayload<T>>

    /**
     * Find zero or more Ft_metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ft_metadataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ft_metadata
     * const ft_metadata = await prisma.ft_metadata.findMany()
     * 
     * // Get first 10 Ft_metadata
     * const ft_metadata = await prisma.ft_metadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ft_metadataWithIdOnly = await prisma.ft_metadata.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ft_metadataFindManyArgs>(
      args?: SelectSubset<T, ft_metadataFindManyArgs>
    ): PrismaPromise<Array<ft_metadataGetPayload<T>>>

    /**
     * Create a Ft_metadata.
     * @param {ft_metadataCreateArgs} args - Arguments to create a Ft_metadata.
     * @example
     * // Create one Ft_metadata
     * const Ft_metadata = await prisma.ft_metadata.create({
     *   data: {
     *     // ... data to create a Ft_metadata
     *   }
     * })
     * 
    **/
    create<T extends ft_metadataCreateArgs>(
      args: SelectSubset<T, ft_metadataCreateArgs>
    ): Prisma__ft_metadataClient<ft_metadataGetPayload<T>>

    /**
     * Create many Ft_metadata.
     *     @param {ft_metadataCreateManyArgs} args - Arguments to create many Ft_metadata.
     *     @example
     *     // Create many Ft_metadata
     *     const ft_metadata = await prisma.ft_metadata.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ft_metadataCreateManyArgs>(
      args?: SelectSubset<T, ft_metadataCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Ft_metadata.
     * @param {ft_metadataDeleteArgs} args - Arguments to delete one Ft_metadata.
     * @example
     * // Delete one Ft_metadata
     * const Ft_metadata = await prisma.ft_metadata.delete({
     *   where: {
     *     // ... filter to delete one Ft_metadata
     *   }
     * })
     * 
    **/
    delete<T extends ft_metadataDeleteArgs>(
      args: SelectSubset<T, ft_metadataDeleteArgs>
    ): Prisma__ft_metadataClient<ft_metadataGetPayload<T>>

    /**
     * Update one Ft_metadata.
     * @param {ft_metadataUpdateArgs} args - Arguments to update one Ft_metadata.
     * @example
     * // Update one Ft_metadata
     * const ft_metadata = await prisma.ft_metadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ft_metadataUpdateArgs>(
      args: SelectSubset<T, ft_metadataUpdateArgs>
    ): Prisma__ft_metadataClient<ft_metadataGetPayload<T>>

    /**
     * Delete zero or more Ft_metadata.
     * @param {ft_metadataDeleteManyArgs} args - Arguments to filter Ft_metadata to delete.
     * @example
     * // Delete a few Ft_metadata
     * const { count } = await prisma.ft_metadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ft_metadataDeleteManyArgs>(
      args?: SelectSubset<T, ft_metadataDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ft_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ft_metadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ft_metadata
     * const ft_metadata = await prisma.ft_metadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ft_metadataUpdateManyArgs>(
      args: SelectSubset<T, ft_metadataUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Ft_metadata.
     * @param {ft_metadataUpsertArgs} args - Arguments to update or create a Ft_metadata.
     * @example
     * // Update or create a Ft_metadata
     * const ft_metadata = await prisma.ft_metadata.upsert({
     *   create: {
     *     // ... data to create a Ft_metadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ft_metadata we want to update
     *   }
     * })
    **/
    upsert<T extends ft_metadataUpsertArgs>(
      args: SelectSubset<T, ft_metadataUpsertArgs>
    ): Prisma__ft_metadataClient<ft_metadataGetPayload<T>>

    /**
     * Count the number of Ft_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ft_metadataCountArgs} args - Arguments to filter Ft_metadata to count.
     * @example
     * // Count the number of Ft_metadata
     * const count = await prisma.ft_metadata.count({
     *   where: {
     *     // ... the filter for the Ft_metadata we want to count
     *   }
     * })
    **/
    count<T extends ft_metadataCountArgs>(
      args?: Subset<T, ft_metadataCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Ft_metadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ft_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ft_metadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Ft_metadataAggregateArgs>(args: Subset<T, Ft_metadataAggregateArgs>): PrismaPromise<GetFt_metadataAggregateType<T>>

    /**
     * Group by Ft_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Ft_metadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Ft_metadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Ft_metadataGroupByArgs['orderBy'] }
        : { orderBy?: Ft_metadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Ft_metadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFt_metadataGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ft_metadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ft_metadataClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ft_metadata base type for findUnique actions
   */
  export type ft_metadataFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ft_metadata
     * 
    **/
    select?: ft_metadataSelect | null
    /**
     * Filter, which ft_metadata to fetch.
     * 
    **/
    where: ft_metadataWhereUniqueInput
  }

  /**
   * ft_metadata: findUnique
   */
  export interface ft_metadataFindUniqueArgs extends ft_metadataFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ft_metadata findUniqueOrThrow
   */
  export type ft_metadataFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ft_metadata
     * 
    **/
    select?: ft_metadataSelect | null
    /**
     * Filter, which ft_metadata to fetch.
     * 
    **/
    where: ft_metadataWhereUniqueInput
  }


  /**
   * ft_metadata base type for findFirst actions
   */
  export type ft_metadataFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ft_metadata
     * 
    **/
    select?: ft_metadataSelect | null
    /**
     * Filter, which ft_metadata to fetch.
     * 
    **/
    where?: ft_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ft_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<ft_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ft_metadata.
     * 
    **/
    cursor?: ft_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ft_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ft_metadata.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ft_metadata.
     * 
    **/
    distinct?: Enumerable<Ft_metadataScalarFieldEnum>
  }

  /**
   * ft_metadata: findFirst
   */
  export interface ft_metadataFindFirstArgs extends ft_metadataFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ft_metadata findFirstOrThrow
   */
  export type ft_metadataFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ft_metadata
     * 
    **/
    select?: ft_metadataSelect | null
    /**
     * Filter, which ft_metadata to fetch.
     * 
    **/
    where?: ft_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ft_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<ft_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ft_metadata.
     * 
    **/
    cursor?: ft_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ft_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ft_metadata.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ft_metadata.
     * 
    **/
    distinct?: Enumerable<Ft_metadataScalarFieldEnum>
  }


  /**
   * ft_metadata findMany
   */
  export type ft_metadataFindManyArgs = {
    /**
     * Select specific fields to fetch from the ft_metadata
     * 
    **/
    select?: ft_metadataSelect | null
    /**
     * Filter, which ft_metadata to fetch.
     * 
    **/
    where?: ft_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ft_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<ft_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ft_metadata.
     * 
    **/
    cursor?: ft_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ft_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ft_metadata.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Ft_metadataScalarFieldEnum>
  }


  /**
   * ft_metadata create
   */
  export type ft_metadataCreateArgs = {
    /**
     * Select specific fields to fetch from the ft_metadata
     * 
    **/
    select?: ft_metadataSelect | null
    /**
     * The data needed to create a ft_metadata.
     * 
    **/
    data: XOR<ft_metadataCreateInput, ft_metadataUncheckedCreateInput>
  }


  /**
   * ft_metadata createMany
   */
  export type ft_metadataCreateManyArgs = {
    /**
     * The data used to create many ft_metadata.
     * 
    **/
    data: Enumerable<ft_metadataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ft_metadata update
   */
  export type ft_metadataUpdateArgs = {
    /**
     * Select specific fields to fetch from the ft_metadata
     * 
    **/
    select?: ft_metadataSelect | null
    /**
     * The data needed to update a ft_metadata.
     * 
    **/
    data: XOR<ft_metadataUpdateInput, ft_metadataUncheckedUpdateInput>
    /**
     * Choose, which ft_metadata to update.
     * 
    **/
    where: ft_metadataWhereUniqueInput
  }


  /**
   * ft_metadata updateMany
   */
  export type ft_metadataUpdateManyArgs = {
    /**
     * The data used to update ft_metadata.
     * 
    **/
    data: XOR<ft_metadataUpdateManyMutationInput, ft_metadataUncheckedUpdateManyInput>
    /**
     * Filter which ft_metadata to update
     * 
    **/
    where?: ft_metadataWhereInput
  }


  /**
   * ft_metadata upsert
   */
  export type ft_metadataUpsertArgs = {
    /**
     * Select specific fields to fetch from the ft_metadata
     * 
    **/
    select?: ft_metadataSelect | null
    /**
     * The filter to search for the ft_metadata to update in case it exists.
     * 
    **/
    where: ft_metadataWhereUniqueInput
    /**
     * In case the ft_metadata found by the `where` argument doesn't exist, create a new ft_metadata with this data.
     * 
    **/
    create: XOR<ft_metadataCreateInput, ft_metadataUncheckedCreateInput>
    /**
     * In case the ft_metadata was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ft_metadataUpdateInput, ft_metadataUncheckedUpdateInput>
  }


  /**
   * ft_metadata delete
   */
  export type ft_metadataDeleteArgs = {
    /**
     * Select specific fields to fetch from the ft_metadata
     * 
    **/
    select?: ft_metadataSelect | null
    /**
     * Filter which ft_metadata to delete.
     * 
    **/
    where: ft_metadataWhereUniqueInput
  }


  /**
   * ft_metadata deleteMany
   */
  export type ft_metadataDeleteManyArgs = {
    /**
     * Filter which ft_metadata to delete
     * 
    **/
    where?: ft_metadataWhereInput
  }


  /**
   * ft_metadata without action
   */
  export type ft_metadataArgs = {
    /**
     * Select specific fields to fetch from the ft_metadata
     * 
    **/
    select?: ft_metadataSelect | null
  }



  /**
   * Model mempool_txs
   */


  export type AggregateMempool_txs = {
    _count: Mempool_txsCountAggregateOutputType | null
    _avg: Mempool_txsAvgAggregateOutputType | null
    _sum: Mempool_txsSumAggregateOutputType | null
    _min: Mempool_txsMinAggregateOutputType | null
    _max: Mempool_txsMaxAggregateOutputType | null
  }

  export type Mempool_txsAvgAggregateOutputType = {
    id: number | null
    type_id: number | null
    anchor_mode: number | null
    status: number | null
    nonce: number | null
    fee_rate: number | null
    sponsor_nonce: number | null
    origin_hash_mode: number | null
    receipt_time: number | null
    receipt_block_height: number | null
    token_transfer_amount: number | null
    smart_contract_clarity_version: number | null
    tx_size: number | null
  }

  export type Mempool_txsSumAggregateOutputType = {
    id: number | null
    type_id: number | null
    anchor_mode: number | null
    status: number | null
    nonce: number | null
    fee_rate: bigint | null
    sponsor_nonce: number | null
    origin_hash_mode: number | null
    receipt_time: number | null
    receipt_block_height: number | null
    token_transfer_amount: bigint | null
    smart_contract_clarity_version: number | null
    tx_size: number | null
  }

  export type Mempool_txsMinAggregateOutputType = {
    id: number | null
    pruned: boolean | null
    tx_id: Buffer | null
    type_id: number | null
    anchor_mode: number | null
    status: number | null
    post_conditions: Buffer | null
    nonce: number | null
    fee_rate: bigint | null
    sponsored: boolean | null
    sponsor_address: string | null
    sponsor_nonce: number | null
    sender_address: string | null
    origin_hash_mode: number | null
    raw_tx: Buffer | null
    receipt_time: number | null
    receipt_block_height: number | null
    token_transfer_recipient_address: string | null
    token_transfer_amount: bigint | null
    token_transfer_memo: Buffer | null
    smart_contract_clarity_version: number | null
    smart_contract_contract_id: string | null
    smart_contract_source_code: string | null
    contract_call_contract_id: string | null
    contract_call_function_name: string | null
    contract_call_function_args: Buffer | null
    poison_microblock_header_1: Buffer | null
    poison_microblock_header_2: Buffer | null
    coinbase_payload: Buffer | null
    coinbase_alt_recipient: string | null
    tx_size: number | null
  }

  export type Mempool_txsMaxAggregateOutputType = {
    id: number | null
    pruned: boolean | null
    tx_id: Buffer | null
    type_id: number | null
    anchor_mode: number | null
    status: number | null
    post_conditions: Buffer | null
    nonce: number | null
    fee_rate: bigint | null
    sponsored: boolean | null
    sponsor_address: string | null
    sponsor_nonce: number | null
    sender_address: string | null
    origin_hash_mode: number | null
    raw_tx: Buffer | null
    receipt_time: number | null
    receipt_block_height: number | null
    token_transfer_recipient_address: string | null
    token_transfer_amount: bigint | null
    token_transfer_memo: Buffer | null
    smart_contract_clarity_version: number | null
    smart_contract_contract_id: string | null
    smart_contract_source_code: string | null
    contract_call_contract_id: string | null
    contract_call_function_name: string | null
    contract_call_function_args: Buffer | null
    poison_microblock_header_1: Buffer | null
    poison_microblock_header_2: Buffer | null
    coinbase_payload: Buffer | null
    coinbase_alt_recipient: string | null
    tx_size: number | null
  }

  export type Mempool_txsCountAggregateOutputType = {
    id: number
    pruned: number
    tx_id: number
    type_id: number
    anchor_mode: number
    status: number
    post_conditions: number
    nonce: number
    fee_rate: number
    sponsored: number
    sponsor_address: number
    sponsor_nonce: number
    sender_address: number
    origin_hash_mode: number
    raw_tx: number
    receipt_time: number
    receipt_block_height: number
    token_transfer_recipient_address: number
    token_transfer_amount: number
    token_transfer_memo: number
    smart_contract_clarity_version: number
    smart_contract_contract_id: number
    smart_contract_source_code: number
    contract_call_contract_id: number
    contract_call_function_name: number
    contract_call_function_args: number
    poison_microblock_header_1: number
    poison_microblock_header_2: number
    coinbase_payload: number
    coinbase_alt_recipient: number
    tx_size: number
    _all: number
  }


  export type Mempool_txsAvgAggregateInputType = {
    id?: true
    type_id?: true
    anchor_mode?: true
    status?: true
    nonce?: true
    fee_rate?: true
    sponsor_nonce?: true
    origin_hash_mode?: true
    receipt_time?: true
    receipt_block_height?: true
    token_transfer_amount?: true
    smart_contract_clarity_version?: true
    tx_size?: true
  }

  export type Mempool_txsSumAggregateInputType = {
    id?: true
    type_id?: true
    anchor_mode?: true
    status?: true
    nonce?: true
    fee_rate?: true
    sponsor_nonce?: true
    origin_hash_mode?: true
    receipt_time?: true
    receipt_block_height?: true
    token_transfer_amount?: true
    smart_contract_clarity_version?: true
    tx_size?: true
  }

  export type Mempool_txsMinAggregateInputType = {
    id?: true
    pruned?: true
    tx_id?: true
    type_id?: true
    anchor_mode?: true
    status?: true
    post_conditions?: true
    nonce?: true
    fee_rate?: true
    sponsored?: true
    sponsor_address?: true
    sponsor_nonce?: true
    sender_address?: true
    origin_hash_mode?: true
    raw_tx?: true
    receipt_time?: true
    receipt_block_height?: true
    token_transfer_recipient_address?: true
    token_transfer_amount?: true
    token_transfer_memo?: true
    smart_contract_clarity_version?: true
    smart_contract_contract_id?: true
    smart_contract_source_code?: true
    contract_call_contract_id?: true
    contract_call_function_name?: true
    contract_call_function_args?: true
    poison_microblock_header_1?: true
    poison_microblock_header_2?: true
    coinbase_payload?: true
    coinbase_alt_recipient?: true
    tx_size?: true
  }

  export type Mempool_txsMaxAggregateInputType = {
    id?: true
    pruned?: true
    tx_id?: true
    type_id?: true
    anchor_mode?: true
    status?: true
    post_conditions?: true
    nonce?: true
    fee_rate?: true
    sponsored?: true
    sponsor_address?: true
    sponsor_nonce?: true
    sender_address?: true
    origin_hash_mode?: true
    raw_tx?: true
    receipt_time?: true
    receipt_block_height?: true
    token_transfer_recipient_address?: true
    token_transfer_amount?: true
    token_transfer_memo?: true
    smart_contract_clarity_version?: true
    smart_contract_contract_id?: true
    smart_contract_source_code?: true
    contract_call_contract_id?: true
    contract_call_function_name?: true
    contract_call_function_args?: true
    poison_microblock_header_1?: true
    poison_microblock_header_2?: true
    coinbase_payload?: true
    coinbase_alt_recipient?: true
    tx_size?: true
  }

  export type Mempool_txsCountAggregateInputType = {
    id?: true
    pruned?: true
    tx_id?: true
    type_id?: true
    anchor_mode?: true
    status?: true
    post_conditions?: true
    nonce?: true
    fee_rate?: true
    sponsored?: true
    sponsor_address?: true
    sponsor_nonce?: true
    sender_address?: true
    origin_hash_mode?: true
    raw_tx?: true
    receipt_time?: true
    receipt_block_height?: true
    token_transfer_recipient_address?: true
    token_transfer_amount?: true
    token_transfer_memo?: true
    smart_contract_clarity_version?: true
    smart_contract_contract_id?: true
    smart_contract_source_code?: true
    contract_call_contract_id?: true
    contract_call_function_name?: true
    contract_call_function_args?: true
    poison_microblock_header_1?: true
    poison_microblock_header_2?: true
    coinbase_payload?: true
    coinbase_alt_recipient?: true
    tx_size?: true
    _all?: true
  }

  export type Mempool_txsAggregateArgs = {
    /**
     * Filter which mempool_txs to aggregate.
     * 
    **/
    where?: mempool_txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mempool_txs to fetch.
     * 
    **/
    orderBy?: Enumerable<mempool_txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: mempool_txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mempool_txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mempool_txs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mempool_txs
    **/
    _count?: true | Mempool_txsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mempool_txsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mempool_txsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mempool_txsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mempool_txsMaxAggregateInputType
  }

  export type GetMempool_txsAggregateType<T extends Mempool_txsAggregateArgs> = {
        [P in keyof T & keyof AggregateMempool_txs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMempool_txs[P]>
      : GetScalarType<T[P], AggregateMempool_txs[P]>
  }




  export type Mempool_txsGroupByArgs = {
    where?: mempool_txsWhereInput
    orderBy?: Enumerable<mempool_txsOrderByWithAggregationInput>
    by: Array<Mempool_txsScalarFieldEnum>
    having?: mempool_txsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mempool_txsCountAggregateInputType | true
    _avg?: Mempool_txsAvgAggregateInputType
    _sum?: Mempool_txsSumAggregateInputType
    _min?: Mempool_txsMinAggregateInputType
    _max?: Mempool_txsMaxAggregateInputType
  }


  export type Mempool_txsGroupByOutputType = {
    id: number
    pruned: boolean
    tx_id: Buffer
    type_id: number
    anchor_mode: number
    status: number
    post_conditions: Buffer
    nonce: number
    fee_rate: bigint
    sponsored: boolean
    sponsor_address: string | null
    sponsor_nonce: number | null
    sender_address: string
    origin_hash_mode: number
    raw_tx: Buffer
    receipt_time: number
    receipt_block_height: number
    token_transfer_recipient_address: string | null
    token_transfer_amount: bigint | null
    token_transfer_memo: Buffer | null
    smart_contract_clarity_version: number | null
    smart_contract_contract_id: string | null
    smart_contract_source_code: string | null
    contract_call_contract_id: string | null
    contract_call_function_name: string | null
    contract_call_function_args: Buffer | null
    poison_microblock_header_1: Buffer | null
    poison_microblock_header_2: Buffer | null
    coinbase_payload: Buffer | null
    coinbase_alt_recipient: string | null
    tx_size: number
    _count: Mempool_txsCountAggregateOutputType | null
    _avg: Mempool_txsAvgAggregateOutputType | null
    _sum: Mempool_txsSumAggregateOutputType | null
    _min: Mempool_txsMinAggregateOutputType | null
    _max: Mempool_txsMaxAggregateOutputType | null
  }

  type GetMempool_txsGroupByPayload<T extends Mempool_txsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Mempool_txsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mempool_txsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mempool_txsGroupByOutputType[P]>
            : GetScalarType<T[P], Mempool_txsGroupByOutputType[P]>
        }
      >
    >


  export type mempool_txsSelect = {
    id?: boolean
    pruned?: boolean
    tx_id?: boolean
    type_id?: boolean
    anchor_mode?: boolean
    status?: boolean
    post_conditions?: boolean
    nonce?: boolean
    fee_rate?: boolean
    sponsored?: boolean
    sponsor_address?: boolean
    sponsor_nonce?: boolean
    sender_address?: boolean
    origin_hash_mode?: boolean
    raw_tx?: boolean
    receipt_time?: boolean
    receipt_block_height?: boolean
    token_transfer_recipient_address?: boolean
    token_transfer_amount?: boolean
    token_transfer_memo?: boolean
    smart_contract_clarity_version?: boolean
    smart_contract_contract_id?: boolean
    smart_contract_source_code?: boolean
    contract_call_contract_id?: boolean
    contract_call_function_name?: boolean
    contract_call_function_args?: boolean
    poison_microblock_header_1?: boolean
    poison_microblock_header_2?: boolean
    coinbase_payload?: boolean
    coinbase_alt_recipient?: boolean
    tx_size?: boolean
  }


  export type mempool_txsGetPayload<S extends boolean | null | undefined | mempool_txsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? mempool_txs :
    S extends undefined ? never :
    S extends { include: any } & (mempool_txsArgs | mempool_txsFindManyArgs)
    ? mempool_txs 
    : S extends { select: any } & (mempool_txsArgs | mempool_txsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof mempool_txs ? mempool_txs[P] : never
  } 
      : mempool_txs


  type mempool_txsCountArgs = Merge<
    Omit<mempool_txsFindManyArgs, 'select' | 'include'> & {
      select?: Mempool_txsCountAggregateInputType | true
    }
  >

  export interface mempool_txsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Mempool_txs that matches the filter.
     * @param {mempool_txsFindUniqueArgs} args - Arguments to find a Mempool_txs
     * @example
     * // Get one Mempool_txs
     * const mempool_txs = await prisma.mempool_txs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends mempool_txsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, mempool_txsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'mempool_txs'> extends True ? Prisma__mempool_txsClient<mempool_txsGetPayload<T>> : Prisma__mempool_txsClient<mempool_txsGetPayload<T> | null, null>

    /**
     * Find one Mempool_txs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {mempool_txsFindUniqueOrThrowArgs} args - Arguments to find a Mempool_txs
     * @example
     * // Get one Mempool_txs
     * const mempool_txs = await prisma.mempool_txs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends mempool_txsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, mempool_txsFindUniqueOrThrowArgs>
    ): Prisma__mempool_txsClient<mempool_txsGetPayload<T>>

    /**
     * Find the first Mempool_txs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mempool_txsFindFirstArgs} args - Arguments to find a Mempool_txs
     * @example
     * // Get one Mempool_txs
     * const mempool_txs = await prisma.mempool_txs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends mempool_txsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, mempool_txsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'mempool_txs'> extends True ? Prisma__mempool_txsClient<mempool_txsGetPayload<T>> : Prisma__mempool_txsClient<mempool_txsGetPayload<T> | null, null>

    /**
     * Find the first Mempool_txs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mempool_txsFindFirstOrThrowArgs} args - Arguments to find a Mempool_txs
     * @example
     * // Get one Mempool_txs
     * const mempool_txs = await prisma.mempool_txs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends mempool_txsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, mempool_txsFindFirstOrThrowArgs>
    ): Prisma__mempool_txsClient<mempool_txsGetPayload<T>>

    /**
     * Find zero or more Mempool_txs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mempool_txsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mempool_txs
     * const mempool_txs = await prisma.mempool_txs.findMany()
     * 
     * // Get first 10 Mempool_txs
     * const mempool_txs = await prisma.mempool_txs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mempool_txsWithIdOnly = await prisma.mempool_txs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends mempool_txsFindManyArgs>(
      args?: SelectSubset<T, mempool_txsFindManyArgs>
    ): PrismaPromise<Array<mempool_txsGetPayload<T>>>

    /**
     * Create a Mempool_txs.
     * @param {mempool_txsCreateArgs} args - Arguments to create a Mempool_txs.
     * @example
     * // Create one Mempool_txs
     * const Mempool_txs = await prisma.mempool_txs.create({
     *   data: {
     *     // ... data to create a Mempool_txs
     *   }
     * })
     * 
    **/
    create<T extends mempool_txsCreateArgs>(
      args: SelectSubset<T, mempool_txsCreateArgs>
    ): Prisma__mempool_txsClient<mempool_txsGetPayload<T>>

    /**
     * Create many Mempool_txs.
     *     @param {mempool_txsCreateManyArgs} args - Arguments to create many Mempool_txs.
     *     @example
     *     // Create many Mempool_txs
     *     const mempool_txs = await prisma.mempool_txs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends mempool_txsCreateManyArgs>(
      args?: SelectSubset<T, mempool_txsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Mempool_txs.
     * @param {mempool_txsDeleteArgs} args - Arguments to delete one Mempool_txs.
     * @example
     * // Delete one Mempool_txs
     * const Mempool_txs = await prisma.mempool_txs.delete({
     *   where: {
     *     // ... filter to delete one Mempool_txs
     *   }
     * })
     * 
    **/
    delete<T extends mempool_txsDeleteArgs>(
      args: SelectSubset<T, mempool_txsDeleteArgs>
    ): Prisma__mempool_txsClient<mempool_txsGetPayload<T>>

    /**
     * Update one Mempool_txs.
     * @param {mempool_txsUpdateArgs} args - Arguments to update one Mempool_txs.
     * @example
     * // Update one Mempool_txs
     * const mempool_txs = await prisma.mempool_txs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends mempool_txsUpdateArgs>(
      args: SelectSubset<T, mempool_txsUpdateArgs>
    ): Prisma__mempool_txsClient<mempool_txsGetPayload<T>>

    /**
     * Delete zero or more Mempool_txs.
     * @param {mempool_txsDeleteManyArgs} args - Arguments to filter Mempool_txs to delete.
     * @example
     * // Delete a few Mempool_txs
     * const { count } = await prisma.mempool_txs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends mempool_txsDeleteManyArgs>(
      args?: SelectSubset<T, mempool_txsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mempool_txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mempool_txsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mempool_txs
     * const mempool_txs = await prisma.mempool_txs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends mempool_txsUpdateManyArgs>(
      args: SelectSubset<T, mempool_txsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Mempool_txs.
     * @param {mempool_txsUpsertArgs} args - Arguments to update or create a Mempool_txs.
     * @example
     * // Update or create a Mempool_txs
     * const mempool_txs = await prisma.mempool_txs.upsert({
     *   create: {
     *     // ... data to create a Mempool_txs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mempool_txs we want to update
     *   }
     * })
    **/
    upsert<T extends mempool_txsUpsertArgs>(
      args: SelectSubset<T, mempool_txsUpsertArgs>
    ): Prisma__mempool_txsClient<mempool_txsGetPayload<T>>

    /**
     * Count the number of Mempool_txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mempool_txsCountArgs} args - Arguments to filter Mempool_txs to count.
     * @example
     * // Count the number of Mempool_txs
     * const count = await prisma.mempool_txs.count({
     *   where: {
     *     // ... the filter for the Mempool_txs we want to count
     *   }
     * })
    **/
    count<T extends mempool_txsCountArgs>(
      args?: Subset<T, mempool_txsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mempool_txsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mempool_txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mempool_txsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mempool_txsAggregateArgs>(args: Subset<T, Mempool_txsAggregateArgs>): PrismaPromise<GetMempool_txsAggregateType<T>>

    /**
     * Group by Mempool_txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mempool_txsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Mempool_txsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Mempool_txsGroupByArgs['orderBy'] }
        : { orderBy?: Mempool_txsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Mempool_txsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMempool_txsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for mempool_txs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__mempool_txsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * mempool_txs base type for findUnique actions
   */
  export type mempool_txsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the mempool_txs
     * 
    **/
    select?: mempool_txsSelect | null
    /**
     * Filter, which mempool_txs to fetch.
     * 
    **/
    where: mempool_txsWhereUniqueInput
  }

  /**
   * mempool_txs: findUnique
   */
  export interface mempool_txsFindUniqueArgs extends mempool_txsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mempool_txs findUniqueOrThrow
   */
  export type mempool_txsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the mempool_txs
     * 
    **/
    select?: mempool_txsSelect | null
    /**
     * Filter, which mempool_txs to fetch.
     * 
    **/
    where: mempool_txsWhereUniqueInput
  }


  /**
   * mempool_txs base type for findFirst actions
   */
  export type mempool_txsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the mempool_txs
     * 
    **/
    select?: mempool_txsSelect | null
    /**
     * Filter, which mempool_txs to fetch.
     * 
    **/
    where?: mempool_txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mempool_txs to fetch.
     * 
    **/
    orderBy?: Enumerable<mempool_txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mempool_txs.
     * 
    **/
    cursor?: mempool_txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mempool_txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mempool_txs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mempool_txs.
     * 
    **/
    distinct?: Enumerable<Mempool_txsScalarFieldEnum>
  }

  /**
   * mempool_txs: findFirst
   */
  export interface mempool_txsFindFirstArgs extends mempool_txsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * mempool_txs findFirstOrThrow
   */
  export type mempool_txsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the mempool_txs
     * 
    **/
    select?: mempool_txsSelect | null
    /**
     * Filter, which mempool_txs to fetch.
     * 
    **/
    where?: mempool_txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mempool_txs to fetch.
     * 
    **/
    orderBy?: Enumerable<mempool_txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mempool_txs.
     * 
    **/
    cursor?: mempool_txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mempool_txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mempool_txs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mempool_txs.
     * 
    **/
    distinct?: Enumerable<Mempool_txsScalarFieldEnum>
  }


  /**
   * mempool_txs findMany
   */
  export type mempool_txsFindManyArgs = {
    /**
     * Select specific fields to fetch from the mempool_txs
     * 
    **/
    select?: mempool_txsSelect | null
    /**
     * Filter, which mempool_txs to fetch.
     * 
    **/
    where?: mempool_txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mempool_txs to fetch.
     * 
    **/
    orderBy?: Enumerable<mempool_txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mempool_txs.
     * 
    **/
    cursor?: mempool_txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mempool_txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mempool_txs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Mempool_txsScalarFieldEnum>
  }


  /**
   * mempool_txs create
   */
  export type mempool_txsCreateArgs = {
    /**
     * Select specific fields to fetch from the mempool_txs
     * 
    **/
    select?: mempool_txsSelect | null
    /**
     * The data needed to create a mempool_txs.
     * 
    **/
    data: XOR<mempool_txsCreateInput, mempool_txsUncheckedCreateInput>
  }


  /**
   * mempool_txs createMany
   */
  export type mempool_txsCreateManyArgs = {
    /**
     * The data used to create many mempool_txs.
     * 
    **/
    data: Enumerable<mempool_txsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * mempool_txs update
   */
  export type mempool_txsUpdateArgs = {
    /**
     * Select specific fields to fetch from the mempool_txs
     * 
    **/
    select?: mempool_txsSelect | null
    /**
     * The data needed to update a mempool_txs.
     * 
    **/
    data: XOR<mempool_txsUpdateInput, mempool_txsUncheckedUpdateInput>
    /**
     * Choose, which mempool_txs to update.
     * 
    **/
    where: mempool_txsWhereUniqueInput
  }


  /**
   * mempool_txs updateMany
   */
  export type mempool_txsUpdateManyArgs = {
    /**
     * The data used to update mempool_txs.
     * 
    **/
    data: XOR<mempool_txsUpdateManyMutationInput, mempool_txsUncheckedUpdateManyInput>
    /**
     * Filter which mempool_txs to update
     * 
    **/
    where?: mempool_txsWhereInput
  }


  /**
   * mempool_txs upsert
   */
  export type mempool_txsUpsertArgs = {
    /**
     * Select specific fields to fetch from the mempool_txs
     * 
    **/
    select?: mempool_txsSelect | null
    /**
     * The filter to search for the mempool_txs to update in case it exists.
     * 
    **/
    where: mempool_txsWhereUniqueInput
    /**
     * In case the mempool_txs found by the `where` argument doesn't exist, create a new mempool_txs with this data.
     * 
    **/
    create: XOR<mempool_txsCreateInput, mempool_txsUncheckedCreateInput>
    /**
     * In case the mempool_txs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<mempool_txsUpdateInput, mempool_txsUncheckedUpdateInput>
  }


  /**
   * mempool_txs delete
   */
  export type mempool_txsDeleteArgs = {
    /**
     * Select specific fields to fetch from the mempool_txs
     * 
    **/
    select?: mempool_txsSelect | null
    /**
     * Filter which mempool_txs to delete.
     * 
    **/
    where: mempool_txsWhereUniqueInput
  }


  /**
   * mempool_txs deleteMany
   */
  export type mempool_txsDeleteManyArgs = {
    /**
     * Filter which mempool_txs to delete
     * 
    **/
    where?: mempool_txsWhereInput
  }


  /**
   * mempool_txs without action
   */
  export type mempool_txsArgs = {
    /**
     * Select specific fields to fetch from the mempool_txs
     * 
    **/
    select?: mempool_txsSelect | null
  }



  /**
   * Model microblocks
   */


  export type AggregateMicroblocks = {
    _count: MicroblocksCountAggregateOutputType | null
    _avg: MicroblocksAvgAggregateOutputType | null
    _sum: MicroblocksSumAggregateOutputType | null
    _min: MicroblocksMinAggregateOutputType | null
    _max: MicroblocksMaxAggregateOutputType | null
  }

  export type MicroblocksAvgAggregateOutputType = {
    id: number | null
    microblock_sequence: number | null
    block_height: number | null
    parent_block_height: number | null
    parent_burn_block_height: number | null
    parent_burn_block_time: number | null
  }

  export type MicroblocksSumAggregateOutputType = {
    id: bigint | null
    microblock_sequence: number | null
    block_height: number | null
    parent_block_height: number | null
    parent_burn_block_height: number | null
    parent_burn_block_time: number | null
  }

  export type MicroblocksMinAggregateOutputType = {
    id: bigint | null
    receive_timestamp: Date | null
    canonical: boolean | null
    microblock_canonical: boolean | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_parent_hash: Buffer | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    block_height: number | null
    parent_block_height: number | null
    parent_block_hash: Buffer | null
    parent_burn_block_height: number | null
    parent_burn_block_time: number | null
    parent_burn_block_hash: Buffer | null
    block_hash: Buffer | null
  }

  export type MicroblocksMaxAggregateOutputType = {
    id: bigint | null
    receive_timestamp: Date | null
    canonical: boolean | null
    microblock_canonical: boolean | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_parent_hash: Buffer | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    block_height: number | null
    parent_block_height: number | null
    parent_block_hash: Buffer | null
    parent_burn_block_height: number | null
    parent_burn_block_time: number | null
    parent_burn_block_hash: Buffer | null
    block_hash: Buffer | null
  }

  export type MicroblocksCountAggregateOutputType = {
    id: number
    receive_timestamp: number
    canonical: number
    microblock_canonical: number
    microblock_hash: number
    microblock_sequence: number
    microblock_parent_hash: number
    index_block_hash: number
    parent_index_block_hash: number
    block_height: number
    parent_block_height: number
    parent_block_hash: number
    parent_burn_block_height: number
    parent_burn_block_time: number
    parent_burn_block_hash: number
    block_hash: number
    _all: number
  }


  export type MicroblocksAvgAggregateInputType = {
    id?: true
    microblock_sequence?: true
    block_height?: true
    parent_block_height?: true
    parent_burn_block_height?: true
    parent_burn_block_time?: true
  }

  export type MicroblocksSumAggregateInputType = {
    id?: true
    microblock_sequence?: true
    block_height?: true
    parent_block_height?: true
    parent_burn_block_height?: true
    parent_burn_block_time?: true
  }

  export type MicroblocksMinAggregateInputType = {
    id?: true
    receive_timestamp?: true
    canonical?: true
    microblock_canonical?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_parent_hash?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    block_height?: true
    parent_block_height?: true
    parent_block_hash?: true
    parent_burn_block_height?: true
    parent_burn_block_time?: true
    parent_burn_block_hash?: true
    block_hash?: true
  }

  export type MicroblocksMaxAggregateInputType = {
    id?: true
    receive_timestamp?: true
    canonical?: true
    microblock_canonical?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_parent_hash?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    block_height?: true
    parent_block_height?: true
    parent_block_hash?: true
    parent_burn_block_height?: true
    parent_burn_block_time?: true
    parent_burn_block_hash?: true
    block_hash?: true
  }

  export type MicroblocksCountAggregateInputType = {
    id?: true
    receive_timestamp?: true
    canonical?: true
    microblock_canonical?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_parent_hash?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    block_height?: true
    parent_block_height?: true
    parent_block_hash?: true
    parent_burn_block_height?: true
    parent_burn_block_time?: true
    parent_burn_block_hash?: true
    block_hash?: true
    _all?: true
  }

  export type MicroblocksAggregateArgs = {
    /**
     * Filter which microblocks to aggregate.
     * 
    **/
    where?: microblocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of microblocks to fetch.
     * 
    **/
    orderBy?: Enumerable<microblocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: microblocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` microblocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` microblocks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned microblocks
    **/
    _count?: true | MicroblocksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MicroblocksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MicroblocksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MicroblocksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MicroblocksMaxAggregateInputType
  }

  export type GetMicroblocksAggregateType<T extends MicroblocksAggregateArgs> = {
        [P in keyof T & keyof AggregateMicroblocks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMicroblocks[P]>
      : GetScalarType<T[P], AggregateMicroblocks[P]>
  }




  export type MicroblocksGroupByArgs = {
    where?: microblocksWhereInput
    orderBy?: Enumerable<microblocksOrderByWithAggregationInput>
    by: Array<MicroblocksScalarFieldEnum>
    having?: microblocksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MicroblocksCountAggregateInputType | true
    _avg?: MicroblocksAvgAggregateInputType
    _sum?: MicroblocksSumAggregateInputType
    _min?: MicroblocksMinAggregateInputType
    _max?: MicroblocksMaxAggregateInputType
  }


  export type MicroblocksGroupByOutputType = {
    id: bigint
    receive_timestamp: Date
    canonical: boolean
    microblock_canonical: boolean
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_parent_hash: Buffer
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    block_height: number
    parent_block_height: number
    parent_block_hash: Buffer
    parent_burn_block_height: number
    parent_burn_block_time: number
    parent_burn_block_hash: Buffer
    block_hash: Buffer
    _count: MicroblocksCountAggregateOutputType | null
    _avg: MicroblocksAvgAggregateOutputType | null
    _sum: MicroblocksSumAggregateOutputType | null
    _min: MicroblocksMinAggregateOutputType | null
    _max: MicroblocksMaxAggregateOutputType | null
  }

  type GetMicroblocksGroupByPayload<T extends MicroblocksGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MicroblocksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MicroblocksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MicroblocksGroupByOutputType[P]>
            : GetScalarType<T[P], MicroblocksGroupByOutputType[P]>
        }
      >
    >


  export type microblocksSelect = {
    id?: boolean
    receive_timestamp?: boolean
    canonical?: boolean
    microblock_canonical?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_parent_hash?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    block_height?: boolean
    parent_block_height?: boolean
    parent_block_hash?: boolean
    parent_burn_block_height?: boolean
    parent_burn_block_time?: boolean
    parent_burn_block_hash?: boolean
    block_hash?: boolean
  }


  export type microblocksGetPayload<S extends boolean | null | undefined | microblocksArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? microblocks :
    S extends undefined ? never :
    S extends { include: any } & (microblocksArgs | microblocksFindManyArgs)
    ? microblocks 
    : S extends { select: any } & (microblocksArgs | microblocksFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof microblocks ? microblocks[P] : never
  } 
      : microblocks


  type microblocksCountArgs = Merge<
    Omit<microblocksFindManyArgs, 'select' | 'include'> & {
      select?: MicroblocksCountAggregateInputType | true
    }
  >

  export interface microblocksDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Microblocks that matches the filter.
     * @param {microblocksFindUniqueArgs} args - Arguments to find a Microblocks
     * @example
     * // Get one Microblocks
     * const microblocks = await prisma.microblocks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends microblocksFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, microblocksFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'microblocks'> extends True ? Prisma__microblocksClient<microblocksGetPayload<T>> : Prisma__microblocksClient<microblocksGetPayload<T> | null, null>

    /**
     * Find one Microblocks that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {microblocksFindUniqueOrThrowArgs} args - Arguments to find a Microblocks
     * @example
     * // Get one Microblocks
     * const microblocks = await prisma.microblocks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends microblocksFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, microblocksFindUniqueOrThrowArgs>
    ): Prisma__microblocksClient<microblocksGetPayload<T>>

    /**
     * Find the first Microblocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microblocksFindFirstArgs} args - Arguments to find a Microblocks
     * @example
     * // Get one Microblocks
     * const microblocks = await prisma.microblocks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends microblocksFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, microblocksFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'microblocks'> extends True ? Prisma__microblocksClient<microblocksGetPayload<T>> : Prisma__microblocksClient<microblocksGetPayload<T> | null, null>

    /**
     * Find the first Microblocks that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microblocksFindFirstOrThrowArgs} args - Arguments to find a Microblocks
     * @example
     * // Get one Microblocks
     * const microblocks = await prisma.microblocks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends microblocksFindFirstOrThrowArgs>(
      args?: SelectSubset<T, microblocksFindFirstOrThrowArgs>
    ): Prisma__microblocksClient<microblocksGetPayload<T>>

    /**
     * Find zero or more Microblocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microblocksFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Microblocks
     * const microblocks = await prisma.microblocks.findMany()
     * 
     * // Get first 10 Microblocks
     * const microblocks = await prisma.microblocks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const microblocksWithIdOnly = await prisma.microblocks.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends microblocksFindManyArgs>(
      args?: SelectSubset<T, microblocksFindManyArgs>
    ): PrismaPromise<Array<microblocksGetPayload<T>>>

    /**
     * Create a Microblocks.
     * @param {microblocksCreateArgs} args - Arguments to create a Microblocks.
     * @example
     * // Create one Microblocks
     * const Microblocks = await prisma.microblocks.create({
     *   data: {
     *     // ... data to create a Microblocks
     *   }
     * })
     * 
    **/
    create<T extends microblocksCreateArgs>(
      args: SelectSubset<T, microblocksCreateArgs>
    ): Prisma__microblocksClient<microblocksGetPayload<T>>

    /**
     * Create many Microblocks.
     *     @param {microblocksCreateManyArgs} args - Arguments to create many Microblocks.
     *     @example
     *     // Create many Microblocks
     *     const microblocks = await prisma.microblocks.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends microblocksCreateManyArgs>(
      args?: SelectSubset<T, microblocksCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Microblocks.
     * @param {microblocksDeleteArgs} args - Arguments to delete one Microblocks.
     * @example
     * // Delete one Microblocks
     * const Microblocks = await prisma.microblocks.delete({
     *   where: {
     *     // ... filter to delete one Microblocks
     *   }
     * })
     * 
    **/
    delete<T extends microblocksDeleteArgs>(
      args: SelectSubset<T, microblocksDeleteArgs>
    ): Prisma__microblocksClient<microblocksGetPayload<T>>

    /**
     * Update one Microblocks.
     * @param {microblocksUpdateArgs} args - Arguments to update one Microblocks.
     * @example
     * // Update one Microblocks
     * const microblocks = await prisma.microblocks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends microblocksUpdateArgs>(
      args: SelectSubset<T, microblocksUpdateArgs>
    ): Prisma__microblocksClient<microblocksGetPayload<T>>

    /**
     * Delete zero or more Microblocks.
     * @param {microblocksDeleteManyArgs} args - Arguments to filter Microblocks to delete.
     * @example
     * // Delete a few Microblocks
     * const { count } = await prisma.microblocks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends microblocksDeleteManyArgs>(
      args?: SelectSubset<T, microblocksDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Microblocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microblocksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Microblocks
     * const microblocks = await prisma.microblocks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends microblocksUpdateManyArgs>(
      args: SelectSubset<T, microblocksUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Microblocks.
     * @param {microblocksUpsertArgs} args - Arguments to update or create a Microblocks.
     * @example
     * // Update or create a Microblocks
     * const microblocks = await prisma.microblocks.upsert({
     *   create: {
     *     // ... data to create a Microblocks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Microblocks we want to update
     *   }
     * })
    **/
    upsert<T extends microblocksUpsertArgs>(
      args: SelectSubset<T, microblocksUpsertArgs>
    ): Prisma__microblocksClient<microblocksGetPayload<T>>

    /**
     * Count the number of Microblocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microblocksCountArgs} args - Arguments to filter Microblocks to count.
     * @example
     * // Count the number of Microblocks
     * const count = await prisma.microblocks.count({
     *   where: {
     *     // ... the filter for the Microblocks we want to count
     *   }
     * })
    **/
    count<T extends microblocksCountArgs>(
      args?: Subset<T, microblocksCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MicroblocksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Microblocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MicroblocksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MicroblocksAggregateArgs>(args: Subset<T, MicroblocksAggregateArgs>): PrismaPromise<GetMicroblocksAggregateType<T>>

    /**
     * Group by Microblocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MicroblocksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MicroblocksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MicroblocksGroupByArgs['orderBy'] }
        : { orderBy?: MicroblocksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MicroblocksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMicroblocksGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for microblocks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__microblocksClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * microblocks base type for findUnique actions
   */
  export type microblocksFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the microblocks
     * 
    **/
    select?: microblocksSelect | null
    /**
     * Filter, which microblocks to fetch.
     * 
    **/
    where: microblocksWhereUniqueInput
  }

  /**
   * microblocks: findUnique
   */
  export interface microblocksFindUniqueArgs extends microblocksFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * microblocks findUniqueOrThrow
   */
  export type microblocksFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the microblocks
     * 
    **/
    select?: microblocksSelect | null
    /**
     * Filter, which microblocks to fetch.
     * 
    **/
    where: microblocksWhereUniqueInput
  }


  /**
   * microblocks base type for findFirst actions
   */
  export type microblocksFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the microblocks
     * 
    **/
    select?: microblocksSelect | null
    /**
     * Filter, which microblocks to fetch.
     * 
    **/
    where?: microblocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of microblocks to fetch.
     * 
    **/
    orderBy?: Enumerable<microblocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for microblocks.
     * 
    **/
    cursor?: microblocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` microblocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` microblocks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of microblocks.
     * 
    **/
    distinct?: Enumerable<MicroblocksScalarFieldEnum>
  }

  /**
   * microblocks: findFirst
   */
  export interface microblocksFindFirstArgs extends microblocksFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * microblocks findFirstOrThrow
   */
  export type microblocksFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the microblocks
     * 
    **/
    select?: microblocksSelect | null
    /**
     * Filter, which microblocks to fetch.
     * 
    **/
    where?: microblocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of microblocks to fetch.
     * 
    **/
    orderBy?: Enumerable<microblocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for microblocks.
     * 
    **/
    cursor?: microblocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` microblocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` microblocks.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of microblocks.
     * 
    **/
    distinct?: Enumerable<MicroblocksScalarFieldEnum>
  }


  /**
   * microblocks findMany
   */
  export type microblocksFindManyArgs = {
    /**
     * Select specific fields to fetch from the microblocks
     * 
    **/
    select?: microblocksSelect | null
    /**
     * Filter, which microblocks to fetch.
     * 
    **/
    where?: microblocksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of microblocks to fetch.
     * 
    **/
    orderBy?: Enumerable<microblocksOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing microblocks.
     * 
    **/
    cursor?: microblocksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` microblocks from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` microblocks.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MicroblocksScalarFieldEnum>
  }


  /**
   * microblocks create
   */
  export type microblocksCreateArgs = {
    /**
     * Select specific fields to fetch from the microblocks
     * 
    **/
    select?: microblocksSelect | null
    /**
     * The data needed to create a microblocks.
     * 
    **/
    data: XOR<microblocksCreateInput, microblocksUncheckedCreateInput>
  }


  /**
   * microblocks createMany
   */
  export type microblocksCreateManyArgs = {
    /**
     * The data used to create many microblocks.
     * 
    **/
    data: Enumerable<microblocksCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * microblocks update
   */
  export type microblocksUpdateArgs = {
    /**
     * Select specific fields to fetch from the microblocks
     * 
    **/
    select?: microblocksSelect | null
    /**
     * The data needed to update a microblocks.
     * 
    **/
    data: XOR<microblocksUpdateInput, microblocksUncheckedUpdateInput>
    /**
     * Choose, which microblocks to update.
     * 
    **/
    where: microblocksWhereUniqueInput
  }


  /**
   * microblocks updateMany
   */
  export type microblocksUpdateManyArgs = {
    /**
     * The data used to update microblocks.
     * 
    **/
    data: XOR<microblocksUpdateManyMutationInput, microblocksUncheckedUpdateManyInput>
    /**
     * Filter which microblocks to update
     * 
    **/
    where?: microblocksWhereInput
  }


  /**
   * microblocks upsert
   */
  export type microblocksUpsertArgs = {
    /**
     * Select specific fields to fetch from the microblocks
     * 
    **/
    select?: microblocksSelect | null
    /**
     * The filter to search for the microblocks to update in case it exists.
     * 
    **/
    where: microblocksWhereUniqueInput
    /**
     * In case the microblocks found by the `where` argument doesn't exist, create a new microblocks with this data.
     * 
    **/
    create: XOR<microblocksCreateInput, microblocksUncheckedCreateInput>
    /**
     * In case the microblocks was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<microblocksUpdateInput, microblocksUncheckedUpdateInput>
  }


  /**
   * microblocks delete
   */
  export type microblocksDeleteArgs = {
    /**
     * Select specific fields to fetch from the microblocks
     * 
    **/
    select?: microblocksSelect | null
    /**
     * Filter which microblocks to delete.
     * 
    **/
    where: microblocksWhereUniqueInput
  }


  /**
   * microblocks deleteMany
   */
  export type microblocksDeleteManyArgs = {
    /**
     * Filter which microblocks to delete
     * 
    **/
    where?: microblocksWhereInput
  }


  /**
   * microblocks without action
   */
  export type microblocksArgs = {
    /**
     * Select specific fields to fetch from the microblocks
     * 
    **/
    select?: microblocksSelect | null
  }



  /**
   * Model miner_rewards
   */


  export type AggregateMiner_rewards = {
    _count: Miner_rewardsCountAggregateOutputType | null
    _avg: Miner_rewardsAvgAggregateOutputType | null
    _sum: Miner_rewardsSumAggregateOutputType | null
    _min: Miner_rewardsMinAggregateOutputType | null
    _max: Miner_rewardsMaxAggregateOutputType | null
  }

  export type Miner_rewardsAvgAggregateOutputType = {
    id: number | null
    mature_block_height: number | null
    coinbase_amount: Decimal | null
    tx_fees_anchored: Decimal | null
    tx_fees_streamed_confirmed: Decimal | null
    tx_fees_streamed_produced: Decimal | null
  }

  export type Miner_rewardsSumAggregateOutputType = {
    id: number | null
    mature_block_height: number | null
    coinbase_amount: Decimal | null
    tx_fees_anchored: Decimal | null
    tx_fees_streamed_confirmed: Decimal | null
    tx_fees_streamed_produced: Decimal | null
  }

  export type Miner_rewardsMinAggregateOutputType = {
    id: number | null
    block_hash: Buffer | null
    index_block_hash: Buffer | null
    from_index_block_hash: Buffer | null
    mature_block_height: number | null
    canonical: boolean | null
    recipient: string | null
    miner_address: string | null
    coinbase_amount: Decimal | null
    tx_fees_anchored: Decimal | null
    tx_fees_streamed_confirmed: Decimal | null
    tx_fees_streamed_produced: Decimal | null
  }

  export type Miner_rewardsMaxAggregateOutputType = {
    id: number | null
    block_hash: Buffer | null
    index_block_hash: Buffer | null
    from_index_block_hash: Buffer | null
    mature_block_height: number | null
    canonical: boolean | null
    recipient: string | null
    miner_address: string | null
    coinbase_amount: Decimal | null
    tx_fees_anchored: Decimal | null
    tx_fees_streamed_confirmed: Decimal | null
    tx_fees_streamed_produced: Decimal | null
  }

  export type Miner_rewardsCountAggregateOutputType = {
    id: number
    block_hash: number
    index_block_hash: number
    from_index_block_hash: number
    mature_block_height: number
    canonical: number
    recipient: number
    miner_address: number
    coinbase_amount: number
    tx_fees_anchored: number
    tx_fees_streamed_confirmed: number
    tx_fees_streamed_produced: number
    _all: number
  }


  export type Miner_rewardsAvgAggregateInputType = {
    id?: true
    mature_block_height?: true
    coinbase_amount?: true
    tx_fees_anchored?: true
    tx_fees_streamed_confirmed?: true
    tx_fees_streamed_produced?: true
  }

  export type Miner_rewardsSumAggregateInputType = {
    id?: true
    mature_block_height?: true
    coinbase_amount?: true
    tx_fees_anchored?: true
    tx_fees_streamed_confirmed?: true
    tx_fees_streamed_produced?: true
  }

  export type Miner_rewardsMinAggregateInputType = {
    id?: true
    block_hash?: true
    index_block_hash?: true
    from_index_block_hash?: true
    mature_block_height?: true
    canonical?: true
    recipient?: true
    miner_address?: true
    coinbase_amount?: true
    tx_fees_anchored?: true
    tx_fees_streamed_confirmed?: true
    tx_fees_streamed_produced?: true
  }

  export type Miner_rewardsMaxAggregateInputType = {
    id?: true
    block_hash?: true
    index_block_hash?: true
    from_index_block_hash?: true
    mature_block_height?: true
    canonical?: true
    recipient?: true
    miner_address?: true
    coinbase_amount?: true
    tx_fees_anchored?: true
    tx_fees_streamed_confirmed?: true
    tx_fees_streamed_produced?: true
  }

  export type Miner_rewardsCountAggregateInputType = {
    id?: true
    block_hash?: true
    index_block_hash?: true
    from_index_block_hash?: true
    mature_block_height?: true
    canonical?: true
    recipient?: true
    miner_address?: true
    coinbase_amount?: true
    tx_fees_anchored?: true
    tx_fees_streamed_confirmed?: true
    tx_fees_streamed_produced?: true
    _all?: true
  }

  export type Miner_rewardsAggregateArgs = {
    /**
     * Filter which miner_rewards to aggregate.
     * 
    **/
    where?: miner_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miner_rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<miner_rewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: miner_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miner_rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miner_rewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned miner_rewards
    **/
    _count?: true | Miner_rewardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Miner_rewardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Miner_rewardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Miner_rewardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Miner_rewardsMaxAggregateInputType
  }

  export type GetMiner_rewardsAggregateType<T extends Miner_rewardsAggregateArgs> = {
        [P in keyof T & keyof AggregateMiner_rewards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMiner_rewards[P]>
      : GetScalarType<T[P], AggregateMiner_rewards[P]>
  }




  export type Miner_rewardsGroupByArgs = {
    where?: miner_rewardsWhereInput
    orderBy?: Enumerable<miner_rewardsOrderByWithAggregationInput>
    by: Array<Miner_rewardsScalarFieldEnum>
    having?: miner_rewardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Miner_rewardsCountAggregateInputType | true
    _avg?: Miner_rewardsAvgAggregateInputType
    _sum?: Miner_rewardsSumAggregateInputType
    _min?: Miner_rewardsMinAggregateInputType
    _max?: Miner_rewardsMaxAggregateInputType
  }


  export type Miner_rewardsGroupByOutputType = {
    id: number
    block_hash: Buffer
    index_block_hash: Buffer
    from_index_block_hash: Buffer
    mature_block_height: number
    canonical: boolean
    recipient: string
    miner_address: string | null
    coinbase_amount: Decimal
    tx_fees_anchored: Decimal
    tx_fees_streamed_confirmed: Decimal
    tx_fees_streamed_produced: Decimal
    _count: Miner_rewardsCountAggregateOutputType | null
    _avg: Miner_rewardsAvgAggregateOutputType | null
    _sum: Miner_rewardsSumAggregateOutputType | null
    _min: Miner_rewardsMinAggregateOutputType | null
    _max: Miner_rewardsMaxAggregateOutputType | null
  }

  type GetMiner_rewardsGroupByPayload<T extends Miner_rewardsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Miner_rewardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Miner_rewardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Miner_rewardsGroupByOutputType[P]>
            : GetScalarType<T[P], Miner_rewardsGroupByOutputType[P]>
        }
      >
    >


  export type miner_rewardsSelect = {
    id?: boolean
    block_hash?: boolean
    index_block_hash?: boolean
    from_index_block_hash?: boolean
    mature_block_height?: boolean
    canonical?: boolean
    recipient?: boolean
    miner_address?: boolean
    coinbase_amount?: boolean
    tx_fees_anchored?: boolean
    tx_fees_streamed_confirmed?: boolean
    tx_fees_streamed_produced?: boolean
  }


  export type miner_rewardsGetPayload<S extends boolean | null | undefined | miner_rewardsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? miner_rewards :
    S extends undefined ? never :
    S extends { include: any } & (miner_rewardsArgs | miner_rewardsFindManyArgs)
    ? miner_rewards 
    : S extends { select: any } & (miner_rewardsArgs | miner_rewardsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof miner_rewards ? miner_rewards[P] : never
  } 
      : miner_rewards


  type miner_rewardsCountArgs = Merge<
    Omit<miner_rewardsFindManyArgs, 'select' | 'include'> & {
      select?: Miner_rewardsCountAggregateInputType | true
    }
  >

  export interface miner_rewardsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Miner_rewards that matches the filter.
     * @param {miner_rewardsFindUniqueArgs} args - Arguments to find a Miner_rewards
     * @example
     * // Get one Miner_rewards
     * const miner_rewards = await prisma.miner_rewards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends miner_rewardsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, miner_rewardsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'miner_rewards'> extends True ? Prisma__miner_rewardsClient<miner_rewardsGetPayload<T>> : Prisma__miner_rewardsClient<miner_rewardsGetPayload<T> | null, null>

    /**
     * Find one Miner_rewards that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {miner_rewardsFindUniqueOrThrowArgs} args - Arguments to find a Miner_rewards
     * @example
     * // Get one Miner_rewards
     * const miner_rewards = await prisma.miner_rewards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends miner_rewardsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, miner_rewardsFindUniqueOrThrowArgs>
    ): Prisma__miner_rewardsClient<miner_rewardsGetPayload<T>>

    /**
     * Find the first Miner_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miner_rewardsFindFirstArgs} args - Arguments to find a Miner_rewards
     * @example
     * // Get one Miner_rewards
     * const miner_rewards = await prisma.miner_rewards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends miner_rewardsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, miner_rewardsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'miner_rewards'> extends True ? Prisma__miner_rewardsClient<miner_rewardsGetPayload<T>> : Prisma__miner_rewardsClient<miner_rewardsGetPayload<T> | null, null>

    /**
     * Find the first Miner_rewards that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miner_rewardsFindFirstOrThrowArgs} args - Arguments to find a Miner_rewards
     * @example
     * // Get one Miner_rewards
     * const miner_rewards = await prisma.miner_rewards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends miner_rewardsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, miner_rewardsFindFirstOrThrowArgs>
    ): Prisma__miner_rewardsClient<miner_rewardsGetPayload<T>>

    /**
     * Find zero or more Miner_rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miner_rewardsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Miner_rewards
     * const miner_rewards = await prisma.miner_rewards.findMany()
     * 
     * // Get first 10 Miner_rewards
     * const miner_rewards = await prisma.miner_rewards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const miner_rewardsWithIdOnly = await prisma.miner_rewards.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends miner_rewardsFindManyArgs>(
      args?: SelectSubset<T, miner_rewardsFindManyArgs>
    ): PrismaPromise<Array<miner_rewardsGetPayload<T>>>

    /**
     * Create a Miner_rewards.
     * @param {miner_rewardsCreateArgs} args - Arguments to create a Miner_rewards.
     * @example
     * // Create one Miner_rewards
     * const Miner_rewards = await prisma.miner_rewards.create({
     *   data: {
     *     // ... data to create a Miner_rewards
     *   }
     * })
     * 
    **/
    create<T extends miner_rewardsCreateArgs>(
      args: SelectSubset<T, miner_rewardsCreateArgs>
    ): Prisma__miner_rewardsClient<miner_rewardsGetPayload<T>>

    /**
     * Create many Miner_rewards.
     *     @param {miner_rewardsCreateManyArgs} args - Arguments to create many Miner_rewards.
     *     @example
     *     // Create many Miner_rewards
     *     const miner_rewards = await prisma.miner_rewards.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends miner_rewardsCreateManyArgs>(
      args?: SelectSubset<T, miner_rewardsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Miner_rewards.
     * @param {miner_rewardsDeleteArgs} args - Arguments to delete one Miner_rewards.
     * @example
     * // Delete one Miner_rewards
     * const Miner_rewards = await prisma.miner_rewards.delete({
     *   where: {
     *     // ... filter to delete one Miner_rewards
     *   }
     * })
     * 
    **/
    delete<T extends miner_rewardsDeleteArgs>(
      args: SelectSubset<T, miner_rewardsDeleteArgs>
    ): Prisma__miner_rewardsClient<miner_rewardsGetPayload<T>>

    /**
     * Update one Miner_rewards.
     * @param {miner_rewardsUpdateArgs} args - Arguments to update one Miner_rewards.
     * @example
     * // Update one Miner_rewards
     * const miner_rewards = await prisma.miner_rewards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends miner_rewardsUpdateArgs>(
      args: SelectSubset<T, miner_rewardsUpdateArgs>
    ): Prisma__miner_rewardsClient<miner_rewardsGetPayload<T>>

    /**
     * Delete zero or more Miner_rewards.
     * @param {miner_rewardsDeleteManyArgs} args - Arguments to filter Miner_rewards to delete.
     * @example
     * // Delete a few Miner_rewards
     * const { count } = await prisma.miner_rewards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends miner_rewardsDeleteManyArgs>(
      args?: SelectSubset<T, miner_rewardsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Miner_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miner_rewardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Miner_rewards
     * const miner_rewards = await prisma.miner_rewards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends miner_rewardsUpdateManyArgs>(
      args: SelectSubset<T, miner_rewardsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Miner_rewards.
     * @param {miner_rewardsUpsertArgs} args - Arguments to update or create a Miner_rewards.
     * @example
     * // Update or create a Miner_rewards
     * const miner_rewards = await prisma.miner_rewards.upsert({
     *   create: {
     *     // ... data to create a Miner_rewards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Miner_rewards we want to update
     *   }
     * })
    **/
    upsert<T extends miner_rewardsUpsertArgs>(
      args: SelectSubset<T, miner_rewardsUpsertArgs>
    ): Prisma__miner_rewardsClient<miner_rewardsGetPayload<T>>

    /**
     * Count the number of Miner_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {miner_rewardsCountArgs} args - Arguments to filter Miner_rewards to count.
     * @example
     * // Count the number of Miner_rewards
     * const count = await prisma.miner_rewards.count({
     *   where: {
     *     // ... the filter for the Miner_rewards we want to count
     *   }
     * })
    **/
    count<T extends miner_rewardsCountArgs>(
      args?: Subset<T, miner_rewardsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Miner_rewardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Miner_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Miner_rewardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Miner_rewardsAggregateArgs>(args: Subset<T, Miner_rewardsAggregateArgs>): PrismaPromise<GetMiner_rewardsAggregateType<T>>

    /**
     * Group by Miner_rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Miner_rewardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Miner_rewardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Miner_rewardsGroupByArgs['orderBy'] }
        : { orderBy?: Miner_rewardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Miner_rewardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMiner_rewardsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for miner_rewards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__miner_rewardsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * miner_rewards base type for findUnique actions
   */
  export type miner_rewardsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the miner_rewards
     * 
    **/
    select?: miner_rewardsSelect | null
    /**
     * Filter, which miner_rewards to fetch.
     * 
    **/
    where: miner_rewardsWhereUniqueInput
  }

  /**
   * miner_rewards: findUnique
   */
  export interface miner_rewardsFindUniqueArgs extends miner_rewardsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * miner_rewards findUniqueOrThrow
   */
  export type miner_rewardsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the miner_rewards
     * 
    **/
    select?: miner_rewardsSelect | null
    /**
     * Filter, which miner_rewards to fetch.
     * 
    **/
    where: miner_rewardsWhereUniqueInput
  }


  /**
   * miner_rewards base type for findFirst actions
   */
  export type miner_rewardsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the miner_rewards
     * 
    **/
    select?: miner_rewardsSelect | null
    /**
     * Filter, which miner_rewards to fetch.
     * 
    **/
    where?: miner_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miner_rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<miner_rewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for miner_rewards.
     * 
    **/
    cursor?: miner_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miner_rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miner_rewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of miner_rewards.
     * 
    **/
    distinct?: Enumerable<Miner_rewardsScalarFieldEnum>
  }

  /**
   * miner_rewards: findFirst
   */
  export interface miner_rewardsFindFirstArgs extends miner_rewardsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * miner_rewards findFirstOrThrow
   */
  export type miner_rewardsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the miner_rewards
     * 
    **/
    select?: miner_rewardsSelect | null
    /**
     * Filter, which miner_rewards to fetch.
     * 
    **/
    where?: miner_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miner_rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<miner_rewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for miner_rewards.
     * 
    **/
    cursor?: miner_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miner_rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miner_rewards.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of miner_rewards.
     * 
    **/
    distinct?: Enumerable<Miner_rewardsScalarFieldEnum>
  }


  /**
   * miner_rewards findMany
   */
  export type miner_rewardsFindManyArgs = {
    /**
     * Select specific fields to fetch from the miner_rewards
     * 
    **/
    select?: miner_rewardsSelect | null
    /**
     * Filter, which miner_rewards to fetch.
     * 
    **/
    where?: miner_rewardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of miner_rewards to fetch.
     * 
    **/
    orderBy?: Enumerable<miner_rewardsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing miner_rewards.
     * 
    **/
    cursor?: miner_rewardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` miner_rewards from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` miner_rewards.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Miner_rewardsScalarFieldEnum>
  }


  /**
   * miner_rewards create
   */
  export type miner_rewardsCreateArgs = {
    /**
     * Select specific fields to fetch from the miner_rewards
     * 
    **/
    select?: miner_rewardsSelect | null
    /**
     * The data needed to create a miner_rewards.
     * 
    **/
    data: XOR<miner_rewardsCreateInput, miner_rewardsUncheckedCreateInput>
  }


  /**
   * miner_rewards createMany
   */
  export type miner_rewardsCreateManyArgs = {
    /**
     * The data used to create many miner_rewards.
     * 
    **/
    data: Enumerable<miner_rewardsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * miner_rewards update
   */
  export type miner_rewardsUpdateArgs = {
    /**
     * Select specific fields to fetch from the miner_rewards
     * 
    **/
    select?: miner_rewardsSelect | null
    /**
     * The data needed to update a miner_rewards.
     * 
    **/
    data: XOR<miner_rewardsUpdateInput, miner_rewardsUncheckedUpdateInput>
    /**
     * Choose, which miner_rewards to update.
     * 
    **/
    where: miner_rewardsWhereUniqueInput
  }


  /**
   * miner_rewards updateMany
   */
  export type miner_rewardsUpdateManyArgs = {
    /**
     * The data used to update miner_rewards.
     * 
    **/
    data: XOR<miner_rewardsUpdateManyMutationInput, miner_rewardsUncheckedUpdateManyInput>
    /**
     * Filter which miner_rewards to update
     * 
    **/
    where?: miner_rewardsWhereInput
  }


  /**
   * miner_rewards upsert
   */
  export type miner_rewardsUpsertArgs = {
    /**
     * Select specific fields to fetch from the miner_rewards
     * 
    **/
    select?: miner_rewardsSelect | null
    /**
     * The filter to search for the miner_rewards to update in case it exists.
     * 
    **/
    where: miner_rewardsWhereUniqueInput
    /**
     * In case the miner_rewards found by the `where` argument doesn't exist, create a new miner_rewards with this data.
     * 
    **/
    create: XOR<miner_rewardsCreateInput, miner_rewardsUncheckedCreateInput>
    /**
     * In case the miner_rewards was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<miner_rewardsUpdateInput, miner_rewardsUncheckedUpdateInput>
  }


  /**
   * miner_rewards delete
   */
  export type miner_rewardsDeleteArgs = {
    /**
     * Select specific fields to fetch from the miner_rewards
     * 
    **/
    select?: miner_rewardsSelect | null
    /**
     * Filter which miner_rewards to delete.
     * 
    **/
    where: miner_rewardsWhereUniqueInput
  }


  /**
   * miner_rewards deleteMany
   */
  export type miner_rewardsDeleteManyArgs = {
    /**
     * Filter which miner_rewards to delete
     * 
    **/
    where?: miner_rewardsWhereInput
  }


  /**
   * miner_rewards without action
   */
  export type miner_rewardsArgs = {
    /**
     * Select specific fields to fetch from the miner_rewards
     * 
    **/
    select?: miner_rewardsSelect | null
  }



  /**
   * Model names
   */


  export type AggregateNames = {
    _count: NamesCountAggregateOutputType | null
    _avg: NamesAvgAggregateOutputType | null
    _sum: NamesSumAggregateOutputType | null
    _min: NamesMinAggregateOutputType | null
    _max: NamesMaxAggregateOutputType | null
  }

  export type NamesAvgAggregateOutputType = {
    id: number | null
    registered_at: number | null
    expire_block: number | null
    renewal_deadline: number | null
    tx_index: number | null
    event_index: number | null
    microblock_sequence: number | null
  }

  export type NamesSumAggregateOutputType = {
    id: number | null
    registered_at: number | null
    expire_block: number | null
    renewal_deadline: number | null
    tx_index: number | null
    event_index: number | null
    microblock_sequence: number | null
  }

  export type NamesMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    registered_at: number | null
    expire_block: number | null
    zonefile_hash: string | null
    namespace_id: string | null
    grace_period: string | null
    renewal_deadline: number | null
    resolver: string | null
    tx_id: Buffer | null
    tx_index: number | null
    event_index: number | null
    status: string | null
    canonical: boolean | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
  }

  export type NamesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    registered_at: number | null
    expire_block: number | null
    zonefile_hash: string | null
    namespace_id: string | null
    grace_period: string | null
    renewal_deadline: number | null
    resolver: string | null
    tx_id: Buffer | null
    tx_index: number | null
    event_index: number | null
    status: string | null
    canonical: boolean | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
  }

  export type NamesCountAggregateOutputType = {
    id: number
    name: number
    address: number
    registered_at: number
    expire_block: number
    zonefile_hash: number
    namespace_id: number
    grace_period: number
    renewal_deadline: number
    resolver: number
    tx_id: number
    tx_index: number
    event_index: number
    status: number
    canonical: number
    index_block_hash: number
    parent_index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    microblock_canonical: number
    _all: number
  }


  export type NamesAvgAggregateInputType = {
    id?: true
    registered_at?: true
    expire_block?: true
    renewal_deadline?: true
    tx_index?: true
    event_index?: true
    microblock_sequence?: true
  }

  export type NamesSumAggregateInputType = {
    id?: true
    registered_at?: true
    expire_block?: true
    renewal_deadline?: true
    tx_index?: true
    event_index?: true
    microblock_sequence?: true
  }

  export type NamesMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    registered_at?: true
    expire_block?: true
    zonefile_hash?: true
    namespace_id?: true
    grace_period?: true
    renewal_deadline?: true
    resolver?: true
    tx_id?: true
    tx_index?: true
    event_index?: true
    status?: true
    canonical?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
  }

  export type NamesMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    registered_at?: true
    expire_block?: true
    zonefile_hash?: true
    namespace_id?: true
    grace_period?: true
    renewal_deadline?: true
    resolver?: true
    tx_id?: true
    tx_index?: true
    event_index?: true
    status?: true
    canonical?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
  }

  export type NamesCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    registered_at?: true
    expire_block?: true
    zonefile_hash?: true
    namespace_id?: true
    grace_period?: true
    renewal_deadline?: true
    resolver?: true
    tx_id?: true
    tx_index?: true
    event_index?: true
    status?: true
    canonical?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    _all?: true
  }

  export type NamesAggregateArgs = {
    /**
     * Filter which names to aggregate.
     * 
    **/
    where?: namesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of names to fetch.
     * 
    **/
    orderBy?: Enumerable<namesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: namesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` names from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` names.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned names
    **/
    _count?: true | NamesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NamesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NamesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NamesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NamesMaxAggregateInputType
  }

  export type GetNamesAggregateType<T extends NamesAggregateArgs> = {
        [P in keyof T & keyof AggregateNames]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNames[P]>
      : GetScalarType<T[P], AggregateNames[P]>
  }




  export type NamesGroupByArgs = {
    where?: namesWhereInput
    orderBy?: Enumerable<namesOrderByWithAggregationInput>
    by: Array<NamesScalarFieldEnum>
    having?: namesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NamesCountAggregateInputType | true
    _avg?: NamesAvgAggregateInputType
    _sum?: NamesSumAggregateInputType
    _min?: NamesMinAggregateInputType
    _max?: NamesMaxAggregateInputType
  }


  export type NamesGroupByOutputType = {
    id: number
    name: string
    address: string
    registered_at: number
    expire_block: number
    zonefile_hash: string
    namespace_id: string
    grace_period: string | null
    renewal_deadline: number | null
    resolver: string | null
    tx_id: Buffer | null
    tx_index: number
    event_index: number | null
    status: string | null
    canonical: boolean
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    _count: NamesCountAggregateOutputType | null
    _avg: NamesAvgAggregateOutputType | null
    _sum: NamesSumAggregateOutputType | null
    _min: NamesMinAggregateOutputType | null
    _max: NamesMaxAggregateOutputType | null
  }

  type GetNamesGroupByPayload<T extends NamesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NamesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NamesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NamesGroupByOutputType[P]>
            : GetScalarType<T[P], NamesGroupByOutputType[P]>
        }
      >
    >


  export type namesSelect = {
    id?: boolean
    name?: boolean
    address?: boolean
    registered_at?: boolean
    expire_block?: boolean
    zonefile_hash?: boolean
    namespace_id?: boolean
    grace_period?: boolean
    renewal_deadline?: boolean
    resolver?: boolean
    tx_id?: boolean
    tx_index?: boolean
    event_index?: boolean
    status?: boolean
    canonical?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_canonical?: boolean
  }


  export type namesGetPayload<S extends boolean | null | undefined | namesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? names :
    S extends undefined ? never :
    S extends { include: any } & (namesArgs | namesFindManyArgs)
    ? names 
    : S extends { select: any } & (namesArgs | namesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof names ? names[P] : never
  } 
      : names


  type namesCountArgs = Merge<
    Omit<namesFindManyArgs, 'select' | 'include'> & {
      select?: NamesCountAggregateInputType | true
    }
  >

  export interface namesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Names that matches the filter.
     * @param {namesFindUniqueArgs} args - Arguments to find a Names
     * @example
     * // Get one Names
     * const names = await prisma.names.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends namesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, namesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'names'> extends True ? Prisma__namesClient<namesGetPayload<T>> : Prisma__namesClient<namesGetPayload<T> | null, null>

    /**
     * Find one Names that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {namesFindUniqueOrThrowArgs} args - Arguments to find a Names
     * @example
     * // Get one Names
     * const names = await prisma.names.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends namesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, namesFindUniqueOrThrowArgs>
    ): Prisma__namesClient<namesGetPayload<T>>

    /**
     * Find the first Names that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {namesFindFirstArgs} args - Arguments to find a Names
     * @example
     * // Get one Names
     * const names = await prisma.names.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends namesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, namesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'names'> extends True ? Prisma__namesClient<namesGetPayload<T>> : Prisma__namesClient<namesGetPayload<T> | null, null>

    /**
     * Find the first Names that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {namesFindFirstOrThrowArgs} args - Arguments to find a Names
     * @example
     * // Get one Names
     * const names = await prisma.names.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends namesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, namesFindFirstOrThrowArgs>
    ): Prisma__namesClient<namesGetPayload<T>>

    /**
     * Find zero or more Names that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {namesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Names
     * const names = await prisma.names.findMany()
     * 
     * // Get first 10 Names
     * const names = await prisma.names.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const namesWithIdOnly = await prisma.names.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends namesFindManyArgs>(
      args?: SelectSubset<T, namesFindManyArgs>
    ): PrismaPromise<Array<namesGetPayload<T>>>

    /**
     * Create a Names.
     * @param {namesCreateArgs} args - Arguments to create a Names.
     * @example
     * // Create one Names
     * const Names = await prisma.names.create({
     *   data: {
     *     // ... data to create a Names
     *   }
     * })
     * 
    **/
    create<T extends namesCreateArgs>(
      args: SelectSubset<T, namesCreateArgs>
    ): Prisma__namesClient<namesGetPayload<T>>

    /**
     * Create many Names.
     *     @param {namesCreateManyArgs} args - Arguments to create many Names.
     *     @example
     *     // Create many Names
     *     const names = await prisma.names.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends namesCreateManyArgs>(
      args?: SelectSubset<T, namesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Names.
     * @param {namesDeleteArgs} args - Arguments to delete one Names.
     * @example
     * // Delete one Names
     * const Names = await prisma.names.delete({
     *   where: {
     *     // ... filter to delete one Names
     *   }
     * })
     * 
    **/
    delete<T extends namesDeleteArgs>(
      args: SelectSubset<T, namesDeleteArgs>
    ): Prisma__namesClient<namesGetPayload<T>>

    /**
     * Update one Names.
     * @param {namesUpdateArgs} args - Arguments to update one Names.
     * @example
     * // Update one Names
     * const names = await prisma.names.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends namesUpdateArgs>(
      args: SelectSubset<T, namesUpdateArgs>
    ): Prisma__namesClient<namesGetPayload<T>>

    /**
     * Delete zero or more Names.
     * @param {namesDeleteManyArgs} args - Arguments to filter Names to delete.
     * @example
     * // Delete a few Names
     * const { count } = await prisma.names.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends namesDeleteManyArgs>(
      args?: SelectSubset<T, namesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Names.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {namesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Names
     * const names = await prisma.names.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends namesUpdateManyArgs>(
      args: SelectSubset<T, namesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Names.
     * @param {namesUpsertArgs} args - Arguments to update or create a Names.
     * @example
     * // Update or create a Names
     * const names = await prisma.names.upsert({
     *   create: {
     *     // ... data to create a Names
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Names we want to update
     *   }
     * })
    **/
    upsert<T extends namesUpsertArgs>(
      args: SelectSubset<T, namesUpsertArgs>
    ): Prisma__namesClient<namesGetPayload<T>>

    /**
     * Count the number of Names.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {namesCountArgs} args - Arguments to filter Names to count.
     * @example
     * // Count the number of Names
     * const count = await prisma.names.count({
     *   where: {
     *     // ... the filter for the Names we want to count
     *   }
     * })
    **/
    count<T extends namesCountArgs>(
      args?: Subset<T, namesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NamesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Names.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NamesAggregateArgs>(args: Subset<T, NamesAggregateArgs>): PrismaPromise<GetNamesAggregateType<T>>

    /**
     * Group by Names.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NamesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NamesGroupByArgs['orderBy'] }
        : { orderBy?: NamesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NamesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNamesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for names.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__namesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * names base type for findUnique actions
   */
  export type namesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the names
     * 
    **/
    select?: namesSelect | null
    /**
     * Filter, which names to fetch.
     * 
    **/
    where: namesWhereUniqueInput
  }

  /**
   * names: findUnique
   */
  export interface namesFindUniqueArgs extends namesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * names findUniqueOrThrow
   */
  export type namesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the names
     * 
    **/
    select?: namesSelect | null
    /**
     * Filter, which names to fetch.
     * 
    **/
    where: namesWhereUniqueInput
  }


  /**
   * names base type for findFirst actions
   */
  export type namesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the names
     * 
    **/
    select?: namesSelect | null
    /**
     * Filter, which names to fetch.
     * 
    **/
    where?: namesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of names to fetch.
     * 
    **/
    orderBy?: Enumerable<namesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for names.
     * 
    **/
    cursor?: namesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` names from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` names.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of names.
     * 
    **/
    distinct?: Enumerable<NamesScalarFieldEnum>
  }

  /**
   * names: findFirst
   */
  export interface namesFindFirstArgs extends namesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * names findFirstOrThrow
   */
  export type namesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the names
     * 
    **/
    select?: namesSelect | null
    /**
     * Filter, which names to fetch.
     * 
    **/
    where?: namesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of names to fetch.
     * 
    **/
    orderBy?: Enumerable<namesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for names.
     * 
    **/
    cursor?: namesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` names from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` names.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of names.
     * 
    **/
    distinct?: Enumerable<NamesScalarFieldEnum>
  }


  /**
   * names findMany
   */
  export type namesFindManyArgs = {
    /**
     * Select specific fields to fetch from the names
     * 
    **/
    select?: namesSelect | null
    /**
     * Filter, which names to fetch.
     * 
    **/
    where?: namesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of names to fetch.
     * 
    **/
    orderBy?: Enumerable<namesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing names.
     * 
    **/
    cursor?: namesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` names from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` names.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NamesScalarFieldEnum>
  }


  /**
   * names create
   */
  export type namesCreateArgs = {
    /**
     * Select specific fields to fetch from the names
     * 
    **/
    select?: namesSelect | null
    /**
     * The data needed to create a names.
     * 
    **/
    data: XOR<namesCreateInput, namesUncheckedCreateInput>
  }


  /**
   * names createMany
   */
  export type namesCreateManyArgs = {
    /**
     * The data used to create many names.
     * 
    **/
    data: Enumerable<namesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * names update
   */
  export type namesUpdateArgs = {
    /**
     * Select specific fields to fetch from the names
     * 
    **/
    select?: namesSelect | null
    /**
     * The data needed to update a names.
     * 
    **/
    data: XOR<namesUpdateInput, namesUncheckedUpdateInput>
    /**
     * Choose, which names to update.
     * 
    **/
    where: namesWhereUniqueInput
  }


  /**
   * names updateMany
   */
  export type namesUpdateManyArgs = {
    /**
     * The data used to update names.
     * 
    **/
    data: XOR<namesUpdateManyMutationInput, namesUncheckedUpdateManyInput>
    /**
     * Filter which names to update
     * 
    **/
    where?: namesWhereInput
  }


  /**
   * names upsert
   */
  export type namesUpsertArgs = {
    /**
     * Select specific fields to fetch from the names
     * 
    **/
    select?: namesSelect | null
    /**
     * The filter to search for the names to update in case it exists.
     * 
    **/
    where: namesWhereUniqueInput
    /**
     * In case the names found by the `where` argument doesn't exist, create a new names with this data.
     * 
    **/
    create: XOR<namesCreateInput, namesUncheckedCreateInput>
    /**
     * In case the names was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<namesUpdateInput, namesUncheckedUpdateInput>
  }


  /**
   * names delete
   */
  export type namesDeleteArgs = {
    /**
     * Select specific fields to fetch from the names
     * 
    **/
    select?: namesSelect | null
    /**
     * Filter which names to delete.
     * 
    **/
    where: namesWhereUniqueInput
  }


  /**
   * names deleteMany
   */
  export type namesDeleteManyArgs = {
    /**
     * Filter which names to delete
     * 
    **/
    where?: namesWhereInput
  }


  /**
   * names without action
   */
  export type namesArgs = {
    /**
     * Select specific fields to fetch from the names
     * 
    **/
    select?: namesSelect | null
  }



  /**
   * Model namespaces
   */


  export type AggregateNamespaces = {
    _count: NamespacesCountAggregateOutputType | null
    _avg: NamespacesAvgAggregateOutputType | null
    _sum: NamespacesSumAggregateOutputType | null
    _min: NamespacesMinAggregateOutputType | null
    _max: NamespacesMaxAggregateOutputType | null
  }

  export type NamespacesAvgAggregateOutputType = {
    id: number | null
    launched_at: number | null
    reveal_block: number | null
    ready_block: number | null
    base: Decimal | null
    coeff: Decimal | null
    nonalpha_discount: number | null
    no_vowel_discount: number | null
    lifetime: number | null
    tx_index: number | null
    microblock_sequence: number | null
  }

  export type NamespacesSumAggregateOutputType = {
    id: number | null
    launched_at: number | null
    reveal_block: number | null
    ready_block: number | null
    base: Decimal | null
    coeff: Decimal | null
    nonalpha_discount: number | null
    no_vowel_discount: number | null
    lifetime: number | null
    tx_index: number | null
    microblock_sequence: number | null
  }

  export type NamespacesMinAggregateOutputType = {
    id: number | null
    namespace_id: string | null
    launched_at: number | null
    address: string | null
    reveal_block: number | null
    ready_block: number | null
    buckets: string | null
    base: Decimal | null
    coeff: Decimal | null
    nonalpha_discount: number | null
    no_vowel_discount: number | null
    lifetime: number | null
    status: string | null
    tx_id: Buffer | null
    tx_index: number | null
    canonical: boolean | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
  }

  export type NamespacesMaxAggregateOutputType = {
    id: number | null
    namespace_id: string | null
    launched_at: number | null
    address: string | null
    reveal_block: number | null
    ready_block: number | null
    buckets: string | null
    base: Decimal | null
    coeff: Decimal | null
    nonalpha_discount: number | null
    no_vowel_discount: number | null
    lifetime: number | null
    status: string | null
    tx_id: Buffer | null
    tx_index: number | null
    canonical: boolean | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
  }

  export type NamespacesCountAggregateOutputType = {
    id: number
    namespace_id: number
    launched_at: number
    address: number
    reveal_block: number
    ready_block: number
    buckets: number
    base: number
    coeff: number
    nonalpha_discount: number
    no_vowel_discount: number
    lifetime: number
    status: number
    tx_id: number
    tx_index: number
    canonical: number
    index_block_hash: number
    parent_index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    microblock_canonical: number
    _all: number
  }


  export type NamespacesAvgAggregateInputType = {
    id?: true
    launched_at?: true
    reveal_block?: true
    ready_block?: true
    base?: true
    coeff?: true
    nonalpha_discount?: true
    no_vowel_discount?: true
    lifetime?: true
    tx_index?: true
    microblock_sequence?: true
  }

  export type NamespacesSumAggregateInputType = {
    id?: true
    launched_at?: true
    reveal_block?: true
    ready_block?: true
    base?: true
    coeff?: true
    nonalpha_discount?: true
    no_vowel_discount?: true
    lifetime?: true
    tx_index?: true
    microblock_sequence?: true
  }

  export type NamespacesMinAggregateInputType = {
    id?: true
    namespace_id?: true
    launched_at?: true
    address?: true
    reveal_block?: true
    ready_block?: true
    buckets?: true
    base?: true
    coeff?: true
    nonalpha_discount?: true
    no_vowel_discount?: true
    lifetime?: true
    status?: true
    tx_id?: true
    tx_index?: true
    canonical?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
  }

  export type NamespacesMaxAggregateInputType = {
    id?: true
    namespace_id?: true
    launched_at?: true
    address?: true
    reveal_block?: true
    ready_block?: true
    buckets?: true
    base?: true
    coeff?: true
    nonalpha_discount?: true
    no_vowel_discount?: true
    lifetime?: true
    status?: true
    tx_id?: true
    tx_index?: true
    canonical?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
  }

  export type NamespacesCountAggregateInputType = {
    id?: true
    namespace_id?: true
    launched_at?: true
    address?: true
    reveal_block?: true
    ready_block?: true
    buckets?: true
    base?: true
    coeff?: true
    nonalpha_discount?: true
    no_vowel_discount?: true
    lifetime?: true
    status?: true
    tx_id?: true
    tx_index?: true
    canonical?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    _all?: true
  }

  export type NamespacesAggregateArgs = {
    /**
     * Filter which namespaces to aggregate.
     * 
    **/
    where?: namespacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of namespaces to fetch.
     * 
    **/
    orderBy?: Enumerable<namespacesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: namespacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` namespaces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` namespaces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned namespaces
    **/
    _count?: true | NamespacesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NamespacesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NamespacesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NamespacesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NamespacesMaxAggregateInputType
  }

  export type GetNamespacesAggregateType<T extends NamespacesAggregateArgs> = {
        [P in keyof T & keyof AggregateNamespaces]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNamespaces[P]>
      : GetScalarType<T[P], AggregateNamespaces[P]>
  }




  export type NamespacesGroupByArgs = {
    where?: namespacesWhereInput
    orderBy?: Enumerable<namespacesOrderByWithAggregationInput>
    by: Array<NamespacesScalarFieldEnum>
    having?: namespacesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NamespacesCountAggregateInputType | true
    _avg?: NamespacesAvgAggregateInputType
    _sum?: NamespacesSumAggregateInputType
    _min?: NamespacesMinAggregateInputType
    _max?: NamespacesMaxAggregateInputType
  }


  export type NamespacesGroupByOutputType = {
    id: number
    namespace_id: string
    launched_at: number | null
    address: string
    reveal_block: number
    ready_block: number
    buckets: string
    base: Decimal
    coeff: Decimal
    nonalpha_discount: number
    no_vowel_discount: number
    lifetime: number
    status: string | null
    tx_id: Buffer | null
    tx_index: number
    canonical: boolean
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    _count: NamespacesCountAggregateOutputType | null
    _avg: NamespacesAvgAggregateOutputType | null
    _sum: NamespacesSumAggregateOutputType | null
    _min: NamespacesMinAggregateOutputType | null
    _max: NamespacesMaxAggregateOutputType | null
  }

  type GetNamespacesGroupByPayload<T extends NamespacesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NamespacesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NamespacesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NamespacesGroupByOutputType[P]>
            : GetScalarType<T[P], NamespacesGroupByOutputType[P]>
        }
      >
    >


  export type namespacesSelect = {
    id?: boolean
    namespace_id?: boolean
    launched_at?: boolean
    address?: boolean
    reveal_block?: boolean
    ready_block?: boolean
    buckets?: boolean
    base?: boolean
    coeff?: boolean
    nonalpha_discount?: boolean
    no_vowel_discount?: boolean
    lifetime?: boolean
    status?: boolean
    tx_id?: boolean
    tx_index?: boolean
    canonical?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_canonical?: boolean
  }


  export type namespacesGetPayload<S extends boolean | null | undefined | namespacesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? namespaces :
    S extends undefined ? never :
    S extends { include: any } & (namespacesArgs | namespacesFindManyArgs)
    ? namespaces 
    : S extends { select: any } & (namespacesArgs | namespacesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof namespaces ? namespaces[P] : never
  } 
      : namespaces


  type namespacesCountArgs = Merge<
    Omit<namespacesFindManyArgs, 'select' | 'include'> & {
      select?: NamespacesCountAggregateInputType | true
    }
  >

  export interface namespacesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Namespaces that matches the filter.
     * @param {namespacesFindUniqueArgs} args - Arguments to find a Namespaces
     * @example
     * // Get one Namespaces
     * const namespaces = await prisma.namespaces.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends namespacesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, namespacesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'namespaces'> extends True ? Prisma__namespacesClient<namespacesGetPayload<T>> : Prisma__namespacesClient<namespacesGetPayload<T> | null, null>

    /**
     * Find one Namespaces that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {namespacesFindUniqueOrThrowArgs} args - Arguments to find a Namespaces
     * @example
     * // Get one Namespaces
     * const namespaces = await prisma.namespaces.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends namespacesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, namespacesFindUniqueOrThrowArgs>
    ): Prisma__namespacesClient<namespacesGetPayload<T>>

    /**
     * Find the first Namespaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {namespacesFindFirstArgs} args - Arguments to find a Namespaces
     * @example
     * // Get one Namespaces
     * const namespaces = await prisma.namespaces.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends namespacesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, namespacesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'namespaces'> extends True ? Prisma__namespacesClient<namespacesGetPayload<T>> : Prisma__namespacesClient<namespacesGetPayload<T> | null, null>

    /**
     * Find the first Namespaces that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {namespacesFindFirstOrThrowArgs} args - Arguments to find a Namespaces
     * @example
     * // Get one Namespaces
     * const namespaces = await prisma.namespaces.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends namespacesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, namespacesFindFirstOrThrowArgs>
    ): Prisma__namespacesClient<namespacesGetPayload<T>>

    /**
     * Find zero or more Namespaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {namespacesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Namespaces
     * const namespaces = await prisma.namespaces.findMany()
     * 
     * // Get first 10 Namespaces
     * const namespaces = await prisma.namespaces.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const namespacesWithIdOnly = await prisma.namespaces.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends namespacesFindManyArgs>(
      args?: SelectSubset<T, namespacesFindManyArgs>
    ): PrismaPromise<Array<namespacesGetPayload<T>>>

    /**
     * Create a Namespaces.
     * @param {namespacesCreateArgs} args - Arguments to create a Namespaces.
     * @example
     * // Create one Namespaces
     * const Namespaces = await prisma.namespaces.create({
     *   data: {
     *     // ... data to create a Namespaces
     *   }
     * })
     * 
    **/
    create<T extends namespacesCreateArgs>(
      args: SelectSubset<T, namespacesCreateArgs>
    ): Prisma__namespacesClient<namespacesGetPayload<T>>

    /**
     * Create many Namespaces.
     *     @param {namespacesCreateManyArgs} args - Arguments to create many Namespaces.
     *     @example
     *     // Create many Namespaces
     *     const namespaces = await prisma.namespaces.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends namespacesCreateManyArgs>(
      args?: SelectSubset<T, namespacesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Namespaces.
     * @param {namespacesDeleteArgs} args - Arguments to delete one Namespaces.
     * @example
     * // Delete one Namespaces
     * const Namespaces = await prisma.namespaces.delete({
     *   where: {
     *     // ... filter to delete one Namespaces
     *   }
     * })
     * 
    **/
    delete<T extends namespacesDeleteArgs>(
      args: SelectSubset<T, namespacesDeleteArgs>
    ): Prisma__namespacesClient<namespacesGetPayload<T>>

    /**
     * Update one Namespaces.
     * @param {namespacesUpdateArgs} args - Arguments to update one Namespaces.
     * @example
     * // Update one Namespaces
     * const namespaces = await prisma.namespaces.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends namespacesUpdateArgs>(
      args: SelectSubset<T, namespacesUpdateArgs>
    ): Prisma__namespacesClient<namespacesGetPayload<T>>

    /**
     * Delete zero or more Namespaces.
     * @param {namespacesDeleteManyArgs} args - Arguments to filter Namespaces to delete.
     * @example
     * // Delete a few Namespaces
     * const { count } = await prisma.namespaces.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends namespacesDeleteManyArgs>(
      args?: SelectSubset<T, namespacesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Namespaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {namespacesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Namespaces
     * const namespaces = await prisma.namespaces.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends namespacesUpdateManyArgs>(
      args: SelectSubset<T, namespacesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Namespaces.
     * @param {namespacesUpsertArgs} args - Arguments to update or create a Namespaces.
     * @example
     * // Update or create a Namespaces
     * const namespaces = await prisma.namespaces.upsert({
     *   create: {
     *     // ... data to create a Namespaces
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Namespaces we want to update
     *   }
     * })
    **/
    upsert<T extends namespacesUpsertArgs>(
      args: SelectSubset<T, namespacesUpsertArgs>
    ): Prisma__namespacesClient<namespacesGetPayload<T>>

    /**
     * Count the number of Namespaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {namespacesCountArgs} args - Arguments to filter Namespaces to count.
     * @example
     * // Count the number of Namespaces
     * const count = await prisma.namespaces.count({
     *   where: {
     *     // ... the filter for the Namespaces we want to count
     *   }
     * })
    **/
    count<T extends namespacesCountArgs>(
      args?: Subset<T, namespacesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NamespacesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Namespaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespacesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NamespacesAggregateArgs>(args: Subset<T, NamespacesAggregateArgs>): PrismaPromise<GetNamespacesAggregateType<T>>

    /**
     * Group by Namespaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NamespacesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NamespacesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NamespacesGroupByArgs['orderBy'] }
        : { orderBy?: NamespacesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NamespacesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNamespacesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for namespaces.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__namespacesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * namespaces base type for findUnique actions
   */
  export type namespacesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the namespaces
     * 
    **/
    select?: namespacesSelect | null
    /**
     * Filter, which namespaces to fetch.
     * 
    **/
    where: namespacesWhereUniqueInput
  }

  /**
   * namespaces: findUnique
   */
  export interface namespacesFindUniqueArgs extends namespacesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * namespaces findUniqueOrThrow
   */
  export type namespacesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the namespaces
     * 
    **/
    select?: namespacesSelect | null
    /**
     * Filter, which namespaces to fetch.
     * 
    **/
    where: namespacesWhereUniqueInput
  }


  /**
   * namespaces base type for findFirst actions
   */
  export type namespacesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the namespaces
     * 
    **/
    select?: namespacesSelect | null
    /**
     * Filter, which namespaces to fetch.
     * 
    **/
    where?: namespacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of namespaces to fetch.
     * 
    **/
    orderBy?: Enumerable<namespacesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for namespaces.
     * 
    **/
    cursor?: namespacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` namespaces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` namespaces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of namespaces.
     * 
    **/
    distinct?: Enumerable<NamespacesScalarFieldEnum>
  }

  /**
   * namespaces: findFirst
   */
  export interface namespacesFindFirstArgs extends namespacesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * namespaces findFirstOrThrow
   */
  export type namespacesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the namespaces
     * 
    **/
    select?: namespacesSelect | null
    /**
     * Filter, which namespaces to fetch.
     * 
    **/
    where?: namespacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of namespaces to fetch.
     * 
    **/
    orderBy?: Enumerable<namespacesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for namespaces.
     * 
    **/
    cursor?: namespacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` namespaces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` namespaces.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of namespaces.
     * 
    **/
    distinct?: Enumerable<NamespacesScalarFieldEnum>
  }


  /**
   * namespaces findMany
   */
  export type namespacesFindManyArgs = {
    /**
     * Select specific fields to fetch from the namespaces
     * 
    **/
    select?: namespacesSelect | null
    /**
     * Filter, which namespaces to fetch.
     * 
    **/
    where?: namespacesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of namespaces to fetch.
     * 
    **/
    orderBy?: Enumerable<namespacesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing namespaces.
     * 
    **/
    cursor?: namespacesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` namespaces from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` namespaces.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NamespacesScalarFieldEnum>
  }


  /**
   * namespaces create
   */
  export type namespacesCreateArgs = {
    /**
     * Select specific fields to fetch from the namespaces
     * 
    **/
    select?: namespacesSelect | null
    /**
     * The data needed to create a namespaces.
     * 
    **/
    data: XOR<namespacesCreateInput, namespacesUncheckedCreateInput>
  }


  /**
   * namespaces createMany
   */
  export type namespacesCreateManyArgs = {
    /**
     * The data used to create many namespaces.
     * 
    **/
    data: Enumerable<namespacesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * namespaces update
   */
  export type namespacesUpdateArgs = {
    /**
     * Select specific fields to fetch from the namespaces
     * 
    **/
    select?: namespacesSelect | null
    /**
     * The data needed to update a namespaces.
     * 
    **/
    data: XOR<namespacesUpdateInput, namespacesUncheckedUpdateInput>
    /**
     * Choose, which namespaces to update.
     * 
    **/
    where: namespacesWhereUniqueInput
  }


  /**
   * namespaces updateMany
   */
  export type namespacesUpdateManyArgs = {
    /**
     * The data used to update namespaces.
     * 
    **/
    data: XOR<namespacesUpdateManyMutationInput, namespacesUncheckedUpdateManyInput>
    /**
     * Filter which namespaces to update
     * 
    **/
    where?: namespacesWhereInput
  }


  /**
   * namespaces upsert
   */
  export type namespacesUpsertArgs = {
    /**
     * Select specific fields to fetch from the namespaces
     * 
    **/
    select?: namespacesSelect | null
    /**
     * The filter to search for the namespaces to update in case it exists.
     * 
    **/
    where: namespacesWhereUniqueInput
    /**
     * In case the namespaces found by the `where` argument doesn't exist, create a new namespaces with this data.
     * 
    **/
    create: XOR<namespacesCreateInput, namespacesUncheckedCreateInput>
    /**
     * In case the namespaces was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<namespacesUpdateInput, namespacesUncheckedUpdateInput>
  }


  /**
   * namespaces delete
   */
  export type namespacesDeleteArgs = {
    /**
     * Select specific fields to fetch from the namespaces
     * 
    **/
    select?: namespacesSelect | null
    /**
     * Filter which namespaces to delete.
     * 
    **/
    where: namespacesWhereUniqueInput
  }


  /**
   * namespaces deleteMany
   */
  export type namespacesDeleteManyArgs = {
    /**
     * Filter which namespaces to delete
     * 
    **/
    where?: namespacesWhereInput
  }


  /**
   * namespaces without action
   */
  export type namespacesArgs = {
    /**
     * Select specific fields to fetch from the namespaces
     * 
    **/
    select?: namespacesSelect | null
  }



  /**
   * Model nft_events
   */


  export type AggregateNft_events = {
    _count: Nft_eventsCountAggregateOutputType | null
    _avg: Nft_eventsAvgAggregateOutputType | null
    _sum: Nft_eventsSumAggregateOutputType | null
    _min: Nft_eventsMinAggregateOutputType | null
    _max: Nft_eventsMaxAggregateOutputType | null
  }

  export type Nft_eventsAvgAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
    asset_event_type_id: number | null
  }

  export type Nft_eventsSumAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
    asset_event_type_id: number | null
  }

  export type Nft_eventsMinAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    asset_event_type_id: number | null
    asset_identifier: string | null
    value: Buffer | null
    sender: string | null
    recipient: string | null
  }

  export type Nft_eventsMaxAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    asset_event_type_id: number | null
    asset_identifier: string | null
    value: Buffer | null
    sender: string | null
    recipient: string | null
  }

  export type Nft_eventsCountAggregateOutputType = {
    id: number
    event_index: number
    tx_id: number
    tx_index: number
    block_height: number
    index_block_hash: number
    parent_index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    microblock_canonical: number
    canonical: number
    asset_event_type_id: number
    asset_identifier: number
    value: number
    sender: number
    recipient: number
    _all: number
  }


  export type Nft_eventsAvgAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
    asset_event_type_id?: true
  }

  export type Nft_eventsSumAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
    asset_event_type_id?: true
  }

  export type Nft_eventsMinAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    asset_event_type_id?: true
    asset_identifier?: true
    value?: true
    sender?: true
    recipient?: true
  }

  export type Nft_eventsMaxAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    asset_event_type_id?: true
    asset_identifier?: true
    value?: true
    sender?: true
    recipient?: true
  }

  export type Nft_eventsCountAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    asset_event_type_id?: true
    asset_identifier?: true
    value?: true
    sender?: true
    recipient?: true
    _all?: true
  }

  export type Nft_eventsAggregateArgs = {
    /**
     * Filter which nft_events to aggregate.
     * 
    **/
    where?: nft_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nft_events to fetch.
     * 
    **/
    orderBy?: Enumerable<nft_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: nft_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nft_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nft_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned nft_events
    **/
    _count?: true | Nft_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Nft_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Nft_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Nft_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Nft_eventsMaxAggregateInputType
  }

  export type GetNft_eventsAggregateType<T extends Nft_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateNft_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNft_events[P]>
      : GetScalarType<T[P], AggregateNft_events[P]>
  }




  export type Nft_eventsGroupByArgs = {
    where?: nft_eventsWhereInput
    orderBy?: Enumerable<nft_eventsOrderByWithAggregationInput>
    by: Array<Nft_eventsScalarFieldEnum>
    having?: nft_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Nft_eventsCountAggregateInputType | true
    _avg?: Nft_eventsAvgAggregateInputType
    _sum?: Nft_eventsSumAggregateInputType
    _min?: Nft_eventsMinAggregateInputType
    _max?: Nft_eventsMaxAggregateInputType
  }


  export type Nft_eventsGroupByOutputType = {
    id: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    asset_identifier: string
    value: Buffer
    sender: string | null
    recipient: string | null
    _count: Nft_eventsCountAggregateOutputType | null
    _avg: Nft_eventsAvgAggregateOutputType | null
    _sum: Nft_eventsSumAggregateOutputType | null
    _min: Nft_eventsMinAggregateOutputType | null
    _max: Nft_eventsMaxAggregateOutputType | null
  }

  type GetNft_eventsGroupByPayload<T extends Nft_eventsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Nft_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Nft_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Nft_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Nft_eventsGroupByOutputType[P]>
        }
      >
    >


  export type nft_eventsSelect = {
    id?: boolean
    event_index?: boolean
    tx_id?: boolean
    tx_index?: boolean
    block_height?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_canonical?: boolean
    canonical?: boolean
    asset_event_type_id?: boolean
    asset_identifier?: boolean
    value?: boolean
    sender?: boolean
    recipient?: boolean
  }


  export type nft_eventsGetPayload<S extends boolean | null | undefined | nft_eventsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? nft_events :
    S extends undefined ? never :
    S extends { include: any } & (nft_eventsArgs | nft_eventsFindManyArgs)
    ? nft_events 
    : S extends { select: any } & (nft_eventsArgs | nft_eventsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof nft_events ? nft_events[P] : never
  } 
      : nft_events


  type nft_eventsCountArgs = Merge<
    Omit<nft_eventsFindManyArgs, 'select' | 'include'> & {
      select?: Nft_eventsCountAggregateInputType | true
    }
  >

  export interface nft_eventsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Nft_events that matches the filter.
     * @param {nft_eventsFindUniqueArgs} args - Arguments to find a Nft_events
     * @example
     * // Get one Nft_events
     * const nft_events = await prisma.nft_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends nft_eventsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, nft_eventsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'nft_events'> extends True ? Prisma__nft_eventsClient<nft_eventsGetPayload<T>> : Prisma__nft_eventsClient<nft_eventsGetPayload<T> | null, null>

    /**
     * Find one Nft_events that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {nft_eventsFindUniqueOrThrowArgs} args - Arguments to find a Nft_events
     * @example
     * // Get one Nft_events
     * const nft_events = await prisma.nft_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends nft_eventsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, nft_eventsFindUniqueOrThrowArgs>
    ): Prisma__nft_eventsClient<nft_eventsGetPayload<T>>

    /**
     * Find the first Nft_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nft_eventsFindFirstArgs} args - Arguments to find a Nft_events
     * @example
     * // Get one Nft_events
     * const nft_events = await prisma.nft_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends nft_eventsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, nft_eventsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'nft_events'> extends True ? Prisma__nft_eventsClient<nft_eventsGetPayload<T>> : Prisma__nft_eventsClient<nft_eventsGetPayload<T> | null, null>

    /**
     * Find the first Nft_events that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nft_eventsFindFirstOrThrowArgs} args - Arguments to find a Nft_events
     * @example
     * // Get one Nft_events
     * const nft_events = await prisma.nft_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends nft_eventsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, nft_eventsFindFirstOrThrowArgs>
    ): Prisma__nft_eventsClient<nft_eventsGetPayload<T>>

    /**
     * Find zero or more Nft_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nft_eventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nft_events
     * const nft_events = await prisma.nft_events.findMany()
     * 
     * // Get first 10 Nft_events
     * const nft_events = await prisma.nft_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nft_eventsWithIdOnly = await prisma.nft_events.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends nft_eventsFindManyArgs>(
      args?: SelectSubset<T, nft_eventsFindManyArgs>
    ): PrismaPromise<Array<nft_eventsGetPayload<T>>>

    /**
     * Create a Nft_events.
     * @param {nft_eventsCreateArgs} args - Arguments to create a Nft_events.
     * @example
     * // Create one Nft_events
     * const Nft_events = await prisma.nft_events.create({
     *   data: {
     *     // ... data to create a Nft_events
     *   }
     * })
     * 
    **/
    create<T extends nft_eventsCreateArgs>(
      args: SelectSubset<T, nft_eventsCreateArgs>
    ): Prisma__nft_eventsClient<nft_eventsGetPayload<T>>

    /**
     * Create many Nft_events.
     *     @param {nft_eventsCreateManyArgs} args - Arguments to create many Nft_events.
     *     @example
     *     // Create many Nft_events
     *     const nft_events = await prisma.nft_events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends nft_eventsCreateManyArgs>(
      args?: SelectSubset<T, nft_eventsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Nft_events.
     * @param {nft_eventsDeleteArgs} args - Arguments to delete one Nft_events.
     * @example
     * // Delete one Nft_events
     * const Nft_events = await prisma.nft_events.delete({
     *   where: {
     *     // ... filter to delete one Nft_events
     *   }
     * })
     * 
    **/
    delete<T extends nft_eventsDeleteArgs>(
      args: SelectSubset<T, nft_eventsDeleteArgs>
    ): Prisma__nft_eventsClient<nft_eventsGetPayload<T>>

    /**
     * Update one Nft_events.
     * @param {nft_eventsUpdateArgs} args - Arguments to update one Nft_events.
     * @example
     * // Update one Nft_events
     * const nft_events = await prisma.nft_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends nft_eventsUpdateArgs>(
      args: SelectSubset<T, nft_eventsUpdateArgs>
    ): Prisma__nft_eventsClient<nft_eventsGetPayload<T>>

    /**
     * Delete zero or more Nft_events.
     * @param {nft_eventsDeleteManyArgs} args - Arguments to filter Nft_events to delete.
     * @example
     * // Delete a few Nft_events
     * const { count } = await prisma.nft_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends nft_eventsDeleteManyArgs>(
      args?: SelectSubset<T, nft_eventsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nft_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nft_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nft_events
     * const nft_events = await prisma.nft_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends nft_eventsUpdateManyArgs>(
      args: SelectSubset<T, nft_eventsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Nft_events.
     * @param {nft_eventsUpsertArgs} args - Arguments to update or create a Nft_events.
     * @example
     * // Update or create a Nft_events
     * const nft_events = await prisma.nft_events.upsert({
     *   create: {
     *     // ... data to create a Nft_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nft_events we want to update
     *   }
     * })
    **/
    upsert<T extends nft_eventsUpsertArgs>(
      args: SelectSubset<T, nft_eventsUpsertArgs>
    ): Prisma__nft_eventsClient<nft_eventsGetPayload<T>>

    /**
     * Count the number of Nft_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nft_eventsCountArgs} args - Arguments to filter Nft_events to count.
     * @example
     * // Count the number of Nft_events
     * const count = await prisma.nft_events.count({
     *   where: {
     *     // ... the filter for the Nft_events we want to count
     *   }
     * })
    **/
    count<T extends nft_eventsCountArgs>(
      args?: Subset<T, nft_eventsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Nft_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nft_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Nft_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Nft_eventsAggregateArgs>(args: Subset<T, Nft_eventsAggregateArgs>): PrismaPromise<GetNft_eventsAggregateType<T>>

    /**
     * Group by Nft_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Nft_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Nft_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Nft_eventsGroupByArgs['orderBy'] }
        : { orderBy?: Nft_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Nft_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNft_eventsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for nft_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__nft_eventsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * nft_events base type for findUnique actions
   */
  export type nft_eventsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the nft_events
     * 
    **/
    select?: nft_eventsSelect | null
    /**
     * Filter, which nft_events to fetch.
     * 
    **/
    where: nft_eventsWhereUniqueInput
  }

  /**
   * nft_events: findUnique
   */
  export interface nft_eventsFindUniqueArgs extends nft_eventsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * nft_events findUniqueOrThrow
   */
  export type nft_eventsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the nft_events
     * 
    **/
    select?: nft_eventsSelect | null
    /**
     * Filter, which nft_events to fetch.
     * 
    **/
    where: nft_eventsWhereUniqueInput
  }


  /**
   * nft_events base type for findFirst actions
   */
  export type nft_eventsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the nft_events
     * 
    **/
    select?: nft_eventsSelect | null
    /**
     * Filter, which nft_events to fetch.
     * 
    **/
    where?: nft_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nft_events to fetch.
     * 
    **/
    orderBy?: Enumerable<nft_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nft_events.
     * 
    **/
    cursor?: nft_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nft_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nft_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nft_events.
     * 
    **/
    distinct?: Enumerable<Nft_eventsScalarFieldEnum>
  }

  /**
   * nft_events: findFirst
   */
  export interface nft_eventsFindFirstArgs extends nft_eventsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * nft_events findFirstOrThrow
   */
  export type nft_eventsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the nft_events
     * 
    **/
    select?: nft_eventsSelect | null
    /**
     * Filter, which nft_events to fetch.
     * 
    **/
    where?: nft_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nft_events to fetch.
     * 
    **/
    orderBy?: Enumerable<nft_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nft_events.
     * 
    **/
    cursor?: nft_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nft_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nft_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nft_events.
     * 
    **/
    distinct?: Enumerable<Nft_eventsScalarFieldEnum>
  }


  /**
   * nft_events findMany
   */
  export type nft_eventsFindManyArgs = {
    /**
     * Select specific fields to fetch from the nft_events
     * 
    **/
    select?: nft_eventsSelect | null
    /**
     * Filter, which nft_events to fetch.
     * 
    **/
    where?: nft_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nft_events to fetch.
     * 
    **/
    orderBy?: Enumerable<nft_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing nft_events.
     * 
    **/
    cursor?: nft_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nft_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nft_events.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Nft_eventsScalarFieldEnum>
  }


  /**
   * nft_events create
   */
  export type nft_eventsCreateArgs = {
    /**
     * Select specific fields to fetch from the nft_events
     * 
    **/
    select?: nft_eventsSelect | null
    /**
     * The data needed to create a nft_events.
     * 
    **/
    data: XOR<nft_eventsCreateInput, nft_eventsUncheckedCreateInput>
  }


  /**
   * nft_events createMany
   */
  export type nft_eventsCreateManyArgs = {
    /**
     * The data used to create many nft_events.
     * 
    **/
    data: Enumerable<nft_eventsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * nft_events update
   */
  export type nft_eventsUpdateArgs = {
    /**
     * Select specific fields to fetch from the nft_events
     * 
    **/
    select?: nft_eventsSelect | null
    /**
     * The data needed to update a nft_events.
     * 
    **/
    data: XOR<nft_eventsUpdateInput, nft_eventsUncheckedUpdateInput>
    /**
     * Choose, which nft_events to update.
     * 
    **/
    where: nft_eventsWhereUniqueInput
  }


  /**
   * nft_events updateMany
   */
  export type nft_eventsUpdateManyArgs = {
    /**
     * The data used to update nft_events.
     * 
    **/
    data: XOR<nft_eventsUpdateManyMutationInput, nft_eventsUncheckedUpdateManyInput>
    /**
     * Filter which nft_events to update
     * 
    **/
    where?: nft_eventsWhereInput
  }


  /**
   * nft_events upsert
   */
  export type nft_eventsUpsertArgs = {
    /**
     * Select specific fields to fetch from the nft_events
     * 
    **/
    select?: nft_eventsSelect | null
    /**
     * The filter to search for the nft_events to update in case it exists.
     * 
    **/
    where: nft_eventsWhereUniqueInput
    /**
     * In case the nft_events found by the `where` argument doesn't exist, create a new nft_events with this data.
     * 
    **/
    create: XOR<nft_eventsCreateInput, nft_eventsUncheckedCreateInput>
    /**
     * In case the nft_events was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<nft_eventsUpdateInput, nft_eventsUncheckedUpdateInput>
  }


  /**
   * nft_events delete
   */
  export type nft_eventsDeleteArgs = {
    /**
     * Select specific fields to fetch from the nft_events
     * 
    **/
    select?: nft_eventsSelect | null
    /**
     * Filter which nft_events to delete.
     * 
    **/
    where: nft_eventsWhereUniqueInput
  }


  /**
   * nft_events deleteMany
   */
  export type nft_eventsDeleteManyArgs = {
    /**
     * Filter which nft_events to delete
     * 
    **/
    where?: nft_eventsWhereInput
  }


  /**
   * nft_events without action
   */
  export type nft_eventsArgs = {
    /**
     * Select specific fields to fetch from the nft_events
     * 
    **/
    select?: nft_eventsSelect | null
  }



  /**
   * Model nft_metadata
   */


  export type AggregateNft_metadata = {
    _count: Nft_metadataCountAggregateOutputType | null
    _avg: Nft_metadataAvgAggregateOutputType | null
    _sum: Nft_metadataSumAggregateOutputType | null
    _min: Nft_metadataMinAggregateOutputType | null
    _max: Nft_metadataMaxAggregateOutputType | null
  }

  export type Nft_metadataAvgAggregateOutputType = {
    id: number | null
  }

  export type Nft_metadataSumAggregateOutputType = {
    id: number | null
  }

  export type Nft_metadataMinAggregateOutputType = {
    id: number | null
    name: string | null
    token_uri: string | null
    description: string | null
    image_uri: string | null
    image_canonical_uri: string | null
    contract_id: string | null
    tx_id: Buffer | null
    sender_address: string | null
  }

  export type Nft_metadataMaxAggregateOutputType = {
    id: number | null
    name: string | null
    token_uri: string | null
    description: string | null
    image_uri: string | null
    image_canonical_uri: string | null
    contract_id: string | null
    tx_id: Buffer | null
    sender_address: string | null
  }

  export type Nft_metadataCountAggregateOutputType = {
    id: number
    name: number
    token_uri: number
    description: number
    image_uri: number
    image_canonical_uri: number
    contract_id: number
    tx_id: number
    sender_address: number
    _all: number
  }


  export type Nft_metadataAvgAggregateInputType = {
    id?: true
  }

  export type Nft_metadataSumAggregateInputType = {
    id?: true
  }

  export type Nft_metadataMinAggregateInputType = {
    id?: true
    name?: true
    token_uri?: true
    description?: true
    image_uri?: true
    image_canonical_uri?: true
    contract_id?: true
    tx_id?: true
    sender_address?: true
  }

  export type Nft_metadataMaxAggregateInputType = {
    id?: true
    name?: true
    token_uri?: true
    description?: true
    image_uri?: true
    image_canonical_uri?: true
    contract_id?: true
    tx_id?: true
    sender_address?: true
  }

  export type Nft_metadataCountAggregateInputType = {
    id?: true
    name?: true
    token_uri?: true
    description?: true
    image_uri?: true
    image_canonical_uri?: true
    contract_id?: true
    tx_id?: true
    sender_address?: true
    _all?: true
  }

  export type Nft_metadataAggregateArgs = {
    /**
     * Filter which nft_metadata to aggregate.
     * 
    **/
    where?: nft_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nft_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<nft_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: nft_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nft_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nft_metadata.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned nft_metadata
    **/
    _count?: true | Nft_metadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Nft_metadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Nft_metadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Nft_metadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Nft_metadataMaxAggregateInputType
  }

  export type GetNft_metadataAggregateType<T extends Nft_metadataAggregateArgs> = {
        [P in keyof T & keyof AggregateNft_metadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNft_metadata[P]>
      : GetScalarType<T[P], AggregateNft_metadata[P]>
  }




  export type Nft_metadataGroupByArgs = {
    where?: nft_metadataWhereInput
    orderBy?: Enumerable<nft_metadataOrderByWithAggregationInput>
    by: Array<Nft_metadataScalarFieldEnum>
    having?: nft_metadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Nft_metadataCountAggregateInputType | true
    _avg?: Nft_metadataAvgAggregateInputType
    _sum?: Nft_metadataSumAggregateInputType
    _min?: Nft_metadataMinAggregateInputType
    _max?: Nft_metadataMaxAggregateInputType
  }


  export type Nft_metadataGroupByOutputType = {
    id: number
    name: string
    token_uri: string
    description: string
    image_uri: string
    image_canonical_uri: string
    contract_id: string
    tx_id: Buffer
    sender_address: string
    _count: Nft_metadataCountAggregateOutputType | null
    _avg: Nft_metadataAvgAggregateOutputType | null
    _sum: Nft_metadataSumAggregateOutputType | null
    _min: Nft_metadataMinAggregateOutputType | null
    _max: Nft_metadataMaxAggregateOutputType | null
  }

  type GetNft_metadataGroupByPayload<T extends Nft_metadataGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Nft_metadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Nft_metadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Nft_metadataGroupByOutputType[P]>
            : GetScalarType<T[P], Nft_metadataGroupByOutputType[P]>
        }
      >
    >


  export type nft_metadataSelect = {
    id?: boolean
    name?: boolean
    token_uri?: boolean
    description?: boolean
    image_uri?: boolean
    image_canonical_uri?: boolean
    contract_id?: boolean
    tx_id?: boolean
    sender_address?: boolean
  }


  export type nft_metadataGetPayload<S extends boolean | null | undefined | nft_metadataArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? nft_metadata :
    S extends undefined ? never :
    S extends { include: any } & (nft_metadataArgs | nft_metadataFindManyArgs)
    ? nft_metadata 
    : S extends { select: any } & (nft_metadataArgs | nft_metadataFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof nft_metadata ? nft_metadata[P] : never
  } 
      : nft_metadata


  type nft_metadataCountArgs = Merge<
    Omit<nft_metadataFindManyArgs, 'select' | 'include'> & {
      select?: Nft_metadataCountAggregateInputType | true
    }
  >

  export interface nft_metadataDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Nft_metadata that matches the filter.
     * @param {nft_metadataFindUniqueArgs} args - Arguments to find a Nft_metadata
     * @example
     * // Get one Nft_metadata
     * const nft_metadata = await prisma.nft_metadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends nft_metadataFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, nft_metadataFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'nft_metadata'> extends True ? Prisma__nft_metadataClient<nft_metadataGetPayload<T>> : Prisma__nft_metadataClient<nft_metadataGetPayload<T> | null, null>

    /**
     * Find one Nft_metadata that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {nft_metadataFindUniqueOrThrowArgs} args - Arguments to find a Nft_metadata
     * @example
     * // Get one Nft_metadata
     * const nft_metadata = await prisma.nft_metadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends nft_metadataFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, nft_metadataFindUniqueOrThrowArgs>
    ): Prisma__nft_metadataClient<nft_metadataGetPayload<T>>

    /**
     * Find the first Nft_metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nft_metadataFindFirstArgs} args - Arguments to find a Nft_metadata
     * @example
     * // Get one Nft_metadata
     * const nft_metadata = await prisma.nft_metadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends nft_metadataFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, nft_metadataFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'nft_metadata'> extends True ? Prisma__nft_metadataClient<nft_metadataGetPayload<T>> : Prisma__nft_metadataClient<nft_metadataGetPayload<T> | null, null>

    /**
     * Find the first Nft_metadata that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nft_metadataFindFirstOrThrowArgs} args - Arguments to find a Nft_metadata
     * @example
     * // Get one Nft_metadata
     * const nft_metadata = await prisma.nft_metadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends nft_metadataFindFirstOrThrowArgs>(
      args?: SelectSubset<T, nft_metadataFindFirstOrThrowArgs>
    ): Prisma__nft_metadataClient<nft_metadataGetPayload<T>>

    /**
     * Find zero or more Nft_metadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nft_metadataFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nft_metadata
     * const nft_metadata = await prisma.nft_metadata.findMany()
     * 
     * // Get first 10 Nft_metadata
     * const nft_metadata = await prisma.nft_metadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nft_metadataWithIdOnly = await prisma.nft_metadata.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends nft_metadataFindManyArgs>(
      args?: SelectSubset<T, nft_metadataFindManyArgs>
    ): PrismaPromise<Array<nft_metadataGetPayload<T>>>

    /**
     * Create a Nft_metadata.
     * @param {nft_metadataCreateArgs} args - Arguments to create a Nft_metadata.
     * @example
     * // Create one Nft_metadata
     * const Nft_metadata = await prisma.nft_metadata.create({
     *   data: {
     *     // ... data to create a Nft_metadata
     *   }
     * })
     * 
    **/
    create<T extends nft_metadataCreateArgs>(
      args: SelectSubset<T, nft_metadataCreateArgs>
    ): Prisma__nft_metadataClient<nft_metadataGetPayload<T>>

    /**
     * Create many Nft_metadata.
     *     @param {nft_metadataCreateManyArgs} args - Arguments to create many Nft_metadata.
     *     @example
     *     // Create many Nft_metadata
     *     const nft_metadata = await prisma.nft_metadata.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends nft_metadataCreateManyArgs>(
      args?: SelectSubset<T, nft_metadataCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Nft_metadata.
     * @param {nft_metadataDeleteArgs} args - Arguments to delete one Nft_metadata.
     * @example
     * // Delete one Nft_metadata
     * const Nft_metadata = await prisma.nft_metadata.delete({
     *   where: {
     *     // ... filter to delete one Nft_metadata
     *   }
     * })
     * 
    **/
    delete<T extends nft_metadataDeleteArgs>(
      args: SelectSubset<T, nft_metadataDeleteArgs>
    ): Prisma__nft_metadataClient<nft_metadataGetPayload<T>>

    /**
     * Update one Nft_metadata.
     * @param {nft_metadataUpdateArgs} args - Arguments to update one Nft_metadata.
     * @example
     * // Update one Nft_metadata
     * const nft_metadata = await prisma.nft_metadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends nft_metadataUpdateArgs>(
      args: SelectSubset<T, nft_metadataUpdateArgs>
    ): Prisma__nft_metadataClient<nft_metadataGetPayload<T>>

    /**
     * Delete zero or more Nft_metadata.
     * @param {nft_metadataDeleteManyArgs} args - Arguments to filter Nft_metadata to delete.
     * @example
     * // Delete a few Nft_metadata
     * const { count } = await prisma.nft_metadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends nft_metadataDeleteManyArgs>(
      args?: SelectSubset<T, nft_metadataDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nft_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nft_metadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nft_metadata
     * const nft_metadata = await prisma.nft_metadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends nft_metadataUpdateManyArgs>(
      args: SelectSubset<T, nft_metadataUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Nft_metadata.
     * @param {nft_metadataUpsertArgs} args - Arguments to update or create a Nft_metadata.
     * @example
     * // Update or create a Nft_metadata
     * const nft_metadata = await prisma.nft_metadata.upsert({
     *   create: {
     *     // ... data to create a Nft_metadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nft_metadata we want to update
     *   }
     * })
    **/
    upsert<T extends nft_metadataUpsertArgs>(
      args: SelectSubset<T, nft_metadataUpsertArgs>
    ): Prisma__nft_metadataClient<nft_metadataGetPayload<T>>

    /**
     * Count the number of Nft_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {nft_metadataCountArgs} args - Arguments to filter Nft_metadata to count.
     * @example
     * // Count the number of Nft_metadata
     * const count = await prisma.nft_metadata.count({
     *   where: {
     *     // ... the filter for the Nft_metadata we want to count
     *   }
     * })
    **/
    count<T extends nft_metadataCountArgs>(
      args?: Subset<T, nft_metadataCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Nft_metadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nft_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Nft_metadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Nft_metadataAggregateArgs>(args: Subset<T, Nft_metadataAggregateArgs>): PrismaPromise<GetNft_metadataAggregateType<T>>

    /**
     * Group by Nft_metadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Nft_metadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Nft_metadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Nft_metadataGroupByArgs['orderBy'] }
        : { orderBy?: Nft_metadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Nft_metadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNft_metadataGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for nft_metadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__nft_metadataClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * nft_metadata base type for findUnique actions
   */
  export type nft_metadataFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the nft_metadata
     * 
    **/
    select?: nft_metadataSelect | null
    /**
     * Filter, which nft_metadata to fetch.
     * 
    **/
    where: nft_metadataWhereUniqueInput
  }

  /**
   * nft_metadata: findUnique
   */
  export interface nft_metadataFindUniqueArgs extends nft_metadataFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * nft_metadata findUniqueOrThrow
   */
  export type nft_metadataFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the nft_metadata
     * 
    **/
    select?: nft_metadataSelect | null
    /**
     * Filter, which nft_metadata to fetch.
     * 
    **/
    where: nft_metadataWhereUniqueInput
  }


  /**
   * nft_metadata base type for findFirst actions
   */
  export type nft_metadataFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the nft_metadata
     * 
    **/
    select?: nft_metadataSelect | null
    /**
     * Filter, which nft_metadata to fetch.
     * 
    **/
    where?: nft_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nft_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<nft_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nft_metadata.
     * 
    **/
    cursor?: nft_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nft_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nft_metadata.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nft_metadata.
     * 
    **/
    distinct?: Enumerable<Nft_metadataScalarFieldEnum>
  }

  /**
   * nft_metadata: findFirst
   */
  export interface nft_metadataFindFirstArgs extends nft_metadataFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * nft_metadata findFirstOrThrow
   */
  export type nft_metadataFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the nft_metadata
     * 
    **/
    select?: nft_metadataSelect | null
    /**
     * Filter, which nft_metadata to fetch.
     * 
    **/
    where?: nft_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nft_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<nft_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for nft_metadata.
     * 
    **/
    cursor?: nft_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nft_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nft_metadata.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of nft_metadata.
     * 
    **/
    distinct?: Enumerable<Nft_metadataScalarFieldEnum>
  }


  /**
   * nft_metadata findMany
   */
  export type nft_metadataFindManyArgs = {
    /**
     * Select specific fields to fetch from the nft_metadata
     * 
    **/
    select?: nft_metadataSelect | null
    /**
     * Filter, which nft_metadata to fetch.
     * 
    **/
    where?: nft_metadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of nft_metadata to fetch.
     * 
    **/
    orderBy?: Enumerable<nft_metadataOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing nft_metadata.
     * 
    **/
    cursor?: nft_metadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` nft_metadata from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` nft_metadata.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Nft_metadataScalarFieldEnum>
  }


  /**
   * nft_metadata create
   */
  export type nft_metadataCreateArgs = {
    /**
     * Select specific fields to fetch from the nft_metadata
     * 
    **/
    select?: nft_metadataSelect | null
    /**
     * The data needed to create a nft_metadata.
     * 
    **/
    data: XOR<nft_metadataCreateInput, nft_metadataUncheckedCreateInput>
  }


  /**
   * nft_metadata createMany
   */
  export type nft_metadataCreateManyArgs = {
    /**
     * The data used to create many nft_metadata.
     * 
    **/
    data: Enumerable<nft_metadataCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * nft_metadata update
   */
  export type nft_metadataUpdateArgs = {
    /**
     * Select specific fields to fetch from the nft_metadata
     * 
    **/
    select?: nft_metadataSelect | null
    /**
     * The data needed to update a nft_metadata.
     * 
    **/
    data: XOR<nft_metadataUpdateInput, nft_metadataUncheckedUpdateInput>
    /**
     * Choose, which nft_metadata to update.
     * 
    **/
    where: nft_metadataWhereUniqueInput
  }


  /**
   * nft_metadata updateMany
   */
  export type nft_metadataUpdateManyArgs = {
    /**
     * The data used to update nft_metadata.
     * 
    **/
    data: XOR<nft_metadataUpdateManyMutationInput, nft_metadataUncheckedUpdateManyInput>
    /**
     * Filter which nft_metadata to update
     * 
    **/
    where?: nft_metadataWhereInput
  }


  /**
   * nft_metadata upsert
   */
  export type nft_metadataUpsertArgs = {
    /**
     * Select specific fields to fetch from the nft_metadata
     * 
    **/
    select?: nft_metadataSelect | null
    /**
     * The filter to search for the nft_metadata to update in case it exists.
     * 
    **/
    where: nft_metadataWhereUniqueInput
    /**
     * In case the nft_metadata found by the `where` argument doesn't exist, create a new nft_metadata with this data.
     * 
    **/
    create: XOR<nft_metadataCreateInput, nft_metadataUncheckedCreateInput>
    /**
     * In case the nft_metadata was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<nft_metadataUpdateInput, nft_metadataUncheckedUpdateInput>
  }


  /**
   * nft_metadata delete
   */
  export type nft_metadataDeleteArgs = {
    /**
     * Select specific fields to fetch from the nft_metadata
     * 
    **/
    select?: nft_metadataSelect | null
    /**
     * Filter which nft_metadata to delete.
     * 
    **/
    where: nft_metadataWhereUniqueInput
  }


  /**
   * nft_metadata deleteMany
   */
  export type nft_metadataDeleteManyArgs = {
    /**
     * Filter which nft_metadata to delete
     * 
    **/
    where?: nft_metadataWhereInput
  }


  /**
   * nft_metadata without action
   */
  export type nft_metadataArgs = {
    /**
     * Select specific fields to fetch from the nft_metadata
     * 
    **/
    select?: nft_metadataSelect | null
  }



  /**
   * Model pgmigrations
   */


  export type AggregatePgmigrations = {
    _count: PgmigrationsCountAggregateOutputType | null
    _avg: PgmigrationsAvgAggregateOutputType | null
    _sum: PgmigrationsSumAggregateOutputType | null
    _min: PgmigrationsMinAggregateOutputType | null
    _max: PgmigrationsMaxAggregateOutputType | null
  }

  export type PgmigrationsAvgAggregateOutputType = {
    id: number | null
  }

  export type PgmigrationsSumAggregateOutputType = {
    id: number | null
  }

  export type PgmigrationsMinAggregateOutputType = {
    id: number | null
    name: string | null
    run_on: Date | null
  }

  export type PgmigrationsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    run_on: Date | null
  }

  export type PgmigrationsCountAggregateOutputType = {
    id: number
    name: number
    run_on: number
    _all: number
  }


  export type PgmigrationsAvgAggregateInputType = {
    id?: true
  }

  export type PgmigrationsSumAggregateInputType = {
    id?: true
  }

  export type PgmigrationsMinAggregateInputType = {
    id?: true
    name?: true
    run_on?: true
  }

  export type PgmigrationsMaxAggregateInputType = {
    id?: true
    name?: true
    run_on?: true
  }

  export type PgmigrationsCountAggregateInputType = {
    id?: true
    name?: true
    run_on?: true
    _all?: true
  }

  export type PgmigrationsAggregateArgs = {
    /**
     * Filter which pgmigrations to aggregate.
     * 
    **/
    where?: pgmigrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pgmigrations to fetch.
     * 
    **/
    orderBy?: Enumerable<pgmigrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pgmigrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pgmigrations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pgmigrations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pgmigrations
    **/
    _count?: true | PgmigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PgmigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PgmigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PgmigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PgmigrationsMaxAggregateInputType
  }

  export type GetPgmigrationsAggregateType<T extends PgmigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePgmigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePgmigrations[P]>
      : GetScalarType<T[P], AggregatePgmigrations[P]>
  }




  export type PgmigrationsGroupByArgs = {
    where?: pgmigrationsWhereInput
    orderBy?: Enumerable<pgmigrationsOrderByWithAggregationInput>
    by: Array<PgmigrationsScalarFieldEnum>
    having?: pgmigrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PgmigrationsCountAggregateInputType | true
    _avg?: PgmigrationsAvgAggregateInputType
    _sum?: PgmigrationsSumAggregateInputType
    _min?: PgmigrationsMinAggregateInputType
    _max?: PgmigrationsMaxAggregateInputType
  }


  export type PgmigrationsGroupByOutputType = {
    id: number
    name: string
    run_on: Date
    _count: PgmigrationsCountAggregateOutputType | null
    _avg: PgmigrationsAvgAggregateOutputType | null
    _sum: PgmigrationsSumAggregateOutputType | null
    _min: PgmigrationsMinAggregateOutputType | null
    _max: PgmigrationsMaxAggregateOutputType | null
  }

  type GetPgmigrationsGroupByPayload<T extends PgmigrationsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PgmigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PgmigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PgmigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], PgmigrationsGroupByOutputType[P]>
        }
      >
    >


  export type pgmigrationsSelect = {
    id?: boolean
    name?: boolean
    run_on?: boolean
  }


  export type pgmigrationsGetPayload<S extends boolean | null | undefined | pgmigrationsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pgmigrations :
    S extends undefined ? never :
    S extends { include: any } & (pgmigrationsArgs | pgmigrationsFindManyArgs)
    ? pgmigrations 
    : S extends { select: any } & (pgmigrationsArgs | pgmigrationsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof pgmigrations ? pgmigrations[P] : never
  } 
      : pgmigrations


  type pgmigrationsCountArgs = Merge<
    Omit<pgmigrationsFindManyArgs, 'select' | 'include'> & {
      select?: PgmigrationsCountAggregateInputType | true
    }
  >

  export interface pgmigrationsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pgmigrations that matches the filter.
     * @param {pgmigrationsFindUniqueArgs} args - Arguments to find a Pgmigrations
     * @example
     * // Get one Pgmigrations
     * const pgmigrations = await prisma.pgmigrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pgmigrationsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pgmigrationsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pgmigrations'> extends True ? Prisma__pgmigrationsClient<pgmigrationsGetPayload<T>> : Prisma__pgmigrationsClient<pgmigrationsGetPayload<T> | null, null>

    /**
     * Find one Pgmigrations that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pgmigrationsFindUniqueOrThrowArgs} args - Arguments to find a Pgmigrations
     * @example
     * // Get one Pgmigrations
     * const pgmigrations = await prisma.pgmigrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pgmigrationsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pgmigrationsFindUniqueOrThrowArgs>
    ): Prisma__pgmigrationsClient<pgmigrationsGetPayload<T>>

    /**
     * Find the first Pgmigrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pgmigrationsFindFirstArgs} args - Arguments to find a Pgmigrations
     * @example
     * // Get one Pgmigrations
     * const pgmigrations = await prisma.pgmigrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pgmigrationsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pgmigrationsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pgmigrations'> extends True ? Prisma__pgmigrationsClient<pgmigrationsGetPayload<T>> : Prisma__pgmigrationsClient<pgmigrationsGetPayload<T> | null, null>

    /**
     * Find the first Pgmigrations that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pgmigrationsFindFirstOrThrowArgs} args - Arguments to find a Pgmigrations
     * @example
     * // Get one Pgmigrations
     * const pgmigrations = await prisma.pgmigrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pgmigrationsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pgmigrationsFindFirstOrThrowArgs>
    ): Prisma__pgmigrationsClient<pgmigrationsGetPayload<T>>

    /**
     * Find zero or more Pgmigrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pgmigrationsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pgmigrations
     * const pgmigrations = await prisma.pgmigrations.findMany()
     * 
     * // Get first 10 Pgmigrations
     * const pgmigrations = await prisma.pgmigrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pgmigrationsWithIdOnly = await prisma.pgmigrations.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pgmigrationsFindManyArgs>(
      args?: SelectSubset<T, pgmigrationsFindManyArgs>
    ): PrismaPromise<Array<pgmigrationsGetPayload<T>>>

    /**
     * Create a Pgmigrations.
     * @param {pgmigrationsCreateArgs} args - Arguments to create a Pgmigrations.
     * @example
     * // Create one Pgmigrations
     * const Pgmigrations = await prisma.pgmigrations.create({
     *   data: {
     *     // ... data to create a Pgmigrations
     *   }
     * })
     * 
    **/
    create<T extends pgmigrationsCreateArgs>(
      args: SelectSubset<T, pgmigrationsCreateArgs>
    ): Prisma__pgmigrationsClient<pgmigrationsGetPayload<T>>

    /**
     * Create many Pgmigrations.
     *     @param {pgmigrationsCreateManyArgs} args - Arguments to create many Pgmigrations.
     *     @example
     *     // Create many Pgmigrations
     *     const pgmigrations = await prisma.pgmigrations.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pgmigrationsCreateManyArgs>(
      args?: SelectSubset<T, pgmigrationsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pgmigrations.
     * @param {pgmigrationsDeleteArgs} args - Arguments to delete one Pgmigrations.
     * @example
     * // Delete one Pgmigrations
     * const Pgmigrations = await prisma.pgmigrations.delete({
     *   where: {
     *     // ... filter to delete one Pgmigrations
     *   }
     * })
     * 
    **/
    delete<T extends pgmigrationsDeleteArgs>(
      args: SelectSubset<T, pgmigrationsDeleteArgs>
    ): Prisma__pgmigrationsClient<pgmigrationsGetPayload<T>>

    /**
     * Update one Pgmigrations.
     * @param {pgmigrationsUpdateArgs} args - Arguments to update one Pgmigrations.
     * @example
     * // Update one Pgmigrations
     * const pgmigrations = await prisma.pgmigrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pgmigrationsUpdateArgs>(
      args: SelectSubset<T, pgmigrationsUpdateArgs>
    ): Prisma__pgmigrationsClient<pgmigrationsGetPayload<T>>

    /**
     * Delete zero or more Pgmigrations.
     * @param {pgmigrationsDeleteManyArgs} args - Arguments to filter Pgmigrations to delete.
     * @example
     * // Delete a few Pgmigrations
     * const { count } = await prisma.pgmigrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pgmigrationsDeleteManyArgs>(
      args?: SelectSubset<T, pgmigrationsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pgmigrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pgmigrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pgmigrations
     * const pgmigrations = await prisma.pgmigrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pgmigrationsUpdateManyArgs>(
      args: SelectSubset<T, pgmigrationsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pgmigrations.
     * @param {pgmigrationsUpsertArgs} args - Arguments to update or create a Pgmigrations.
     * @example
     * // Update or create a Pgmigrations
     * const pgmigrations = await prisma.pgmigrations.upsert({
     *   create: {
     *     // ... data to create a Pgmigrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pgmigrations we want to update
     *   }
     * })
    **/
    upsert<T extends pgmigrationsUpsertArgs>(
      args: SelectSubset<T, pgmigrationsUpsertArgs>
    ): Prisma__pgmigrationsClient<pgmigrationsGetPayload<T>>

    /**
     * Count the number of Pgmigrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pgmigrationsCountArgs} args - Arguments to filter Pgmigrations to count.
     * @example
     * // Count the number of Pgmigrations
     * const count = await prisma.pgmigrations.count({
     *   where: {
     *     // ... the filter for the Pgmigrations we want to count
     *   }
     * })
    **/
    count<T extends pgmigrationsCountArgs>(
      args?: Subset<T, pgmigrationsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PgmigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pgmigrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PgmigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PgmigrationsAggregateArgs>(args: Subset<T, PgmigrationsAggregateArgs>): PrismaPromise<GetPgmigrationsAggregateType<T>>

    /**
     * Group by Pgmigrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PgmigrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PgmigrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PgmigrationsGroupByArgs['orderBy'] }
        : { orderBy?: PgmigrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PgmigrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPgmigrationsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pgmigrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pgmigrationsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pgmigrations base type for findUnique actions
   */
  export type pgmigrationsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pgmigrations
     * 
    **/
    select?: pgmigrationsSelect | null
    /**
     * Filter, which pgmigrations to fetch.
     * 
    **/
    where: pgmigrationsWhereUniqueInput
  }

  /**
   * pgmigrations: findUnique
   */
  export interface pgmigrationsFindUniqueArgs extends pgmigrationsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pgmigrations findUniqueOrThrow
   */
  export type pgmigrationsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pgmigrations
     * 
    **/
    select?: pgmigrationsSelect | null
    /**
     * Filter, which pgmigrations to fetch.
     * 
    **/
    where: pgmigrationsWhereUniqueInput
  }


  /**
   * pgmigrations base type for findFirst actions
   */
  export type pgmigrationsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pgmigrations
     * 
    **/
    select?: pgmigrationsSelect | null
    /**
     * Filter, which pgmigrations to fetch.
     * 
    **/
    where?: pgmigrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pgmigrations to fetch.
     * 
    **/
    orderBy?: Enumerable<pgmigrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pgmigrations.
     * 
    **/
    cursor?: pgmigrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pgmigrations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pgmigrations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pgmigrations.
     * 
    **/
    distinct?: Enumerable<PgmigrationsScalarFieldEnum>
  }

  /**
   * pgmigrations: findFirst
   */
  export interface pgmigrationsFindFirstArgs extends pgmigrationsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pgmigrations findFirstOrThrow
   */
  export type pgmigrationsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pgmigrations
     * 
    **/
    select?: pgmigrationsSelect | null
    /**
     * Filter, which pgmigrations to fetch.
     * 
    **/
    where?: pgmigrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pgmigrations to fetch.
     * 
    **/
    orderBy?: Enumerable<pgmigrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pgmigrations.
     * 
    **/
    cursor?: pgmigrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pgmigrations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pgmigrations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pgmigrations.
     * 
    **/
    distinct?: Enumerable<PgmigrationsScalarFieldEnum>
  }


  /**
   * pgmigrations findMany
   */
  export type pgmigrationsFindManyArgs = {
    /**
     * Select specific fields to fetch from the pgmigrations
     * 
    **/
    select?: pgmigrationsSelect | null
    /**
     * Filter, which pgmigrations to fetch.
     * 
    **/
    where?: pgmigrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pgmigrations to fetch.
     * 
    **/
    orderBy?: Enumerable<pgmigrationsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pgmigrations.
     * 
    **/
    cursor?: pgmigrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pgmigrations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pgmigrations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PgmigrationsScalarFieldEnum>
  }


  /**
   * pgmigrations create
   */
  export type pgmigrationsCreateArgs = {
    /**
     * Select specific fields to fetch from the pgmigrations
     * 
    **/
    select?: pgmigrationsSelect | null
    /**
     * The data needed to create a pgmigrations.
     * 
    **/
    data: XOR<pgmigrationsCreateInput, pgmigrationsUncheckedCreateInput>
  }


  /**
   * pgmigrations createMany
   */
  export type pgmigrationsCreateManyArgs = {
    /**
     * The data used to create many pgmigrations.
     * 
    **/
    data: Enumerable<pgmigrationsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pgmigrations update
   */
  export type pgmigrationsUpdateArgs = {
    /**
     * Select specific fields to fetch from the pgmigrations
     * 
    **/
    select?: pgmigrationsSelect | null
    /**
     * The data needed to update a pgmigrations.
     * 
    **/
    data: XOR<pgmigrationsUpdateInput, pgmigrationsUncheckedUpdateInput>
    /**
     * Choose, which pgmigrations to update.
     * 
    **/
    where: pgmigrationsWhereUniqueInput
  }


  /**
   * pgmigrations updateMany
   */
  export type pgmigrationsUpdateManyArgs = {
    /**
     * The data used to update pgmigrations.
     * 
    **/
    data: XOR<pgmigrationsUpdateManyMutationInput, pgmigrationsUncheckedUpdateManyInput>
    /**
     * Filter which pgmigrations to update
     * 
    **/
    where?: pgmigrationsWhereInput
  }


  /**
   * pgmigrations upsert
   */
  export type pgmigrationsUpsertArgs = {
    /**
     * Select specific fields to fetch from the pgmigrations
     * 
    **/
    select?: pgmigrationsSelect | null
    /**
     * The filter to search for the pgmigrations to update in case it exists.
     * 
    **/
    where: pgmigrationsWhereUniqueInput
    /**
     * In case the pgmigrations found by the `where` argument doesn't exist, create a new pgmigrations with this data.
     * 
    **/
    create: XOR<pgmigrationsCreateInput, pgmigrationsUncheckedCreateInput>
    /**
     * In case the pgmigrations was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pgmigrationsUpdateInput, pgmigrationsUncheckedUpdateInput>
  }


  /**
   * pgmigrations delete
   */
  export type pgmigrationsDeleteArgs = {
    /**
     * Select specific fields to fetch from the pgmigrations
     * 
    **/
    select?: pgmigrationsSelect | null
    /**
     * Filter which pgmigrations to delete.
     * 
    **/
    where: pgmigrationsWhereUniqueInput
  }


  /**
   * pgmigrations deleteMany
   */
  export type pgmigrationsDeleteManyArgs = {
    /**
     * Filter which pgmigrations to delete
     * 
    **/
    where?: pgmigrationsWhereInput
  }


  /**
   * pgmigrations without action
   */
  export type pgmigrationsArgs = {
    /**
     * Select specific fields to fetch from the pgmigrations
     * 
    **/
    select?: pgmigrationsSelect | null
  }



  /**
   * Model pox2_events
   */


  export type AggregatePox2_events = {
    _count: Pox2_eventsCountAggregateOutputType | null
    _avg: Pox2_eventsAvgAggregateOutputType | null
    _sum: Pox2_eventsSumAggregateOutputType | null
    _min: Pox2_eventsMinAggregateOutputType | null
    _max: Pox2_eventsMaxAggregateOutputType | null
  }

  export type Pox2_eventsAvgAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
    locked: Decimal | null
    balance: Decimal | null
    burnchain_unlock_height: number | null
    first_cycle_locked: Decimal | null
    first_unlocked_cycle: Decimal | null
    lock_period: Decimal | null
    lock_amount: Decimal | null
    start_burn_height: Decimal | null
    unlock_burn_height: Decimal | null
    increase_by: Decimal | null
    total_locked: Decimal | null
    extend_count: Decimal | null
    reward_cycle: Decimal | null
    amount_ustx: Decimal | null
  }

  export type Pox2_eventsSumAggregateOutputType = {
    id: bigint | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
    locked: Decimal | null
    balance: Decimal | null
    burnchain_unlock_height: bigint | null
    first_cycle_locked: Decimal | null
    first_unlocked_cycle: Decimal | null
    lock_period: Decimal | null
    lock_amount: Decimal | null
    start_burn_height: Decimal | null
    unlock_burn_height: Decimal | null
    increase_by: Decimal | null
    total_locked: Decimal | null
    extend_count: Decimal | null
    reward_cycle: Decimal | null
    amount_ustx: Decimal | null
  }

  export type Pox2_eventsMinAggregateOutputType = {
    id: bigint | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    stacker: string | null
    locked: Decimal | null
    balance: Decimal | null
    burnchain_unlock_height: bigint | null
    name: string | null
    pox_addr: string | null
    pox_addr_raw: Buffer | null
    first_cycle_locked: Decimal | null
    first_unlocked_cycle: Decimal | null
    lock_period: Decimal | null
    lock_amount: Decimal | null
    start_burn_height: Decimal | null
    unlock_burn_height: Decimal | null
    delegator: string | null
    increase_by: Decimal | null
    total_locked: Decimal | null
    extend_count: Decimal | null
    reward_cycle: Decimal | null
    amount_ustx: Decimal | null
  }

  export type Pox2_eventsMaxAggregateOutputType = {
    id: bigint | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    stacker: string | null
    locked: Decimal | null
    balance: Decimal | null
    burnchain_unlock_height: bigint | null
    name: string | null
    pox_addr: string | null
    pox_addr_raw: Buffer | null
    first_cycle_locked: Decimal | null
    first_unlocked_cycle: Decimal | null
    lock_period: Decimal | null
    lock_amount: Decimal | null
    start_burn_height: Decimal | null
    unlock_burn_height: Decimal | null
    delegator: string | null
    increase_by: Decimal | null
    total_locked: Decimal | null
    extend_count: Decimal | null
    reward_cycle: Decimal | null
    amount_ustx: Decimal | null
  }

  export type Pox2_eventsCountAggregateOutputType = {
    id: number
    event_index: number
    tx_id: number
    tx_index: number
    block_height: number
    index_block_hash: number
    parent_index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    microblock_canonical: number
    canonical: number
    stacker: number
    locked: number
    balance: number
    burnchain_unlock_height: number
    name: number
    pox_addr: number
    pox_addr_raw: number
    first_cycle_locked: number
    first_unlocked_cycle: number
    lock_period: number
    lock_amount: number
    start_burn_height: number
    unlock_burn_height: number
    delegator: number
    increase_by: number
    total_locked: number
    extend_count: number
    reward_cycle: number
    amount_ustx: number
    _all: number
  }


  export type Pox2_eventsAvgAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
    locked?: true
    balance?: true
    burnchain_unlock_height?: true
    first_cycle_locked?: true
    first_unlocked_cycle?: true
    lock_period?: true
    lock_amount?: true
    start_burn_height?: true
    unlock_burn_height?: true
    increase_by?: true
    total_locked?: true
    extend_count?: true
    reward_cycle?: true
    amount_ustx?: true
  }

  export type Pox2_eventsSumAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
    locked?: true
    balance?: true
    burnchain_unlock_height?: true
    first_cycle_locked?: true
    first_unlocked_cycle?: true
    lock_period?: true
    lock_amount?: true
    start_burn_height?: true
    unlock_burn_height?: true
    increase_by?: true
    total_locked?: true
    extend_count?: true
    reward_cycle?: true
    amount_ustx?: true
  }

  export type Pox2_eventsMinAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    stacker?: true
    locked?: true
    balance?: true
    burnchain_unlock_height?: true
    name?: true
    pox_addr?: true
    pox_addr_raw?: true
    first_cycle_locked?: true
    first_unlocked_cycle?: true
    lock_period?: true
    lock_amount?: true
    start_burn_height?: true
    unlock_burn_height?: true
    delegator?: true
    increase_by?: true
    total_locked?: true
    extend_count?: true
    reward_cycle?: true
    amount_ustx?: true
  }

  export type Pox2_eventsMaxAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    stacker?: true
    locked?: true
    balance?: true
    burnchain_unlock_height?: true
    name?: true
    pox_addr?: true
    pox_addr_raw?: true
    first_cycle_locked?: true
    first_unlocked_cycle?: true
    lock_period?: true
    lock_amount?: true
    start_burn_height?: true
    unlock_burn_height?: true
    delegator?: true
    increase_by?: true
    total_locked?: true
    extend_count?: true
    reward_cycle?: true
    amount_ustx?: true
  }

  export type Pox2_eventsCountAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    stacker?: true
    locked?: true
    balance?: true
    burnchain_unlock_height?: true
    name?: true
    pox_addr?: true
    pox_addr_raw?: true
    first_cycle_locked?: true
    first_unlocked_cycle?: true
    lock_period?: true
    lock_amount?: true
    start_burn_height?: true
    unlock_burn_height?: true
    delegator?: true
    increase_by?: true
    total_locked?: true
    extend_count?: true
    reward_cycle?: true
    amount_ustx?: true
    _all?: true
  }

  export type Pox2_eventsAggregateArgs = {
    /**
     * Filter which pox2_events to aggregate.
     * 
    **/
    where?: pox2_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pox2_events to fetch.
     * 
    **/
    orderBy?: Enumerable<pox2_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pox2_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pox2_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pox2_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pox2_events
    **/
    _count?: true | Pox2_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pox2_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pox2_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pox2_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pox2_eventsMaxAggregateInputType
  }

  export type GetPox2_eventsAggregateType<T extends Pox2_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregatePox2_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePox2_events[P]>
      : GetScalarType<T[P], AggregatePox2_events[P]>
  }




  export type Pox2_eventsGroupByArgs = {
    where?: pox2_eventsWhereInput
    orderBy?: Enumerable<pox2_eventsOrderByWithAggregationInput>
    by: Array<Pox2_eventsScalarFieldEnum>
    having?: pox2_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pox2_eventsCountAggregateInputType | true
    _avg?: Pox2_eventsAvgAggregateInputType
    _sum?: Pox2_eventsSumAggregateInputType
    _min?: Pox2_eventsMinAggregateInputType
    _max?: Pox2_eventsMaxAggregateInputType
  }


  export type Pox2_eventsGroupByOutputType = {
    id: bigint
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    stacker: string
    locked: Decimal
    balance: Decimal
    burnchain_unlock_height: bigint
    name: string
    pox_addr: string | null
    pox_addr_raw: Buffer | null
    first_cycle_locked: Decimal | null
    first_unlocked_cycle: Decimal | null
    lock_period: Decimal | null
    lock_amount: Decimal | null
    start_burn_height: Decimal | null
    unlock_burn_height: Decimal | null
    delegator: string | null
    increase_by: Decimal | null
    total_locked: Decimal | null
    extend_count: Decimal | null
    reward_cycle: Decimal | null
    amount_ustx: Decimal | null
    _count: Pox2_eventsCountAggregateOutputType | null
    _avg: Pox2_eventsAvgAggregateOutputType | null
    _sum: Pox2_eventsSumAggregateOutputType | null
    _min: Pox2_eventsMinAggregateOutputType | null
    _max: Pox2_eventsMaxAggregateOutputType | null
  }

  type GetPox2_eventsGroupByPayload<T extends Pox2_eventsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Pox2_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pox2_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pox2_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Pox2_eventsGroupByOutputType[P]>
        }
      >
    >


  export type pox2_eventsSelect = {
    id?: boolean
    event_index?: boolean
    tx_id?: boolean
    tx_index?: boolean
    block_height?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_canonical?: boolean
    canonical?: boolean
    stacker?: boolean
    locked?: boolean
    balance?: boolean
    burnchain_unlock_height?: boolean
    name?: boolean
    pox_addr?: boolean
    pox_addr_raw?: boolean
    first_cycle_locked?: boolean
    first_unlocked_cycle?: boolean
    lock_period?: boolean
    lock_amount?: boolean
    start_burn_height?: boolean
    unlock_burn_height?: boolean
    delegator?: boolean
    increase_by?: boolean
    total_locked?: boolean
    extend_count?: boolean
    reward_cycle?: boolean
    amount_ustx?: boolean
  }


  export type pox2_eventsGetPayload<S extends boolean | null | undefined | pox2_eventsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pox2_events :
    S extends undefined ? never :
    S extends { include: any } & (pox2_eventsArgs | pox2_eventsFindManyArgs)
    ? pox2_events 
    : S extends { select: any } & (pox2_eventsArgs | pox2_eventsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof pox2_events ? pox2_events[P] : never
  } 
      : pox2_events


  type pox2_eventsCountArgs = Merge<
    Omit<pox2_eventsFindManyArgs, 'select' | 'include'> & {
      select?: Pox2_eventsCountAggregateInputType | true
    }
  >

  export interface pox2_eventsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pox2_events that matches the filter.
     * @param {pox2_eventsFindUniqueArgs} args - Arguments to find a Pox2_events
     * @example
     * // Get one Pox2_events
     * const pox2_events = await prisma.pox2_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pox2_eventsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pox2_eventsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pox2_events'> extends True ? Prisma__pox2_eventsClient<pox2_eventsGetPayload<T>> : Prisma__pox2_eventsClient<pox2_eventsGetPayload<T> | null, null>

    /**
     * Find one Pox2_events that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pox2_eventsFindUniqueOrThrowArgs} args - Arguments to find a Pox2_events
     * @example
     * // Get one Pox2_events
     * const pox2_events = await prisma.pox2_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pox2_eventsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pox2_eventsFindUniqueOrThrowArgs>
    ): Prisma__pox2_eventsClient<pox2_eventsGetPayload<T>>

    /**
     * Find the first Pox2_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pox2_eventsFindFirstArgs} args - Arguments to find a Pox2_events
     * @example
     * // Get one Pox2_events
     * const pox2_events = await prisma.pox2_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pox2_eventsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pox2_eventsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pox2_events'> extends True ? Prisma__pox2_eventsClient<pox2_eventsGetPayload<T>> : Prisma__pox2_eventsClient<pox2_eventsGetPayload<T> | null, null>

    /**
     * Find the first Pox2_events that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pox2_eventsFindFirstOrThrowArgs} args - Arguments to find a Pox2_events
     * @example
     * // Get one Pox2_events
     * const pox2_events = await prisma.pox2_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pox2_eventsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pox2_eventsFindFirstOrThrowArgs>
    ): Prisma__pox2_eventsClient<pox2_eventsGetPayload<T>>

    /**
     * Find zero or more Pox2_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pox2_eventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pox2_events
     * const pox2_events = await prisma.pox2_events.findMany()
     * 
     * // Get first 10 Pox2_events
     * const pox2_events = await prisma.pox2_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pox2_eventsWithIdOnly = await prisma.pox2_events.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pox2_eventsFindManyArgs>(
      args?: SelectSubset<T, pox2_eventsFindManyArgs>
    ): PrismaPromise<Array<pox2_eventsGetPayload<T>>>

    /**
     * Create a Pox2_events.
     * @param {pox2_eventsCreateArgs} args - Arguments to create a Pox2_events.
     * @example
     * // Create one Pox2_events
     * const Pox2_events = await prisma.pox2_events.create({
     *   data: {
     *     // ... data to create a Pox2_events
     *   }
     * })
     * 
    **/
    create<T extends pox2_eventsCreateArgs>(
      args: SelectSubset<T, pox2_eventsCreateArgs>
    ): Prisma__pox2_eventsClient<pox2_eventsGetPayload<T>>

    /**
     * Create many Pox2_events.
     *     @param {pox2_eventsCreateManyArgs} args - Arguments to create many Pox2_events.
     *     @example
     *     // Create many Pox2_events
     *     const pox2_events = await prisma.pox2_events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pox2_eventsCreateManyArgs>(
      args?: SelectSubset<T, pox2_eventsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pox2_events.
     * @param {pox2_eventsDeleteArgs} args - Arguments to delete one Pox2_events.
     * @example
     * // Delete one Pox2_events
     * const Pox2_events = await prisma.pox2_events.delete({
     *   where: {
     *     // ... filter to delete one Pox2_events
     *   }
     * })
     * 
    **/
    delete<T extends pox2_eventsDeleteArgs>(
      args: SelectSubset<T, pox2_eventsDeleteArgs>
    ): Prisma__pox2_eventsClient<pox2_eventsGetPayload<T>>

    /**
     * Update one Pox2_events.
     * @param {pox2_eventsUpdateArgs} args - Arguments to update one Pox2_events.
     * @example
     * // Update one Pox2_events
     * const pox2_events = await prisma.pox2_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pox2_eventsUpdateArgs>(
      args: SelectSubset<T, pox2_eventsUpdateArgs>
    ): Prisma__pox2_eventsClient<pox2_eventsGetPayload<T>>

    /**
     * Delete zero or more Pox2_events.
     * @param {pox2_eventsDeleteManyArgs} args - Arguments to filter Pox2_events to delete.
     * @example
     * // Delete a few Pox2_events
     * const { count } = await prisma.pox2_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pox2_eventsDeleteManyArgs>(
      args?: SelectSubset<T, pox2_eventsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pox2_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pox2_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pox2_events
     * const pox2_events = await prisma.pox2_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pox2_eventsUpdateManyArgs>(
      args: SelectSubset<T, pox2_eventsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pox2_events.
     * @param {pox2_eventsUpsertArgs} args - Arguments to update or create a Pox2_events.
     * @example
     * // Update or create a Pox2_events
     * const pox2_events = await prisma.pox2_events.upsert({
     *   create: {
     *     // ... data to create a Pox2_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pox2_events we want to update
     *   }
     * })
    **/
    upsert<T extends pox2_eventsUpsertArgs>(
      args: SelectSubset<T, pox2_eventsUpsertArgs>
    ): Prisma__pox2_eventsClient<pox2_eventsGetPayload<T>>

    /**
     * Count the number of Pox2_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pox2_eventsCountArgs} args - Arguments to filter Pox2_events to count.
     * @example
     * // Count the number of Pox2_events
     * const count = await prisma.pox2_events.count({
     *   where: {
     *     // ... the filter for the Pox2_events we want to count
     *   }
     * })
    **/
    count<T extends pox2_eventsCountArgs>(
      args?: Subset<T, pox2_eventsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pox2_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pox2_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pox2_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pox2_eventsAggregateArgs>(args: Subset<T, Pox2_eventsAggregateArgs>): PrismaPromise<GetPox2_eventsAggregateType<T>>

    /**
     * Group by Pox2_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pox2_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Pox2_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Pox2_eventsGroupByArgs['orderBy'] }
        : { orderBy?: Pox2_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Pox2_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPox2_eventsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pox2_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pox2_eventsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pox2_events base type for findUnique actions
   */
  export type pox2_eventsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pox2_events
     * 
    **/
    select?: pox2_eventsSelect | null
    /**
     * Filter, which pox2_events to fetch.
     * 
    **/
    where: pox2_eventsWhereUniqueInput
  }

  /**
   * pox2_events: findUnique
   */
  export interface pox2_eventsFindUniqueArgs extends pox2_eventsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pox2_events findUniqueOrThrow
   */
  export type pox2_eventsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pox2_events
     * 
    **/
    select?: pox2_eventsSelect | null
    /**
     * Filter, which pox2_events to fetch.
     * 
    **/
    where: pox2_eventsWhereUniqueInput
  }


  /**
   * pox2_events base type for findFirst actions
   */
  export type pox2_eventsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pox2_events
     * 
    **/
    select?: pox2_eventsSelect | null
    /**
     * Filter, which pox2_events to fetch.
     * 
    **/
    where?: pox2_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pox2_events to fetch.
     * 
    **/
    orderBy?: Enumerable<pox2_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pox2_events.
     * 
    **/
    cursor?: pox2_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pox2_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pox2_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pox2_events.
     * 
    **/
    distinct?: Enumerable<Pox2_eventsScalarFieldEnum>
  }

  /**
   * pox2_events: findFirst
   */
  export interface pox2_eventsFindFirstArgs extends pox2_eventsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pox2_events findFirstOrThrow
   */
  export type pox2_eventsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pox2_events
     * 
    **/
    select?: pox2_eventsSelect | null
    /**
     * Filter, which pox2_events to fetch.
     * 
    **/
    where?: pox2_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pox2_events to fetch.
     * 
    **/
    orderBy?: Enumerable<pox2_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pox2_events.
     * 
    **/
    cursor?: pox2_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pox2_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pox2_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pox2_events.
     * 
    **/
    distinct?: Enumerable<Pox2_eventsScalarFieldEnum>
  }


  /**
   * pox2_events findMany
   */
  export type pox2_eventsFindManyArgs = {
    /**
     * Select specific fields to fetch from the pox2_events
     * 
    **/
    select?: pox2_eventsSelect | null
    /**
     * Filter, which pox2_events to fetch.
     * 
    **/
    where?: pox2_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pox2_events to fetch.
     * 
    **/
    orderBy?: Enumerable<pox2_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pox2_events.
     * 
    **/
    cursor?: pox2_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pox2_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pox2_events.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Pox2_eventsScalarFieldEnum>
  }


  /**
   * pox2_events create
   */
  export type pox2_eventsCreateArgs = {
    /**
     * Select specific fields to fetch from the pox2_events
     * 
    **/
    select?: pox2_eventsSelect | null
    /**
     * The data needed to create a pox2_events.
     * 
    **/
    data: XOR<pox2_eventsCreateInput, pox2_eventsUncheckedCreateInput>
  }


  /**
   * pox2_events createMany
   */
  export type pox2_eventsCreateManyArgs = {
    /**
     * The data used to create many pox2_events.
     * 
    **/
    data: Enumerable<pox2_eventsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pox2_events update
   */
  export type pox2_eventsUpdateArgs = {
    /**
     * Select specific fields to fetch from the pox2_events
     * 
    **/
    select?: pox2_eventsSelect | null
    /**
     * The data needed to update a pox2_events.
     * 
    **/
    data: XOR<pox2_eventsUpdateInput, pox2_eventsUncheckedUpdateInput>
    /**
     * Choose, which pox2_events to update.
     * 
    **/
    where: pox2_eventsWhereUniqueInput
  }


  /**
   * pox2_events updateMany
   */
  export type pox2_eventsUpdateManyArgs = {
    /**
     * The data used to update pox2_events.
     * 
    **/
    data: XOR<pox2_eventsUpdateManyMutationInput, pox2_eventsUncheckedUpdateManyInput>
    /**
     * Filter which pox2_events to update
     * 
    **/
    where?: pox2_eventsWhereInput
  }


  /**
   * pox2_events upsert
   */
  export type pox2_eventsUpsertArgs = {
    /**
     * Select specific fields to fetch from the pox2_events
     * 
    **/
    select?: pox2_eventsSelect | null
    /**
     * The filter to search for the pox2_events to update in case it exists.
     * 
    **/
    where: pox2_eventsWhereUniqueInput
    /**
     * In case the pox2_events found by the `where` argument doesn't exist, create a new pox2_events with this data.
     * 
    **/
    create: XOR<pox2_eventsCreateInput, pox2_eventsUncheckedCreateInput>
    /**
     * In case the pox2_events was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pox2_eventsUpdateInput, pox2_eventsUncheckedUpdateInput>
  }


  /**
   * pox2_events delete
   */
  export type pox2_eventsDeleteArgs = {
    /**
     * Select specific fields to fetch from the pox2_events
     * 
    **/
    select?: pox2_eventsSelect | null
    /**
     * Filter which pox2_events to delete.
     * 
    **/
    where: pox2_eventsWhereUniqueInput
  }


  /**
   * pox2_events deleteMany
   */
  export type pox2_eventsDeleteManyArgs = {
    /**
     * Filter which pox2_events to delete
     * 
    **/
    where?: pox2_eventsWhereInput
  }


  /**
   * pox2_events without action
   */
  export type pox2_eventsArgs = {
    /**
     * Select specific fields to fetch from the pox2_events
     * 
    **/
    select?: pox2_eventsSelect | null
  }



  /**
   * Model pox_state
   */


  export type AggregatePox_state = {
    _count: Pox_stateCountAggregateOutputType | null
    _avg: Pox_stateAvgAggregateOutputType | null
    _sum: Pox_stateSumAggregateOutputType | null
    _min: Pox_stateMinAggregateOutputType | null
    _max: Pox_stateMaxAggregateOutputType | null
  }

  export type Pox_stateAvgAggregateOutputType = {
    pox_v1_unlock_height: number | null
  }

  export type Pox_stateSumAggregateOutputType = {
    pox_v1_unlock_height: number | null
  }

  export type Pox_stateMinAggregateOutputType = {
    id: boolean | null
    pox_v1_unlock_height: number | null
  }

  export type Pox_stateMaxAggregateOutputType = {
    id: boolean | null
    pox_v1_unlock_height: number | null
  }

  export type Pox_stateCountAggregateOutputType = {
    id: number
    pox_v1_unlock_height: number
    _all: number
  }


  export type Pox_stateAvgAggregateInputType = {
    pox_v1_unlock_height?: true
  }

  export type Pox_stateSumAggregateInputType = {
    pox_v1_unlock_height?: true
  }

  export type Pox_stateMinAggregateInputType = {
    id?: true
    pox_v1_unlock_height?: true
  }

  export type Pox_stateMaxAggregateInputType = {
    id?: true
    pox_v1_unlock_height?: true
  }

  export type Pox_stateCountAggregateInputType = {
    id?: true
    pox_v1_unlock_height?: true
    _all?: true
  }

  export type Pox_stateAggregateArgs = {
    /**
     * Filter which pox_state to aggregate.
     * 
    **/
    where?: pox_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pox_states to fetch.
     * 
    **/
    orderBy?: Enumerable<pox_stateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: pox_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pox_states from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pox_states.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned pox_states
    **/
    _count?: true | Pox_stateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Pox_stateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Pox_stateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Pox_stateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Pox_stateMaxAggregateInputType
  }

  export type GetPox_stateAggregateType<T extends Pox_stateAggregateArgs> = {
        [P in keyof T & keyof AggregatePox_state]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePox_state[P]>
      : GetScalarType<T[P], AggregatePox_state[P]>
  }




  export type Pox_stateGroupByArgs = {
    where?: pox_stateWhereInput
    orderBy?: Enumerable<pox_stateOrderByWithAggregationInput>
    by: Array<Pox_stateScalarFieldEnum>
    having?: pox_stateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Pox_stateCountAggregateInputType | true
    _avg?: Pox_stateAvgAggregateInputType
    _sum?: Pox_stateSumAggregateInputType
    _min?: Pox_stateMinAggregateInputType
    _max?: Pox_stateMaxAggregateInputType
  }


  export type Pox_stateGroupByOutputType = {
    id: boolean
    pox_v1_unlock_height: number
    _count: Pox_stateCountAggregateOutputType | null
    _avg: Pox_stateAvgAggregateOutputType | null
    _sum: Pox_stateSumAggregateOutputType | null
    _min: Pox_stateMinAggregateOutputType | null
    _max: Pox_stateMaxAggregateOutputType | null
  }

  type GetPox_stateGroupByPayload<T extends Pox_stateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Pox_stateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Pox_stateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Pox_stateGroupByOutputType[P]>
            : GetScalarType<T[P], Pox_stateGroupByOutputType[P]>
        }
      >
    >


  export type pox_stateSelect = {
    id?: boolean
    pox_v1_unlock_height?: boolean
  }


  export type pox_stateGetPayload<S extends boolean | null | undefined | pox_stateArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? pox_state :
    S extends undefined ? never :
    S extends { include: any } & (pox_stateArgs | pox_stateFindManyArgs)
    ? pox_state 
    : S extends { select: any } & (pox_stateArgs | pox_stateFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof pox_state ? pox_state[P] : never
  } 
      : pox_state


  type pox_stateCountArgs = Merge<
    Omit<pox_stateFindManyArgs, 'select' | 'include'> & {
      select?: Pox_stateCountAggregateInputType | true
    }
  >

  export interface pox_stateDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Pox_state that matches the filter.
     * @param {pox_stateFindUniqueArgs} args - Arguments to find a Pox_state
     * @example
     * // Get one Pox_state
     * const pox_state = await prisma.pox_state.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends pox_stateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, pox_stateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'pox_state'> extends True ? Prisma__pox_stateClient<pox_stateGetPayload<T>> : Prisma__pox_stateClient<pox_stateGetPayload<T> | null, null>

    /**
     * Find one Pox_state that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {pox_stateFindUniqueOrThrowArgs} args - Arguments to find a Pox_state
     * @example
     * // Get one Pox_state
     * const pox_state = await prisma.pox_state.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends pox_stateFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, pox_stateFindUniqueOrThrowArgs>
    ): Prisma__pox_stateClient<pox_stateGetPayload<T>>

    /**
     * Find the first Pox_state that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pox_stateFindFirstArgs} args - Arguments to find a Pox_state
     * @example
     * // Get one Pox_state
     * const pox_state = await prisma.pox_state.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends pox_stateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, pox_stateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'pox_state'> extends True ? Prisma__pox_stateClient<pox_stateGetPayload<T>> : Prisma__pox_stateClient<pox_stateGetPayload<T> | null, null>

    /**
     * Find the first Pox_state that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pox_stateFindFirstOrThrowArgs} args - Arguments to find a Pox_state
     * @example
     * // Get one Pox_state
     * const pox_state = await prisma.pox_state.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends pox_stateFindFirstOrThrowArgs>(
      args?: SelectSubset<T, pox_stateFindFirstOrThrowArgs>
    ): Prisma__pox_stateClient<pox_stateGetPayload<T>>

    /**
     * Find zero or more Pox_states that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pox_stateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pox_states
     * const pox_states = await prisma.pox_state.findMany()
     * 
     * // Get first 10 Pox_states
     * const pox_states = await prisma.pox_state.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pox_stateWithIdOnly = await prisma.pox_state.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends pox_stateFindManyArgs>(
      args?: SelectSubset<T, pox_stateFindManyArgs>
    ): PrismaPromise<Array<pox_stateGetPayload<T>>>

    /**
     * Create a Pox_state.
     * @param {pox_stateCreateArgs} args - Arguments to create a Pox_state.
     * @example
     * // Create one Pox_state
     * const Pox_state = await prisma.pox_state.create({
     *   data: {
     *     // ... data to create a Pox_state
     *   }
     * })
     * 
    **/
    create<T extends pox_stateCreateArgs>(
      args: SelectSubset<T, pox_stateCreateArgs>
    ): Prisma__pox_stateClient<pox_stateGetPayload<T>>

    /**
     * Create many Pox_states.
     *     @param {pox_stateCreateManyArgs} args - Arguments to create many Pox_states.
     *     @example
     *     // Create many Pox_states
     *     const pox_state = await prisma.pox_state.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends pox_stateCreateManyArgs>(
      args?: SelectSubset<T, pox_stateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Pox_state.
     * @param {pox_stateDeleteArgs} args - Arguments to delete one Pox_state.
     * @example
     * // Delete one Pox_state
     * const Pox_state = await prisma.pox_state.delete({
     *   where: {
     *     // ... filter to delete one Pox_state
     *   }
     * })
     * 
    **/
    delete<T extends pox_stateDeleteArgs>(
      args: SelectSubset<T, pox_stateDeleteArgs>
    ): Prisma__pox_stateClient<pox_stateGetPayload<T>>

    /**
     * Update one Pox_state.
     * @param {pox_stateUpdateArgs} args - Arguments to update one Pox_state.
     * @example
     * // Update one Pox_state
     * const pox_state = await prisma.pox_state.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends pox_stateUpdateArgs>(
      args: SelectSubset<T, pox_stateUpdateArgs>
    ): Prisma__pox_stateClient<pox_stateGetPayload<T>>

    /**
     * Delete zero or more Pox_states.
     * @param {pox_stateDeleteManyArgs} args - Arguments to filter Pox_states to delete.
     * @example
     * // Delete a few Pox_states
     * const { count } = await prisma.pox_state.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends pox_stateDeleteManyArgs>(
      args?: SelectSubset<T, pox_stateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pox_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pox_stateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pox_states
     * const pox_state = await prisma.pox_state.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends pox_stateUpdateManyArgs>(
      args: SelectSubset<T, pox_stateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pox_state.
     * @param {pox_stateUpsertArgs} args - Arguments to update or create a Pox_state.
     * @example
     * // Update or create a Pox_state
     * const pox_state = await prisma.pox_state.upsert({
     *   create: {
     *     // ... data to create a Pox_state
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pox_state we want to update
     *   }
     * })
    **/
    upsert<T extends pox_stateUpsertArgs>(
      args: SelectSubset<T, pox_stateUpsertArgs>
    ): Prisma__pox_stateClient<pox_stateGetPayload<T>>

    /**
     * Count the number of Pox_states.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {pox_stateCountArgs} args - Arguments to filter Pox_states to count.
     * @example
     * // Count the number of Pox_states
     * const count = await prisma.pox_state.count({
     *   where: {
     *     // ... the filter for the Pox_states we want to count
     *   }
     * })
    **/
    count<T extends pox_stateCountArgs>(
      args?: Subset<T, pox_stateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Pox_stateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pox_state.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pox_stateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Pox_stateAggregateArgs>(args: Subset<T, Pox_stateAggregateArgs>): PrismaPromise<GetPox_stateAggregateType<T>>

    /**
     * Group by Pox_state.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Pox_stateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Pox_stateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Pox_stateGroupByArgs['orderBy'] }
        : { orderBy?: Pox_stateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Pox_stateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPox_stateGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for pox_state.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__pox_stateClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * pox_state base type for findUnique actions
   */
  export type pox_stateFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the pox_state
     * 
    **/
    select?: pox_stateSelect | null
    /**
     * Filter, which pox_state to fetch.
     * 
    **/
    where: pox_stateWhereUniqueInput
  }

  /**
   * pox_state: findUnique
   */
  export interface pox_stateFindUniqueArgs extends pox_stateFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pox_state findUniqueOrThrow
   */
  export type pox_stateFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pox_state
     * 
    **/
    select?: pox_stateSelect | null
    /**
     * Filter, which pox_state to fetch.
     * 
    **/
    where: pox_stateWhereUniqueInput
  }


  /**
   * pox_state base type for findFirst actions
   */
  export type pox_stateFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the pox_state
     * 
    **/
    select?: pox_stateSelect | null
    /**
     * Filter, which pox_state to fetch.
     * 
    **/
    where?: pox_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pox_states to fetch.
     * 
    **/
    orderBy?: Enumerable<pox_stateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pox_states.
     * 
    **/
    cursor?: pox_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pox_states from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pox_states.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pox_states.
     * 
    **/
    distinct?: Enumerable<Pox_stateScalarFieldEnum>
  }

  /**
   * pox_state: findFirst
   */
  export interface pox_stateFindFirstArgs extends pox_stateFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * pox_state findFirstOrThrow
   */
  export type pox_stateFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the pox_state
     * 
    **/
    select?: pox_stateSelect | null
    /**
     * Filter, which pox_state to fetch.
     * 
    **/
    where?: pox_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pox_states to fetch.
     * 
    **/
    orderBy?: Enumerable<pox_stateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for pox_states.
     * 
    **/
    cursor?: pox_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pox_states from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pox_states.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of pox_states.
     * 
    **/
    distinct?: Enumerable<Pox_stateScalarFieldEnum>
  }


  /**
   * pox_state findMany
   */
  export type pox_stateFindManyArgs = {
    /**
     * Select specific fields to fetch from the pox_state
     * 
    **/
    select?: pox_stateSelect | null
    /**
     * Filter, which pox_states to fetch.
     * 
    **/
    where?: pox_stateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of pox_states to fetch.
     * 
    **/
    orderBy?: Enumerable<pox_stateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing pox_states.
     * 
    **/
    cursor?: pox_stateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` pox_states from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` pox_states.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Pox_stateScalarFieldEnum>
  }


  /**
   * pox_state create
   */
  export type pox_stateCreateArgs = {
    /**
     * Select specific fields to fetch from the pox_state
     * 
    **/
    select?: pox_stateSelect | null
    /**
     * The data needed to create a pox_state.
     * 
    **/
    data: XOR<pox_stateCreateInput, pox_stateUncheckedCreateInput>
  }


  /**
   * pox_state createMany
   */
  export type pox_stateCreateManyArgs = {
    /**
     * The data used to create many pox_states.
     * 
    **/
    data: Enumerable<pox_stateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * pox_state update
   */
  export type pox_stateUpdateArgs = {
    /**
     * Select specific fields to fetch from the pox_state
     * 
    **/
    select?: pox_stateSelect | null
    /**
     * The data needed to update a pox_state.
     * 
    **/
    data: XOR<pox_stateUpdateInput, pox_stateUncheckedUpdateInput>
    /**
     * Choose, which pox_state to update.
     * 
    **/
    where: pox_stateWhereUniqueInput
  }


  /**
   * pox_state updateMany
   */
  export type pox_stateUpdateManyArgs = {
    /**
     * The data used to update pox_states.
     * 
    **/
    data: XOR<pox_stateUpdateManyMutationInput, pox_stateUncheckedUpdateManyInput>
    /**
     * Filter which pox_states to update
     * 
    **/
    where?: pox_stateWhereInput
  }


  /**
   * pox_state upsert
   */
  export type pox_stateUpsertArgs = {
    /**
     * Select specific fields to fetch from the pox_state
     * 
    **/
    select?: pox_stateSelect | null
    /**
     * The filter to search for the pox_state to update in case it exists.
     * 
    **/
    where: pox_stateWhereUniqueInput
    /**
     * In case the pox_state found by the `where` argument doesn't exist, create a new pox_state with this data.
     * 
    **/
    create: XOR<pox_stateCreateInput, pox_stateUncheckedCreateInput>
    /**
     * In case the pox_state was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<pox_stateUpdateInput, pox_stateUncheckedUpdateInput>
  }


  /**
   * pox_state delete
   */
  export type pox_stateDeleteArgs = {
    /**
     * Select specific fields to fetch from the pox_state
     * 
    **/
    select?: pox_stateSelect | null
    /**
     * Filter which pox_state to delete.
     * 
    **/
    where: pox_stateWhereUniqueInput
  }


  /**
   * pox_state deleteMany
   */
  export type pox_stateDeleteManyArgs = {
    /**
     * Filter which pox_states to delete
     * 
    **/
    where?: pox_stateWhereInput
  }


  /**
   * pox_state without action
   */
  export type pox_stateArgs = {
    /**
     * Select specific fields to fetch from the pox_state
     * 
    **/
    select?: pox_stateSelect | null
  }



  /**
   * Model principal_stx_txs
   */


  export type AggregatePrincipal_stx_txs = {
    _count: Principal_stx_txsCountAggregateOutputType | null
    _avg: Principal_stx_txsAvgAggregateOutputType | null
    _sum: Principal_stx_txsSumAggregateOutputType | null
    _min: Principal_stx_txsMinAggregateOutputType | null
    _max: Principal_stx_txsMaxAggregateOutputType | null
  }

  export type Principal_stx_txsAvgAggregateOutputType = {
    id: number | null
    block_height: number | null
    microblock_sequence: number | null
    tx_index: number | null
  }

  export type Principal_stx_txsSumAggregateOutputType = {
    id: number | null
    block_height: number | null
    microblock_sequence: number | null
    tx_index: number | null
  }

  export type Principal_stx_txsMinAggregateOutputType = {
    id: number | null
    principal: string | null
    tx_id: Buffer | null
    block_height: number | null
    index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    tx_index: number | null
    canonical: boolean | null
    microblock_canonical: boolean | null
  }

  export type Principal_stx_txsMaxAggregateOutputType = {
    id: number | null
    principal: string | null
    tx_id: Buffer | null
    block_height: number | null
    index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    tx_index: number | null
    canonical: boolean | null
    microblock_canonical: boolean | null
  }

  export type Principal_stx_txsCountAggregateOutputType = {
    id: number
    principal: number
    tx_id: number
    block_height: number
    index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    tx_index: number
    canonical: number
    microblock_canonical: number
    _all: number
  }


  export type Principal_stx_txsAvgAggregateInputType = {
    id?: true
    block_height?: true
    microblock_sequence?: true
    tx_index?: true
  }

  export type Principal_stx_txsSumAggregateInputType = {
    id?: true
    block_height?: true
    microblock_sequence?: true
    tx_index?: true
  }

  export type Principal_stx_txsMinAggregateInputType = {
    id?: true
    principal?: true
    tx_id?: true
    block_height?: true
    index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    tx_index?: true
    canonical?: true
    microblock_canonical?: true
  }

  export type Principal_stx_txsMaxAggregateInputType = {
    id?: true
    principal?: true
    tx_id?: true
    block_height?: true
    index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    tx_index?: true
    canonical?: true
    microblock_canonical?: true
  }

  export type Principal_stx_txsCountAggregateInputType = {
    id?: true
    principal?: true
    tx_id?: true
    block_height?: true
    index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    tx_index?: true
    canonical?: true
    microblock_canonical?: true
    _all?: true
  }

  export type Principal_stx_txsAggregateArgs = {
    /**
     * Filter which principal_stx_txs to aggregate.
     * 
    **/
    where?: principal_stx_txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of principal_stx_txs to fetch.
     * 
    **/
    orderBy?: Enumerable<principal_stx_txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: principal_stx_txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` principal_stx_txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` principal_stx_txs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned principal_stx_txs
    **/
    _count?: true | Principal_stx_txsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Principal_stx_txsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Principal_stx_txsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Principal_stx_txsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Principal_stx_txsMaxAggregateInputType
  }

  export type GetPrincipal_stx_txsAggregateType<T extends Principal_stx_txsAggregateArgs> = {
        [P in keyof T & keyof AggregatePrincipal_stx_txs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrincipal_stx_txs[P]>
      : GetScalarType<T[P], AggregatePrincipal_stx_txs[P]>
  }




  export type Principal_stx_txsGroupByArgs = {
    where?: principal_stx_txsWhereInput
    orderBy?: Enumerable<principal_stx_txsOrderByWithAggregationInput>
    by: Array<Principal_stx_txsScalarFieldEnum>
    having?: principal_stx_txsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Principal_stx_txsCountAggregateInputType | true
    _avg?: Principal_stx_txsAvgAggregateInputType
    _sum?: Principal_stx_txsSumAggregateInputType
    _min?: Principal_stx_txsMinAggregateInputType
    _max?: Principal_stx_txsMaxAggregateInputType
  }


  export type Principal_stx_txsGroupByOutputType = {
    id: number
    principal: string
    tx_id: Buffer
    block_height: number
    index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    tx_index: number
    canonical: boolean
    microblock_canonical: boolean
    _count: Principal_stx_txsCountAggregateOutputType | null
    _avg: Principal_stx_txsAvgAggregateOutputType | null
    _sum: Principal_stx_txsSumAggregateOutputType | null
    _min: Principal_stx_txsMinAggregateOutputType | null
    _max: Principal_stx_txsMaxAggregateOutputType | null
  }

  type GetPrincipal_stx_txsGroupByPayload<T extends Principal_stx_txsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Principal_stx_txsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Principal_stx_txsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Principal_stx_txsGroupByOutputType[P]>
            : GetScalarType<T[P], Principal_stx_txsGroupByOutputType[P]>
        }
      >
    >


  export type principal_stx_txsSelect = {
    id?: boolean
    principal?: boolean
    tx_id?: boolean
    block_height?: boolean
    index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    tx_index?: boolean
    canonical?: boolean
    microblock_canonical?: boolean
  }


  export type principal_stx_txsGetPayload<S extends boolean | null | undefined | principal_stx_txsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? principal_stx_txs :
    S extends undefined ? never :
    S extends { include: any } & (principal_stx_txsArgs | principal_stx_txsFindManyArgs)
    ? principal_stx_txs 
    : S extends { select: any } & (principal_stx_txsArgs | principal_stx_txsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof principal_stx_txs ? principal_stx_txs[P] : never
  } 
      : principal_stx_txs


  type principal_stx_txsCountArgs = Merge<
    Omit<principal_stx_txsFindManyArgs, 'select' | 'include'> & {
      select?: Principal_stx_txsCountAggregateInputType | true
    }
  >

  export interface principal_stx_txsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Principal_stx_txs that matches the filter.
     * @param {principal_stx_txsFindUniqueArgs} args - Arguments to find a Principal_stx_txs
     * @example
     * // Get one Principal_stx_txs
     * const principal_stx_txs = await prisma.principal_stx_txs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends principal_stx_txsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, principal_stx_txsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'principal_stx_txs'> extends True ? Prisma__principal_stx_txsClient<principal_stx_txsGetPayload<T>> : Prisma__principal_stx_txsClient<principal_stx_txsGetPayload<T> | null, null>

    /**
     * Find one Principal_stx_txs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {principal_stx_txsFindUniqueOrThrowArgs} args - Arguments to find a Principal_stx_txs
     * @example
     * // Get one Principal_stx_txs
     * const principal_stx_txs = await prisma.principal_stx_txs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends principal_stx_txsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, principal_stx_txsFindUniqueOrThrowArgs>
    ): Prisma__principal_stx_txsClient<principal_stx_txsGetPayload<T>>

    /**
     * Find the first Principal_stx_txs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {principal_stx_txsFindFirstArgs} args - Arguments to find a Principal_stx_txs
     * @example
     * // Get one Principal_stx_txs
     * const principal_stx_txs = await prisma.principal_stx_txs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends principal_stx_txsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, principal_stx_txsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'principal_stx_txs'> extends True ? Prisma__principal_stx_txsClient<principal_stx_txsGetPayload<T>> : Prisma__principal_stx_txsClient<principal_stx_txsGetPayload<T> | null, null>

    /**
     * Find the first Principal_stx_txs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {principal_stx_txsFindFirstOrThrowArgs} args - Arguments to find a Principal_stx_txs
     * @example
     * // Get one Principal_stx_txs
     * const principal_stx_txs = await prisma.principal_stx_txs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends principal_stx_txsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, principal_stx_txsFindFirstOrThrowArgs>
    ): Prisma__principal_stx_txsClient<principal_stx_txsGetPayload<T>>

    /**
     * Find zero or more Principal_stx_txs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {principal_stx_txsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Principal_stx_txs
     * const principal_stx_txs = await prisma.principal_stx_txs.findMany()
     * 
     * // Get first 10 Principal_stx_txs
     * const principal_stx_txs = await prisma.principal_stx_txs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const principal_stx_txsWithIdOnly = await prisma.principal_stx_txs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends principal_stx_txsFindManyArgs>(
      args?: SelectSubset<T, principal_stx_txsFindManyArgs>
    ): PrismaPromise<Array<principal_stx_txsGetPayload<T>>>

    /**
     * Create a Principal_stx_txs.
     * @param {principal_stx_txsCreateArgs} args - Arguments to create a Principal_stx_txs.
     * @example
     * // Create one Principal_stx_txs
     * const Principal_stx_txs = await prisma.principal_stx_txs.create({
     *   data: {
     *     // ... data to create a Principal_stx_txs
     *   }
     * })
     * 
    **/
    create<T extends principal_stx_txsCreateArgs>(
      args: SelectSubset<T, principal_stx_txsCreateArgs>
    ): Prisma__principal_stx_txsClient<principal_stx_txsGetPayload<T>>

    /**
     * Create many Principal_stx_txs.
     *     @param {principal_stx_txsCreateManyArgs} args - Arguments to create many Principal_stx_txs.
     *     @example
     *     // Create many Principal_stx_txs
     *     const principal_stx_txs = await prisma.principal_stx_txs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends principal_stx_txsCreateManyArgs>(
      args?: SelectSubset<T, principal_stx_txsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Principal_stx_txs.
     * @param {principal_stx_txsDeleteArgs} args - Arguments to delete one Principal_stx_txs.
     * @example
     * // Delete one Principal_stx_txs
     * const Principal_stx_txs = await prisma.principal_stx_txs.delete({
     *   where: {
     *     // ... filter to delete one Principal_stx_txs
     *   }
     * })
     * 
    **/
    delete<T extends principal_stx_txsDeleteArgs>(
      args: SelectSubset<T, principal_stx_txsDeleteArgs>
    ): Prisma__principal_stx_txsClient<principal_stx_txsGetPayload<T>>

    /**
     * Update one Principal_stx_txs.
     * @param {principal_stx_txsUpdateArgs} args - Arguments to update one Principal_stx_txs.
     * @example
     * // Update one Principal_stx_txs
     * const principal_stx_txs = await prisma.principal_stx_txs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends principal_stx_txsUpdateArgs>(
      args: SelectSubset<T, principal_stx_txsUpdateArgs>
    ): Prisma__principal_stx_txsClient<principal_stx_txsGetPayload<T>>

    /**
     * Delete zero or more Principal_stx_txs.
     * @param {principal_stx_txsDeleteManyArgs} args - Arguments to filter Principal_stx_txs to delete.
     * @example
     * // Delete a few Principal_stx_txs
     * const { count } = await prisma.principal_stx_txs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends principal_stx_txsDeleteManyArgs>(
      args?: SelectSubset<T, principal_stx_txsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Principal_stx_txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {principal_stx_txsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Principal_stx_txs
     * const principal_stx_txs = await prisma.principal_stx_txs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends principal_stx_txsUpdateManyArgs>(
      args: SelectSubset<T, principal_stx_txsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Principal_stx_txs.
     * @param {principal_stx_txsUpsertArgs} args - Arguments to update or create a Principal_stx_txs.
     * @example
     * // Update or create a Principal_stx_txs
     * const principal_stx_txs = await prisma.principal_stx_txs.upsert({
     *   create: {
     *     // ... data to create a Principal_stx_txs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Principal_stx_txs we want to update
     *   }
     * })
    **/
    upsert<T extends principal_stx_txsUpsertArgs>(
      args: SelectSubset<T, principal_stx_txsUpsertArgs>
    ): Prisma__principal_stx_txsClient<principal_stx_txsGetPayload<T>>

    /**
     * Count the number of Principal_stx_txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {principal_stx_txsCountArgs} args - Arguments to filter Principal_stx_txs to count.
     * @example
     * // Count the number of Principal_stx_txs
     * const count = await prisma.principal_stx_txs.count({
     *   where: {
     *     // ... the filter for the Principal_stx_txs we want to count
     *   }
     * })
    **/
    count<T extends principal_stx_txsCountArgs>(
      args?: Subset<T, principal_stx_txsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Principal_stx_txsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Principal_stx_txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Principal_stx_txsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Principal_stx_txsAggregateArgs>(args: Subset<T, Principal_stx_txsAggregateArgs>): PrismaPromise<GetPrincipal_stx_txsAggregateType<T>>

    /**
     * Group by Principal_stx_txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Principal_stx_txsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Principal_stx_txsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Principal_stx_txsGroupByArgs['orderBy'] }
        : { orderBy?: Principal_stx_txsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Principal_stx_txsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrincipal_stx_txsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for principal_stx_txs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__principal_stx_txsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * principal_stx_txs base type for findUnique actions
   */
  export type principal_stx_txsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the principal_stx_txs
     * 
    **/
    select?: principal_stx_txsSelect | null
    /**
     * Filter, which principal_stx_txs to fetch.
     * 
    **/
    where: principal_stx_txsWhereUniqueInput
  }

  /**
   * principal_stx_txs: findUnique
   */
  export interface principal_stx_txsFindUniqueArgs extends principal_stx_txsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * principal_stx_txs findUniqueOrThrow
   */
  export type principal_stx_txsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the principal_stx_txs
     * 
    **/
    select?: principal_stx_txsSelect | null
    /**
     * Filter, which principal_stx_txs to fetch.
     * 
    **/
    where: principal_stx_txsWhereUniqueInput
  }


  /**
   * principal_stx_txs base type for findFirst actions
   */
  export type principal_stx_txsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the principal_stx_txs
     * 
    **/
    select?: principal_stx_txsSelect | null
    /**
     * Filter, which principal_stx_txs to fetch.
     * 
    **/
    where?: principal_stx_txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of principal_stx_txs to fetch.
     * 
    **/
    orderBy?: Enumerable<principal_stx_txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for principal_stx_txs.
     * 
    **/
    cursor?: principal_stx_txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` principal_stx_txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` principal_stx_txs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of principal_stx_txs.
     * 
    **/
    distinct?: Enumerable<Principal_stx_txsScalarFieldEnum>
  }

  /**
   * principal_stx_txs: findFirst
   */
  export interface principal_stx_txsFindFirstArgs extends principal_stx_txsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * principal_stx_txs findFirstOrThrow
   */
  export type principal_stx_txsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the principal_stx_txs
     * 
    **/
    select?: principal_stx_txsSelect | null
    /**
     * Filter, which principal_stx_txs to fetch.
     * 
    **/
    where?: principal_stx_txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of principal_stx_txs to fetch.
     * 
    **/
    orderBy?: Enumerable<principal_stx_txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for principal_stx_txs.
     * 
    **/
    cursor?: principal_stx_txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` principal_stx_txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` principal_stx_txs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of principal_stx_txs.
     * 
    **/
    distinct?: Enumerable<Principal_stx_txsScalarFieldEnum>
  }


  /**
   * principal_stx_txs findMany
   */
  export type principal_stx_txsFindManyArgs = {
    /**
     * Select specific fields to fetch from the principal_stx_txs
     * 
    **/
    select?: principal_stx_txsSelect | null
    /**
     * Filter, which principal_stx_txs to fetch.
     * 
    **/
    where?: principal_stx_txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of principal_stx_txs to fetch.
     * 
    **/
    orderBy?: Enumerable<principal_stx_txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing principal_stx_txs.
     * 
    **/
    cursor?: principal_stx_txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` principal_stx_txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` principal_stx_txs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Principal_stx_txsScalarFieldEnum>
  }


  /**
   * principal_stx_txs create
   */
  export type principal_stx_txsCreateArgs = {
    /**
     * Select specific fields to fetch from the principal_stx_txs
     * 
    **/
    select?: principal_stx_txsSelect | null
    /**
     * The data needed to create a principal_stx_txs.
     * 
    **/
    data: XOR<principal_stx_txsCreateInput, principal_stx_txsUncheckedCreateInput>
  }


  /**
   * principal_stx_txs createMany
   */
  export type principal_stx_txsCreateManyArgs = {
    /**
     * The data used to create many principal_stx_txs.
     * 
    **/
    data: Enumerable<principal_stx_txsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * principal_stx_txs update
   */
  export type principal_stx_txsUpdateArgs = {
    /**
     * Select specific fields to fetch from the principal_stx_txs
     * 
    **/
    select?: principal_stx_txsSelect | null
    /**
     * The data needed to update a principal_stx_txs.
     * 
    **/
    data: XOR<principal_stx_txsUpdateInput, principal_stx_txsUncheckedUpdateInput>
    /**
     * Choose, which principal_stx_txs to update.
     * 
    **/
    where: principal_stx_txsWhereUniqueInput
  }


  /**
   * principal_stx_txs updateMany
   */
  export type principal_stx_txsUpdateManyArgs = {
    /**
     * The data used to update principal_stx_txs.
     * 
    **/
    data: XOR<principal_stx_txsUpdateManyMutationInput, principal_stx_txsUncheckedUpdateManyInput>
    /**
     * Filter which principal_stx_txs to update
     * 
    **/
    where?: principal_stx_txsWhereInput
  }


  /**
   * principal_stx_txs upsert
   */
  export type principal_stx_txsUpsertArgs = {
    /**
     * Select specific fields to fetch from the principal_stx_txs
     * 
    **/
    select?: principal_stx_txsSelect | null
    /**
     * The filter to search for the principal_stx_txs to update in case it exists.
     * 
    **/
    where: principal_stx_txsWhereUniqueInput
    /**
     * In case the principal_stx_txs found by the `where` argument doesn't exist, create a new principal_stx_txs with this data.
     * 
    **/
    create: XOR<principal_stx_txsCreateInput, principal_stx_txsUncheckedCreateInput>
    /**
     * In case the principal_stx_txs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<principal_stx_txsUpdateInput, principal_stx_txsUncheckedUpdateInput>
  }


  /**
   * principal_stx_txs delete
   */
  export type principal_stx_txsDeleteArgs = {
    /**
     * Select specific fields to fetch from the principal_stx_txs
     * 
    **/
    select?: principal_stx_txsSelect | null
    /**
     * Filter which principal_stx_txs to delete.
     * 
    **/
    where: principal_stx_txsWhereUniqueInput
  }


  /**
   * principal_stx_txs deleteMany
   */
  export type principal_stx_txsDeleteManyArgs = {
    /**
     * Filter which principal_stx_txs to delete
     * 
    **/
    where?: principal_stx_txsWhereInput
  }


  /**
   * principal_stx_txs without action
   */
  export type principal_stx_txsArgs = {
    /**
     * Select specific fields to fetch from the principal_stx_txs
     * 
    **/
    select?: principal_stx_txsSelect | null
  }



  /**
   * Model reward_slot_holders
   */


  export type AggregateReward_slot_holders = {
    _count: Reward_slot_holdersCountAggregateOutputType | null
    _avg: Reward_slot_holdersAvgAggregateOutputType | null
    _sum: Reward_slot_holdersSumAggregateOutputType | null
    _min: Reward_slot_holdersMinAggregateOutputType | null
    _max: Reward_slot_holdersMaxAggregateOutputType | null
  }

  export type Reward_slot_holdersAvgAggregateOutputType = {
    id: number | null
    burn_block_height: number | null
    slot_index: number | null
  }

  export type Reward_slot_holdersSumAggregateOutputType = {
    id: number | null
    burn_block_height: number | null
    slot_index: number | null
  }

  export type Reward_slot_holdersMinAggregateOutputType = {
    id: number | null
    canonical: boolean | null
    burn_block_hash: Buffer | null
    burn_block_height: number | null
    address: string | null
    slot_index: number | null
  }

  export type Reward_slot_holdersMaxAggregateOutputType = {
    id: number | null
    canonical: boolean | null
    burn_block_hash: Buffer | null
    burn_block_height: number | null
    address: string | null
    slot_index: number | null
  }

  export type Reward_slot_holdersCountAggregateOutputType = {
    id: number
    canonical: number
    burn_block_hash: number
    burn_block_height: number
    address: number
    slot_index: number
    _all: number
  }


  export type Reward_slot_holdersAvgAggregateInputType = {
    id?: true
    burn_block_height?: true
    slot_index?: true
  }

  export type Reward_slot_holdersSumAggregateInputType = {
    id?: true
    burn_block_height?: true
    slot_index?: true
  }

  export type Reward_slot_holdersMinAggregateInputType = {
    id?: true
    canonical?: true
    burn_block_hash?: true
    burn_block_height?: true
    address?: true
    slot_index?: true
  }

  export type Reward_slot_holdersMaxAggregateInputType = {
    id?: true
    canonical?: true
    burn_block_hash?: true
    burn_block_height?: true
    address?: true
    slot_index?: true
  }

  export type Reward_slot_holdersCountAggregateInputType = {
    id?: true
    canonical?: true
    burn_block_hash?: true
    burn_block_height?: true
    address?: true
    slot_index?: true
    _all?: true
  }

  export type Reward_slot_holdersAggregateArgs = {
    /**
     * Filter which reward_slot_holders to aggregate.
     * 
    **/
    where?: reward_slot_holdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_slot_holders to fetch.
     * 
    **/
    orderBy?: Enumerable<reward_slot_holdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reward_slot_holdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_slot_holders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_slot_holders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reward_slot_holders
    **/
    _count?: true | Reward_slot_holdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Reward_slot_holdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Reward_slot_holdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reward_slot_holdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reward_slot_holdersMaxAggregateInputType
  }

  export type GetReward_slot_holdersAggregateType<T extends Reward_slot_holdersAggregateArgs> = {
        [P in keyof T & keyof AggregateReward_slot_holders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward_slot_holders[P]>
      : GetScalarType<T[P], AggregateReward_slot_holders[P]>
  }




  export type Reward_slot_holdersGroupByArgs = {
    where?: reward_slot_holdersWhereInput
    orderBy?: Enumerable<reward_slot_holdersOrderByWithAggregationInput>
    by: Array<Reward_slot_holdersScalarFieldEnum>
    having?: reward_slot_holdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reward_slot_holdersCountAggregateInputType | true
    _avg?: Reward_slot_holdersAvgAggregateInputType
    _sum?: Reward_slot_holdersSumAggregateInputType
    _min?: Reward_slot_holdersMinAggregateInputType
    _max?: Reward_slot_holdersMaxAggregateInputType
  }


  export type Reward_slot_holdersGroupByOutputType = {
    id: number
    canonical: boolean
    burn_block_hash: Buffer
    burn_block_height: number
    address: string
    slot_index: number
    _count: Reward_slot_holdersCountAggregateOutputType | null
    _avg: Reward_slot_holdersAvgAggregateOutputType | null
    _sum: Reward_slot_holdersSumAggregateOutputType | null
    _min: Reward_slot_holdersMinAggregateOutputType | null
    _max: Reward_slot_holdersMaxAggregateOutputType | null
  }

  type GetReward_slot_holdersGroupByPayload<T extends Reward_slot_holdersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Reward_slot_holdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reward_slot_holdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reward_slot_holdersGroupByOutputType[P]>
            : GetScalarType<T[P], Reward_slot_holdersGroupByOutputType[P]>
        }
      >
    >


  export type reward_slot_holdersSelect = {
    id?: boolean
    canonical?: boolean
    burn_block_hash?: boolean
    burn_block_height?: boolean
    address?: boolean
    slot_index?: boolean
  }


  export type reward_slot_holdersGetPayload<S extends boolean | null | undefined | reward_slot_holdersArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? reward_slot_holders :
    S extends undefined ? never :
    S extends { include: any } & (reward_slot_holdersArgs | reward_slot_holdersFindManyArgs)
    ? reward_slot_holders 
    : S extends { select: any } & (reward_slot_holdersArgs | reward_slot_holdersFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof reward_slot_holders ? reward_slot_holders[P] : never
  } 
      : reward_slot_holders


  type reward_slot_holdersCountArgs = Merge<
    Omit<reward_slot_holdersFindManyArgs, 'select' | 'include'> & {
      select?: Reward_slot_holdersCountAggregateInputType | true
    }
  >

  export interface reward_slot_holdersDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Reward_slot_holders that matches the filter.
     * @param {reward_slot_holdersFindUniqueArgs} args - Arguments to find a Reward_slot_holders
     * @example
     * // Get one Reward_slot_holders
     * const reward_slot_holders = await prisma.reward_slot_holders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reward_slot_holdersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reward_slot_holdersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reward_slot_holders'> extends True ? Prisma__reward_slot_holdersClient<reward_slot_holdersGetPayload<T>> : Prisma__reward_slot_holdersClient<reward_slot_holdersGetPayload<T> | null, null>

    /**
     * Find one Reward_slot_holders that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reward_slot_holdersFindUniqueOrThrowArgs} args - Arguments to find a Reward_slot_holders
     * @example
     * // Get one Reward_slot_holders
     * const reward_slot_holders = await prisma.reward_slot_holders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reward_slot_holdersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reward_slot_holdersFindUniqueOrThrowArgs>
    ): Prisma__reward_slot_holdersClient<reward_slot_holdersGetPayload<T>>

    /**
     * Find the first Reward_slot_holders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_slot_holdersFindFirstArgs} args - Arguments to find a Reward_slot_holders
     * @example
     * // Get one Reward_slot_holders
     * const reward_slot_holders = await prisma.reward_slot_holders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reward_slot_holdersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reward_slot_holdersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reward_slot_holders'> extends True ? Prisma__reward_slot_holdersClient<reward_slot_holdersGetPayload<T>> : Prisma__reward_slot_holdersClient<reward_slot_holdersGetPayload<T> | null, null>

    /**
     * Find the first Reward_slot_holders that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_slot_holdersFindFirstOrThrowArgs} args - Arguments to find a Reward_slot_holders
     * @example
     * // Get one Reward_slot_holders
     * const reward_slot_holders = await prisma.reward_slot_holders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reward_slot_holdersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reward_slot_holdersFindFirstOrThrowArgs>
    ): Prisma__reward_slot_holdersClient<reward_slot_holdersGetPayload<T>>

    /**
     * Find zero or more Reward_slot_holders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_slot_holdersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reward_slot_holders
     * const reward_slot_holders = await prisma.reward_slot_holders.findMany()
     * 
     * // Get first 10 Reward_slot_holders
     * const reward_slot_holders = await prisma.reward_slot_holders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reward_slot_holdersWithIdOnly = await prisma.reward_slot_holders.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reward_slot_holdersFindManyArgs>(
      args?: SelectSubset<T, reward_slot_holdersFindManyArgs>
    ): PrismaPromise<Array<reward_slot_holdersGetPayload<T>>>

    /**
     * Create a Reward_slot_holders.
     * @param {reward_slot_holdersCreateArgs} args - Arguments to create a Reward_slot_holders.
     * @example
     * // Create one Reward_slot_holders
     * const Reward_slot_holders = await prisma.reward_slot_holders.create({
     *   data: {
     *     // ... data to create a Reward_slot_holders
     *   }
     * })
     * 
    **/
    create<T extends reward_slot_holdersCreateArgs>(
      args: SelectSubset<T, reward_slot_holdersCreateArgs>
    ): Prisma__reward_slot_holdersClient<reward_slot_holdersGetPayload<T>>

    /**
     * Create many Reward_slot_holders.
     *     @param {reward_slot_holdersCreateManyArgs} args - Arguments to create many Reward_slot_holders.
     *     @example
     *     // Create many Reward_slot_holders
     *     const reward_slot_holders = await prisma.reward_slot_holders.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reward_slot_holdersCreateManyArgs>(
      args?: SelectSubset<T, reward_slot_holdersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reward_slot_holders.
     * @param {reward_slot_holdersDeleteArgs} args - Arguments to delete one Reward_slot_holders.
     * @example
     * // Delete one Reward_slot_holders
     * const Reward_slot_holders = await prisma.reward_slot_holders.delete({
     *   where: {
     *     // ... filter to delete one Reward_slot_holders
     *   }
     * })
     * 
    **/
    delete<T extends reward_slot_holdersDeleteArgs>(
      args: SelectSubset<T, reward_slot_holdersDeleteArgs>
    ): Prisma__reward_slot_holdersClient<reward_slot_holdersGetPayload<T>>

    /**
     * Update one Reward_slot_holders.
     * @param {reward_slot_holdersUpdateArgs} args - Arguments to update one Reward_slot_holders.
     * @example
     * // Update one Reward_slot_holders
     * const reward_slot_holders = await prisma.reward_slot_holders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reward_slot_holdersUpdateArgs>(
      args: SelectSubset<T, reward_slot_holdersUpdateArgs>
    ): Prisma__reward_slot_holdersClient<reward_slot_holdersGetPayload<T>>

    /**
     * Delete zero or more Reward_slot_holders.
     * @param {reward_slot_holdersDeleteManyArgs} args - Arguments to filter Reward_slot_holders to delete.
     * @example
     * // Delete a few Reward_slot_holders
     * const { count } = await prisma.reward_slot_holders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reward_slot_holdersDeleteManyArgs>(
      args?: SelectSubset<T, reward_slot_holdersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reward_slot_holders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_slot_holdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reward_slot_holders
     * const reward_slot_holders = await prisma.reward_slot_holders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reward_slot_holdersUpdateManyArgs>(
      args: SelectSubset<T, reward_slot_holdersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reward_slot_holders.
     * @param {reward_slot_holdersUpsertArgs} args - Arguments to update or create a Reward_slot_holders.
     * @example
     * // Update or create a Reward_slot_holders
     * const reward_slot_holders = await prisma.reward_slot_holders.upsert({
     *   create: {
     *     // ... data to create a Reward_slot_holders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward_slot_holders we want to update
     *   }
     * })
    **/
    upsert<T extends reward_slot_holdersUpsertArgs>(
      args: SelectSubset<T, reward_slot_holdersUpsertArgs>
    ): Prisma__reward_slot_holdersClient<reward_slot_holdersGetPayload<T>>

    /**
     * Count the number of Reward_slot_holders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reward_slot_holdersCountArgs} args - Arguments to filter Reward_slot_holders to count.
     * @example
     * // Count the number of Reward_slot_holders
     * const count = await prisma.reward_slot_holders.count({
     *   where: {
     *     // ... the filter for the Reward_slot_holders we want to count
     *   }
     * })
    **/
    count<T extends reward_slot_holdersCountArgs>(
      args?: Subset<T, reward_slot_holdersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reward_slot_holdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward_slot_holders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reward_slot_holdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reward_slot_holdersAggregateArgs>(args: Subset<T, Reward_slot_holdersAggregateArgs>): PrismaPromise<GetReward_slot_holdersAggregateType<T>>

    /**
     * Group by Reward_slot_holders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reward_slot_holdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Reward_slot_holdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Reward_slot_holdersGroupByArgs['orderBy'] }
        : { orderBy?: Reward_slot_holdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Reward_slot_holdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReward_slot_holdersGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for reward_slot_holders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reward_slot_holdersClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * reward_slot_holders base type for findUnique actions
   */
  export type reward_slot_holdersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reward_slot_holders
     * 
    **/
    select?: reward_slot_holdersSelect | null
    /**
     * Filter, which reward_slot_holders to fetch.
     * 
    **/
    where: reward_slot_holdersWhereUniqueInput
  }

  /**
   * reward_slot_holders: findUnique
   */
  export interface reward_slot_holdersFindUniqueArgs extends reward_slot_holdersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reward_slot_holders findUniqueOrThrow
   */
  export type reward_slot_holdersFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reward_slot_holders
     * 
    **/
    select?: reward_slot_holdersSelect | null
    /**
     * Filter, which reward_slot_holders to fetch.
     * 
    **/
    where: reward_slot_holdersWhereUniqueInput
  }


  /**
   * reward_slot_holders base type for findFirst actions
   */
  export type reward_slot_holdersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reward_slot_holders
     * 
    **/
    select?: reward_slot_holdersSelect | null
    /**
     * Filter, which reward_slot_holders to fetch.
     * 
    **/
    where?: reward_slot_holdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_slot_holders to fetch.
     * 
    **/
    orderBy?: Enumerable<reward_slot_holdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reward_slot_holders.
     * 
    **/
    cursor?: reward_slot_holdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_slot_holders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_slot_holders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reward_slot_holders.
     * 
    **/
    distinct?: Enumerable<Reward_slot_holdersScalarFieldEnum>
  }

  /**
   * reward_slot_holders: findFirst
   */
  export interface reward_slot_holdersFindFirstArgs extends reward_slot_holdersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reward_slot_holders findFirstOrThrow
   */
  export type reward_slot_holdersFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the reward_slot_holders
     * 
    **/
    select?: reward_slot_holdersSelect | null
    /**
     * Filter, which reward_slot_holders to fetch.
     * 
    **/
    where?: reward_slot_holdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_slot_holders to fetch.
     * 
    **/
    orderBy?: Enumerable<reward_slot_holdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reward_slot_holders.
     * 
    **/
    cursor?: reward_slot_holdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_slot_holders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_slot_holders.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reward_slot_holders.
     * 
    **/
    distinct?: Enumerable<Reward_slot_holdersScalarFieldEnum>
  }


  /**
   * reward_slot_holders findMany
   */
  export type reward_slot_holdersFindManyArgs = {
    /**
     * Select specific fields to fetch from the reward_slot_holders
     * 
    **/
    select?: reward_slot_holdersSelect | null
    /**
     * Filter, which reward_slot_holders to fetch.
     * 
    **/
    where?: reward_slot_holdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reward_slot_holders to fetch.
     * 
    **/
    orderBy?: Enumerable<reward_slot_holdersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reward_slot_holders.
     * 
    **/
    cursor?: reward_slot_holdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reward_slot_holders from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reward_slot_holders.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Reward_slot_holdersScalarFieldEnum>
  }


  /**
   * reward_slot_holders create
   */
  export type reward_slot_holdersCreateArgs = {
    /**
     * Select specific fields to fetch from the reward_slot_holders
     * 
    **/
    select?: reward_slot_holdersSelect | null
    /**
     * The data needed to create a reward_slot_holders.
     * 
    **/
    data: XOR<reward_slot_holdersCreateInput, reward_slot_holdersUncheckedCreateInput>
  }


  /**
   * reward_slot_holders createMany
   */
  export type reward_slot_holdersCreateManyArgs = {
    /**
     * The data used to create many reward_slot_holders.
     * 
    **/
    data: Enumerable<reward_slot_holdersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reward_slot_holders update
   */
  export type reward_slot_holdersUpdateArgs = {
    /**
     * Select specific fields to fetch from the reward_slot_holders
     * 
    **/
    select?: reward_slot_holdersSelect | null
    /**
     * The data needed to update a reward_slot_holders.
     * 
    **/
    data: XOR<reward_slot_holdersUpdateInput, reward_slot_holdersUncheckedUpdateInput>
    /**
     * Choose, which reward_slot_holders to update.
     * 
    **/
    where: reward_slot_holdersWhereUniqueInput
  }


  /**
   * reward_slot_holders updateMany
   */
  export type reward_slot_holdersUpdateManyArgs = {
    /**
     * The data used to update reward_slot_holders.
     * 
    **/
    data: XOR<reward_slot_holdersUpdateManyMutationInput, reward_slot_holdersUncheckedUpdateManyInput>
    /**
     * Filter which reward_slot_holders to update
     * 
    **/
    where?: reward_slot_holdersWhereInput
  }


  /**
   * reward_slot_holders upsert
   */
  export type reward_slot_holdersUpsertArgs = {
    /**
     * Select specific fields to fetch from the reward_slot_holders
     * 
    **/
    select?: reward_slot_holdersSelect | null
    /**
     * The filter to search for the reward_slot_holders to update in case it exists.
     * 
    **/
    where: reward_slot_holdersWhereUniqueInput
    /**
     * In case the reward_slot_holders found by the `where` argument doesn't exist, create a new reward_slot_holders with this data.
     * 
    **/
    create: XOR<reward_slot_holdersCreateInput, reward_slot_holdersUncheckedCreateInput>
    /**
     * In case the reward_slot_holders was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reward_slot_holdersUpdateInput, reward_slot_holdersUncheckedUpdateInput>
  }


  /**
   * reward_slot_holders delete
   */
  export type reward_slot_holdersDeleteArgs = {
    /**
     * Select specific fields to fetch from the reward_slot_holders
     * 
    **/
    select?: reward_slot_holdersSelect | null
    /**
     * Filter which reward_slot_holders to delete.
     * 
    **/
    where: reward_slot_holdersWhereUniqueInput
  }


  /**
   * reward_slot_holders deleteMany
   */
  export type reward_slot_holdersDeleteManyArgs = {
    /**
     * Filter which reward_slot_holders to delete
     * 
    **/
    where?: reward_slot_holdersWhereInput
  }


  /**
   * reward_slot_holders without action
   */
  export type reward_slot_holdersArgs = {
    /**
     * Select specific fields to fetch from the reward_slot_holders
     * 
    **/
    select?: reward_slot_holdersSelect | null
  }



  /**
   * Model smart_contracts
   */


  export type AggregateSmart_contracts = {
    _count: Smart_contractsCountAggregateOutputType | null
    _avg: Smart_contractsAvgAggregateOutputType | null
    _sum: Smart_contractsSumAggregateOutputType | null
    _min: Smart_contractsMinAggregateOutputType | null
    _max: Smart_contractsMaxAggregateOutputType | null
  }

  export type Smart_contractsAvgAggregateOutputType = {
    id: number | null
    block_height: number | null
    microblock_sequence: number | null
    clarity_version: number | null
  }

  export type Smart_contractsSumAggregateOutputType = {
    id: number | null
    block_height: number | null
    microblock_sequence: number | null
    clarity_version: number | null
  }

  export type Smart_contractsMinAggregateOutputType = {
    id: number | null
    tx_id: Buffer | null
    canonical: boolean | null
    contract_id: string | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    clarity_version: number | null
    source_code: string | null
  }

  export type Smart_contractsMaxAggregateOutputType = {
    id: number | null
    tx_id: Buffer | null
    canonical: boolean | null
    contract_id: string | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    clarity_version: number | null
    source_code: string | null
  }

  export type Smart_contractsCountAggregateOutputType = {
    id: number
    tx_id: number
    canonical: number
    contract_id: number
    block_height: number
    index_block_hash: number
    parent_index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    microblock_canonical: number
    clarity_version: number
    source_code: number
    abi: number
    _all: number
  }


  export type Smart_contractsAvgAggregateInputType = {
    id?: true
    block_height?: true
    microblock_sequence?: true
    clarity_version?: true
  }

  export type Smart_contractsSumAggregateInputType = {
    id?: true
    block_height?: true
    microblock_sequence?: true
    clarity_version?: true
  }

  export type Smart_contractsMinAggregateInputType = {
    id?: true
    tx_id?: true
    canonical?: true
    contract_id?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    clarity_version?: true
    source_code?: true
  }

  export type Smart_contractsMaxAggregateInputType = {
    id?: true
    tx_id?: true
    canonical?: true
    contract_id?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    clarity_version?: true
    source_code?: true
  }

  export type Smart_contractsCountAggregateInputType = {
    id?: true
    tx_id?: true
    canonical?: true
    contract_id?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    clarity_version?: true
    source_code?: true
    abi?: true
    _all?: true
  }

  export type Smart_contractsAggregateArgs = {
    /**
     * Filter which smart_contracts to aggregate.
     * 
    **/
    where?: smart_contractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smart_contracts to fetch.
     * 
    **/
    orderBy?: Enumerable<smart_contractsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: smart_contractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smart_contracts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smart_contracts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned smart_contracts
    **/
    _count?: true | Smart_contractsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Smart_contractsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Smart_contractsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Smart_contractsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Smart_contractsMaxAggregateInputType
  }

  export type GetSmart_contractsAggregateType<T extends Smart_contractsAggregateArgs> = {
        [P in keyof T & keyof AggregateSmart_contracts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmart_contracts[P]>
      : GetScalarType<T[P], AggregateSmart_contracts[P]>
  }




  export type Smart_contractsGroupByArgs = {
    where?: smart_contractsWhereInput
    orderBy?: Enumerable<smart_contractsOrderByWithAggregationInput>
    by: Array<Smart_contractsScalarFieldEnum>
    having?: smart_contractsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Smart_contractsCountAggregateInputType | true
    _avg?: Smart_contractsAvgAggregateInputType
    _sum?: Smart_contractsSumAggregateInputType
    _min?: Smart_contractsMinAggregateInputType
    _max?: Smart_contractsMaxAggregateInputType
  }


  export type Smart_contractsGroupByOutputType = {
    id: number
    tx_id: Buffer
    canonical: boolean
    contract_id: string
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    clarity_version: number | null
    source_code: string
    abi: JsonValue
    _count: Smart_contractsCountAggregateOutputType | null
    _avg: Smart_contractsAvgAggregateOutputType | null
    _sum: Smart_contractsSumAggregateOutputType | null
    _min: Smart_contractsMinAggregateOutputType | null
    _max: Smart_contractsMaxAggregateOutputType | null
  }

  type GetSmart_contractsGroupByPayload<T extends Smart_contractsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Smart_contractsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Smart_contractsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Smart_contractsGroupByOutputType[P]>
            : GetScalarType<T[P], Smart_contractsGroupByOutputType[P]>
        }
      >
    >


  export type smart_contractsSelect = {
    id?: boolean
    tx_id?: boolean
    canonical?: boolean
    contract_id?: boolean
    block_height?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_canonical?: boolean
    clarity_version?: boolean
    source_code?: boolean
    abi?: boolean
  }


  export type smart_contractsGetPayload<S extends boolean | null | undefined | smart_contractsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? smart_contracts :
    S extends undefined ? never :
    S extends { include: any } & (smart_contractsArgs | smart_contractsFindManyArgs)
    ? smart_contracts 
    : S extends { select: any } & (smart_contractsArgs | smart_contractsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof smart_contracts ? smart_contracts[P] : never
  } 
      : smart_contracts


  type smart_contractsCountArgs = Merge<
    Omit<smart_contractsFindManyArgs, 'select' | 'include'> & {
      select?: Smart_contractsCountAggregateInputType | true
    }
  >

  export interface smart_contractsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Smart_contracts that matches the filter.
     * @param {smart_contractsFindUniqueArgs} args - Arguments to find a Smart_contracts
     * @example
     * // Get one Smart_contracts
     * const smart_contracts = await prisma.smart_contracts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends smart_contractsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, smart_contractsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'smart_contracts'> extends True ? Prisma__smart_contractsClient<smart_contractsGetPayload<T>> : Prisma__smart_contractsClient<smart_contractsGetPayload<T> | null, null>

    /**
     * Find one Smart_contracts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {smart_contractsFindUniqueOrThrowArgs} args - Arguments to find a Smart_contracts
     * @example
     * // Get one Smart_contracts
     * const smart_contracts = await prisma.smart_contracts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends smart_contractsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, smart_contractsFindUniqueOrThrowArgs>
    ): Prisma__smart_contractsClient<smart_contractsGetPayload<T>>

    /**
     * Find the first Smart_contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smart_contractsFindFirstArgs} args - Arguments to find a Smart_contracts
     * @example
     * // Get one Smart_contracts
     * const smart_contracts = await prisma.smart_contracts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends smart_contractsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, smart_contractsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'smart_contracts'> extends True ? Prisma__smart_contractsClient<smart_contractsGetPayload<T>> : Prisma__smart_contractsClient<smart_contractsGetPayload<T> | null, null>

    /**
     * Find the first Smart_contracts that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smart_contractsFindFirstOrThrowArgs} args - Arguments to find a Smart_contracts
     * @example
     * // Get one Smart_contracts
     * const smart_contracts = await prisma.smart_contracts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends smart_contractsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, smart_contractsFindFirstOrThrowArgs>
    ): Prisma__smart_contractsClient<smart_contractsGetPayload<T>>

    /**
     * Find zero or more Smart_contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smart_contractsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Smart_contracts
     * const smart_contracts = await prisma.smart_contracts.findMany()
     * 
     * // Get first 10 Smart_contracts
     * const smart_contracts = await prisma.smart_contracts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smart_contractsWithIdOnly = await prisma.smart_contracts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends smart_contractsFindManyArgs>(
      args?: SelectSubset<T, smart_contractsFindManyArgs>
    ): PrismaPromise<Array<smart_contractsGetPayload<T>>>

    /**
     * Create a Smart_contracts.
     * @param {smart_contractsCreateArgs} args - Arguments to create a Smart_contracts.
     * @example
     * // Create one Smart_contracts
     * const Smart_contracts = await prisma.smart_contracts.create({
     *   data: {
     *     // ... data to create a Smart_contracts
     *   }
     * })
     * 
    **/
    create<T extends smart_contractsCreateArgs>(
      args: SelectSubset<T, smart_contractsCreateArgs>
    ): Prisma__smart_contractsClient<smart_contractsGetPayload<T>>

    /**
     * Create many Smart_contracts.
     *     @param {smart_contractsCreateManyArgs} args - Arguments to create many Smart_contracts.
     *     @example
     *     // Create many Smart_contracts
     *     const smart_contracts = await prisma.smart_contracts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends smart_contractsCreateManyArgs>(
      args?: SelectSubset<T, smart_contractsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Smart_contracts.
     * @param {smart_contractsDeleteArgs} args - Arguments to delete one Smart_contracts.
     * @example
     * // Delete one Smart_contracts
     * const Smart_contracts = await prisma.smart_contracts.delete({
     *   where: {
     *     // ... filter to delete one Smart_contracts
     *   }
     * })
     * 
    **/
    delete<T extends smart_contractsDeleteArgs>(
      args: SelectSubset<T, smart_contractsDeleteArgs>
    ): Prisma__smart_contractsClient<smart_contractsGetPayload<T>>

    /**
     * Update one Smart_contracts.
     * @param {smart_contractsUpdateArgs} args - Arguments to update one Smart_contracts.
     * @example
     * // Update one Smart_contracts
     * const smart_contracts = await prisma.smart_contracts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends smart_contractsUpdateArgs>(
      args: SelectSubset<T, smart_contractsUpdateArgs>
    ): Prisma__smart_contractsClient<smart_contractsGetPayload<T>>

    /**
     * Delete zero or more Smart_contracts.
     * @param {smart_contractsDeleteManyArgs} args - Arguments to filter Smart_contracts to delete.
     * @example
     * // Delete a few Smart_contracts
     * const { count } = await prisma.smart_contracts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends smart_contractsDeleteManyArgs>(
      args?: SelectSubset<T, smart_contractsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Smart_contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smart_contractsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Smart_contracts
     * const smart_contracts = await prisma.smart_contracts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends smart_contractsUpdateManyArgs>(
      args: SelectSubset<T, smart_contractsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Smart_contracts.
     * @param {smart_contractsUpsertArgs} args - Arguments to update or create a Smart_contracts.
     * @example
     * // Update or create a Smart_contracts
     * const smart_contracts = await prisma.smart_contracts.upsert({
     *   create: {
     *     // ... data to create a Smart_contracts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Smart_contracts we want to update
     *   }
     * })
    **/
    upsert<T extends smart_contractsUpsertArgs>(
      args: SelectSubset<T, smart_contractsUpsertArgs>
    ): Prisma__smart_contractsClient<smart_contractsGetPayload<T>>

    /**
     * Count the number of Smart_contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smart_contractsCountArgs} args - Arguments to filter Smart_contracts to count.
     * @example
     * // Count the number of Smart_contracts
     * const count = await prisma.smart_contracts.count({
     *   where: {
     *     // ... the filter for the Smart_contracts we want to count
     *   }
     * })
    **/
    count<T extends smart_contractsCountArgs>(
      args?: Subset<T, smart_contractsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Smart_contractsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Smart_contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Smart_contractsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Smart_contractsAggregateArgs>(args: Subset<T, Smart_contractsAggregateArgs>): PrismaPromise<GetSmart_contractsAggregateType<T>>

    /**
     * Group by Smart_contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Smart_contractsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Smart_contractsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Smart_contractsGroupByArgs['orderBy'] }
        : { orderBy?: Smart_contractsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Smart_contractsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmart_contractsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for smart_contracts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__smart_contractsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * smart_contracts base type for findUnique actions
   */
  export type smart_contractsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the smart_contracts
     * 
    **/
    select?: smart_contractsSelect | null
    /**
     * Filter, which smart_contracts to fetch.
     * 
    **/
    where: smart_contractsWhereUniqueInput
  }

  /**
   * smart_contracts: findUnique
   */
  export interface smart_contractsFindUniqueArgs extends smart_contractsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * smart_contracts findUniqueOrThrow
   */
  export type smart_contractsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the smart_contracts
     * 
    **/
    select?: smart_contractsSelect | null
    /**
     * Filter, which smart_contracts to fetch.
     * 
    **/
    where: smart_contractsWhereUniqueInput
  }


  /**
   * smart_contracts base type for findFirst actions
   */
  export type smart_contractsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the smart_contracts
     * 
    **/
    select?: smart_contractsSelect | null
    /**
     * Filter, which smart_contracts to fetch.
     * 
    **/
    where?: smart_contractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smart_contracts to fetch.
     * 
    **/
    orderBy?: Enumerable<smart_contractsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for smart_contracts.
     * 
    **/
    cursor?: smart_contractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smart_contracts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smart_contracts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of smart_contracts.
     * 
    **/
    distinct?: Enumerable<Smart_contractsScalarFieldEnum>
  }

  /**
   * smart_contracts: findFirst
   */
  export interface smart_contractsFindFirstArgs extends smart_contractsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * smart_contracts findFirstOrThrow
   */
  export type smart_contractsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the smart_contracts
     * 
    **/
    select?: smart_contractsSelect | null
    /**
     * Filter, which smart_contracts to fetch.
     * 
    **/
    where?: smart_contractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smart_contracts to fetch.
     * 
    **/
    orderBy?: Enumerable<smart_contractsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for smart_contracts.
     * 
    **/
    cursor?: smart_contractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smart_contracts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smart_contracts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of smart_contracts.
     * 
    **/
    distinct?: Enumerable<Smart_contractsScalarFieldEnum>
  }


  /**
   * smart_contracts findMany
   */
  export type smart_contractsFindManyArgs = {
    /**
     * Select specific fields to fetch from the smart_contracts
     * 
    **/
    select?: smart_contractsSelect | null
    /**
     * Filter, which smart_contracts to fetch.
     * 
    **/
    where?: smart_contractsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smart_contracts to fetch.
     * 
    **/
    orderBy?: Enumerable<smart_contractsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing smart_contracts.
     * 
    **/
    cursor?: smart_contractsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smart_contracts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smart_contracts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Smart_contractsScalarFieldEnum>
  }


  /**
   * smart_contracts create
   */
  export type smart_contractsCreateArgs = {
    /**
     * Select specific fields to fetch from the smart_contracts
     * 
    **/
    select?: smart_contractsSelect | null
    /**
     * The data needed to create a smart_contracts.
     * 
    **/
    data: XOR<smart_contractsCreateInput, smart_contractsUncheckedCreateInput>
  }


  /**
   * smart_contracts createMany
   */
  export type smart_contractsCreateManyArgs = {
    /**
     * The data used to create many smart_contracts.
     * 
    **/
    data: Enumerable<smart_contractsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * smart_contracts update
   */
  export type smart_contractsUpdateArgs = {
    /**
     * Select specific fields to fetch from the smart_contracts
     * 
    **/
    select?: smart_contractsSelect | null
    /**
     * The data needed to update a smart_contracts.
     * 
    **/
    data: XOR<smart_contractsUpdateInput, smart_contractsUncheckedUpdateInput>
    /**
     * Choose, which smart_contracts to update.
     * 
    **/
    where: smart_contractsWhereUniqueInput
  }


  /**
   * smart_contracts updateMany
   */
  export type smart_contractsUpdateManyArgs = {
    /**
     * The data used to update smart_contracts.
     * 
    **/
    data: XOR<smart_contractsUpdateManyMutationInput, smart_contractsUncheckedUpdateManyInput>
    /**
     * Filter which smart_contracts to update
     * 
    **/
    where?: smart_contractsWhereInput
  }


  /**
   * smart_contracts upsert
   */
  export type smart_contractsUpsertArgs = {
    /**
     * Select specific fields to fetch from the smart_contracts
     * 
    **/
    select?: smart_contractsSelect | null
    /**
     * The filter to search for the smart_contracts to update in case it exists.
     * 
    **/
    where: smart_contractsWhereUniqueInput
    /**
     * In case the smart_contracts found by the `where` argument doesn't exist, create a new smart_contracts with this data.
     * 
    **/
    create: XOR<smart_contractsCreateInput, smart_contractsUncheckedCreateInput>
    /**
     * In case the smart_contracts was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<smart_contractsUpdateInput, smart_contractsUncheckedUpdateInput>
  }


  /**
   * smart_contracts delete
   */
  export type smart_contractsDeleteArgs = {
    /**
     * Select specific fields to fetch from the smart_contracts
     * 
    **/
    select?: smart_contractsSelect | null
    /**
     * Filter which smart_contracts to delete.
     * 
    **/
    where: smart_contractsWhereUniqueInput
  }


  /**
   * smart_contracts deleteMany
   */
  export type smart_contractsDeleteManyArgs = {
    /**
     * Filter which smart_contracts to delete
     * 
    **/
    where?: smart_contractsWhereInput
  }


  /**
   * smart_contracts without action
   */
  export type smart_contractsArgs = {
    /**
     * Select specific fields to fetch from the smart_contracts
     * 
    **/
    select?: smart_contractsSelect | null
  }



  /**
   * Model stx_events
   */


  export type AggregateStx_events = {
    _count: Stx_eventsCountAggregateOutputType | null
    _avg: Stx_eventsAvgAggregateOutputType | null
    _sum: Stx_eventsSumAggregateOutputType | null
    _min: Stx_eventsMinAggregateOutputType | null
    _max: Stx_eventsMaxAggregateOutputType | null
  }

  export type Stx_eventsAvgAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
    asset_event_type_id: number | null
    amount: number | null
  }

  export type Stx_eventsSumAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
    asset_event_type_id: number | null
    amount: bigint | null
  }

  export type Stx_eventsMinAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    asset_event_type_id: number | null
    amount: bigint | null
    sender: string | null
    recipient: string | null
    memo: Buffer | null
  }

  export type Stx_eventsMaxAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    asset_event_type_id: number | null
    amount: bigint | null
    sender: string | null
    recipient: string | null
    memo: Buffer | null
  }

  export type Stx_eventsCountAggregateOutputType = {
    id: number
    event_index: number
    tx_id: number
    tx_index: number
    block_height: number
    index_block_hash: number
    parent_index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    microblock_canonical: number
    canonical: number
    asset_event_type_id: number
    amount: number
    sender: number
    recipient: number
    memo: number
    _all: number
  }


  export type Stx_eventsAvgAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
    asset_event_type_id?: true
    amount?: true
  }

  export type Stx_eventsSumAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
    asset_event_type_id?: true
    amount?: true
  }

  export type Stx_eventsMinAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    asset_event_type_id?: true
    amount?: true
    sender?: true
    recipient?: true
    memo?: true
  }

  export type Stx_eventsMaxAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    asset_event_type_id?: true
    amount?: true
    sender?: true
    recipient?: true
    memo?: true
  }

  export type Stx_eventsCountAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    asset_event_type_id?: true
    amount?: true
    sender?: true
    recipient?: true
    memo?: true
    _all?: true
  }

  export type Stx_eventsAggregateArgs = {
    /**
     * Filter which stx_events to aggregate.
     * 
    **/
    where?: stx_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stx_events to fetch.
     * 
    **/
    orderBy?: Enumerable<stx_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: stx_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stx_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stx_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stx_events
    **/
    _count?: true | Stx_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Stx_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Stx_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Stx_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Stx_eventsMaxAggregateInputType
  }

  export type GetStx_eventsAggregateType<T extends Stx_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateStx_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStx_events[P]>
      : GetScalarType<T[P], AggregateStx_events[P]>
  }




  export type Stx_eventsGroupByArgs = {
    where?: stx_eventsWhereInput
    orderBy?: Enumerable<stx_eventsOrderByWithAggregationInput>
    by: Array<Stx_eventsScalarFieldEnum>
    having?: stx_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Stx_eventsCountAggregateInputType | true
    _avg?: Stx_eventsAvgAggregateInputType
    _sum?: Stx_eventsSumAggregateInputType
    _min?: Stx_eventsMinAggregateInputType
    _max?: Stx_eventsMaxAggregateInputType
  }


  export type Stx_eventsGroupByOutputType = {
    id: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    amount: bigint
    sender: string | null
    recipient: string | null
    memo: Buffer | null
    _count: Stx_eventsCountAggregateOutputType | null
    _avg: Stx_eventsAvgAggregateOutputType | null
    _sum: Stx_eventsSumAggregateOutputType | null
    _min: Stx_eventsMinAggregateOutputType | null
    _max: Stx_eventsMaxAggregateOutputType | null
  }

  type GetStx_eventsGroupByPayload<T extends Stx_eventsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Stx_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Stx_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stx_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Stx_eventsGroupByOutputType[P]>
        }
      >
    >


  export type stx_eventsSelect = {
    id?: boolean
    event_index?: boolean
    tx_id?: boolean
    tx_index?: boolean
    block_height?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_canonical?: boolean
    canonical?: boolean
    asset_event_type_id?: boolean
    amount?: boolean
    sender?: boolean
    recipient?: boolean
    memo?: boolean
  }


  export type stx_eventsGetPayload<S extends boolean | null | undefined | stx_eventsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? stx_events :
    S extends undefined ? never :
    S extends { include: any } & (stx_eventsArgs | stx_eventsFindManyArgs)
    ? stx_events 
    : S extends { select: any } & (stx_eventsArgs | stx_eventsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof stx_events ? stx_events[P] : never
  } 
      : stx_events


  type stx_eventsCountArgs = Merge<
    Omit<stx_eventsFindManyArgs, 'select' | 'include'> & {
      select?: Stx_eventsCountAggregateInputType | true
    }
  >

  export interface stx_eventsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Stx_events that matches the filter.
     * @param {stx_eventsFindUniqueArgs} args - Arguments to find a Stx_events
     * @example
     * // Get one Stx_events
     * const stx_events = await prisma.stx_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends stx_eventsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, stx_eventsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'stx_events'> extends True ? Prisma__stx_eventsClient<stx_eventsGetPayload<T>> : Prisma__stx_eventsClient<stx_eventsGetPayload<T> | null, null>

    /**
     * Find one Stx_events that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {stx_eventsFindUniqueOrThrowArgs} args - Arguments to find a Stx_events
     * @example
     * // Get one Stx_events
     * const stx_events = await prisma.stx_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends stx_eventsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, stx_eventsFindUniqueOrThrowArgs>
    ): Prisma__stx_eventsClient<stx_eventsGetPayload<T>>

    /**
     * Find the first Stx_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stx_eventsFindFirstArgs} args - Arguments to find a Stx_events
     * @example
     * // Get one Stx_events
     * const stx_events = await prisma.stx_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends stx_eventsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, stx_eventsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'stx_events'> extends True ? Prisma__stx_eventsClient<stx_eventsGetPayload<T>> : Prisma__stx_eventsClient<stx_eventsGetPayload<T> | null, null>

    /**
     * Find the first Stx_events that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stx_eventsFindFirstOrThrowArgs} args - Arguments to find a Stx_events
     * @example
     * // Get one Stx_events
     * const stx_events = await prisma.stx_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends stx_eventsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, stx_eventsFindFirstOrThrowArgs>
    ): Prisma__stx_eventsClient<stx_eventsGetPayload<T>>

    /**
     * Find zero or more Stx_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stx_eventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stx_events
     * const stx_events = await prisma.stx_events.findMany()
     * 
     * // Get first 10 Stx_events
     * const stx_events = await prisma.stx_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stx_eventsWithIdOnly = await prisma.stx_events.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends stx_eventsFindManyArgs>(
      args?: SelectSubset<T, stx_eventsFindManyArgs>
    ): PrismaPromise<Array<stx_eventsGetPayload<T>>>

    /**
     * Create a Stx_events.
     * @param {stx_eventsCreateArgs} args - Arguments to create a Stx_events.
     * @example
     * // Create one Stx_events
     * const Stx_events = await prisma.stx_events.create({
     *   data: {
     *     // ... data to create a Stx_events
     *   }
     * })
     * 
    **/
    create<T extends stx_eventsCreateArgs>(
      args: SelectSubset<T, stx_eventsCreateArgs>
    ): Prisma__stx_eventsClient<stx_eventsGetPayload<T>>

    /**
     * Create many Stx_events.
     *     @param {stx_eventsCreateManyArgs} args - Arguments to create many Stx_events.
     *     @example
     *     // Create many Stx_events
     *     const stx_events = await prisma.stx_events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends stx_eventsCreateManyArgs>(
      args?: SelectSubset<T, stx_eventsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Stx_events.
     * @param {stx_eventsDeleteArgs} args - Arguments to delete one Stx_events.
     * @example
     * // Delete one Stx_events
     * const Stx_events = await prisma.stx_events.delete({
     *   where: {
     *     // ... filter to delete one Stx_events
     *   }
     * })
     * 
    **/
    delete<T extends stx_eventsDeleteArgs>(
      args: SelectSubset<T, stx_eventsDeleteArgs>
    ): Prisma__stx_eventsClient<stx_eventsGetPayload<T>>

    /**
     * Update one Stx_events.
     * @param {stx_eventsUpdateArgs} args - Arguments to update one Stx_events.
     * @example
     * // Update one Stx_events
     * const stx_events = await prisma.stx_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends stx_eventsUpdateArgs>(
      args: SelectSubset<T, stx_eventsUpdateArgs>
    ): Prisma__stx_eventsClient<stx_eventsGetPayload<T>>

    /**
     * Delete zero or more Stx_events.
     * @param {stx_eventsDeleteManyArgs} args - Arguments to filter Stx_events to delete.
     * @example
     * // Delete a few Stx_events
     * const { count } = await prisma.stx_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends stx_eventsDeleteManyArgs>(
      args?: SelectSubset<T, stx_eventsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stx_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stx_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stx_events
     * const stx_events = await prisma.stx_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends stx_eventsUpdateManyArgs>(
      args: SelectSubset<T, stx_eventsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Stx_events.
     * @param {stx_eventsUpsertArgs} args - Arguments to update or create a Stx_events.
     * @example
     * // Update or create a Stx_events
     * const stx_events = await prisma.stx_events.upsert({
     *   create: {
     *     // ... data to create a Stx_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stx_events we want to update
     *   }
     * })
    **/
    upsert<T extends stx_eventsUpsertArgs>(
      args: SelectSubset<T, stx_eventsUpsertArgs>
    ): Prisma__stx_eventsClient<stx_eventsGetPayload<T>>

    /**
     * Count the number of Stx_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stx_eventsCountArgs} args - Arguments to filter Stx_events to count.
     * @example
     * // Count the number of Stx_events
     * const count = await prisma.stx_events.count({
     *   where: {
     *     // ... the filter for the Stx_events we want to count
     *   }
     * })
    **/
    count<T extends stx_eventsCountArgs>(
      args?: Subset<T, stx_eventsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stx_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stx_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stx_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Stx_eventsAggregateArgs>(args: Subset<T, Stx_eventsAggregateArgs>): PrismaPromise<GetStx_eventsAggregateType<T>>

    /**
     * Group by Stx_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stx_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Stx_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Stx_eventsGroupByArgs['orderBy'] }
        : { orderBy?: Stx_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Stx_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStx_eventsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for stx_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__stx_eventsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * stx_events base type for findUnique actions
   */
  export type stx_eventsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the stx_events
     * 
    **/
    select?: stx_eventsSelect | null
    /**
     * Filter, which stx_events to fetch.
     * 
    **/
    where: stx_eventsWhereUniqueInput
  }

  /**
   * stx_events: findUnique
   */
  export interface stx_eventsFindUniqueArgs extends stx_eventsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * stx_events findUniqueOrThrow
   */
  export type stx_eventsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the stx_events
     * 
    **/
    select?: stx_eventsSelect | null
    /**
     * Filter, which stx_events to fetch.
     * 
    **/
    where: stx_eventsWhereUniqueInput
  }


  /**
   * stx_events base type for findFirst actions
   */
  export type stx_eventsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the stx_events
     * 
    **/
    select?: stx_eventsSelect | null
    /**
     * Filter, which stx_events to fetch.
     * 
    **/
    where?: stx_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stx_events to fetch.
     * 
    **/
    orderBy?: Enumerable<stx_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stx_events.
     * 
    **/
    cursor?: stx_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stx_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stx_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stx_events.
     * 
    **/
    distinct?: Enumerable<Stx_eventsScalarFieldEnum>
  }

  /**
   * stx_events: findFirst
   */
  export interface stx_eventsFindFirstArgs extends stx_eventsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * stx_events findFirstOrThrow
   */
  export type stx_eventsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the stx_events
     * 
    **/
    select?: stx_eventsSelect | null
    /**
     * Filter, which stx_events to fetch.
     * 
    **/
    where?: stx_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stx_events to fetch.
     * 
    **/
    orderBy?: Enumerable<stx_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stx_events.
     * 
    **/
    cursor?: stx_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stx_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stx_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stx_events.
     * 
    **/
    distinct?: Enumerable<Stx_eventsScalarFieldEnum>
  }


  /**
   * stx_events findMany
   */
  export type stx_eventsFindManyArgs = {
    /**
     * Select specific fields to fetch from the stx_events
     * 
    **/
    select?: stx_eventsSelect | null
    /**
     * Filter, which stx_events to fetch.
     * 
    **/
    where?: stx_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stx_events to fetch.
     * 
    **/
    orderBy?: Enumerable<stx_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stx_events.
     * 
    **/
    cursor?: stx_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stx_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stx_events.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Stx_eventsScalarFieldEnum>
  }


  /**
   * stx_events create
   */
  export type stx_eventsCreateArgs = {
    /**
     * Select specific fields to fetch from the stx_events
     * 
    **/
    select?: stx_eventsSelect | null
    /**
     * The data needed to create a stx_events.
     * 
    **/
    data: XOR<stx_eventsCreateInput, stx_eventsUncheckedCreateInput>
  }


  /**
   * stx_events createMany
   */
  export type stx_eventsCreateManyArgs = {
    /**
     * The data used to create many stx_events.
     * 
    **/
    data: Enumerable<stx_eventsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * stx_events update
   */
  export type stx_eventsUpdateArgs = {
    /**
     * Select specific fields to fetch from the stx_events
     * 
    **/
    select?: stx_eventsSelect | null
    /**
     * The data needed to update a stx_events.
     * 
    **/
    data: XOR<stx_eventsUpdateInput, stx_eventsUncheckedUpdateInput>
    /**
     * Choose, which stx_events to update.
     * 
    **/
    where: stx_eventsWhereUniqueInput
  }


  /**
   * stx_events updateMany
   */
  export type stx_eventsUpdateManyArgs = {
    /**
     * The data used to update stx_events.
     * 
    **/
    data: XOR<stx_eventsUpdateManyMutationInput, stx_eventsUncheckedUpdateManyInput>
    /**
     * Filter which stx_events to update
     * 
    **/
    where?: stx_eventsWhereInput
  }


  /**
   * stx_events upsert
   */
  export type stx_eventsUpsertArgs = {
    /**
     * Select specific fields to fetch from the stx_events
     * 
    **/
    select?: stx_eventsSelect | null
    /**
     * The filter to search for the stx_events to update in case it exists.
     * 
    **/
    where: stx_eventsWhereUniqueInput
    /**
     * In case the stx_events found by the `where` argument doesn't exist, create a new stx_events with this data.
     * 
    **/
    create: XOR<stx_eventsCreateInput, stx_eventsUncheckedCreateInput>
    /**
     * In case the stx_events was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<stx_eventsUpdateInput, stx_eventsUncheckedUpdateInput>
  }


  /**
   * stx_events delete
   */
  export type stx_eventsDeleteArgs = {
    /**
     * Select specific fields to fetch from the stx_events
     * 
    **/
    select?: stx_eventsSelect | null
    /**
     * Filter which stx_events to delete.
     * 
    **/
    where: stx_eventsWhereUniqueInput
  }


  /**
   * stx_events deleteMany
   */
  export type stx_eventsDeleteManyArgs = {
    /**
     * Filter which stx_events to delete
     * 
    **/
    where?: stx_eventsWhereInput
  }


  /**
   * stx_events without action
   */
  export type stx_eventsArgs = {
    /**
     * Select specific fields to fetch from the stx_events
     * 
    **/
    select?: stx_eventsSelect | null
  }



  /**
   * Model stx_lock_events
   */


  export type AggregateStx_lock_events = {
    _count: Stx_lock_eventsCountAggregateOutputType | null
    _avg: Stx_lock_eventsAvgAggregateOutputType | null
    _sum: Stx_lock_eventsSumAggregateOutputType | null
    _min: Stx_lock_eventsMinAggregateOutputType | null
    _max: Stx_lock_eventsMaxAggregateOutputType | null
  }

  export type Stx_lock_eventsAvgAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
    locked_amount: Decimal | null
    unlock_height: number | null
  }

  export type Stx_lock_eventsSumAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_index: number | null
    block_height: number | null
    microblock_sequence: number | null
    locked_amount: Decimal | null
    unlock_height: number | null
  }

  export type Stx_lock_eventsMinAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    locked_amount: Decimal | null
    unlock_height: number | null
    locked_address: string | null
    contract_name: string | null
  }

  export type Stx_lock_eventsMaxAggregateOutputType = {
    id: number | null
    event_index: number | null
    tx_id: Buffer | null
    tx_index: number | null
    block_height: number | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
    canonical: boolean | null
    locked_amount: Decimal | null
    unlock_height: number | null
    locked_address: string | null
    contract_name: string | null
  }

  export type Stx_lock_eventsCountAggregateOutputType = {
    id: number
    event_index: number
    tx_id: number
    tx_index: number
    block_height: number
    index_block_hash: number
    parent_index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    microblock_canonical: number
    canonical: number
    locked_amount: number
    unlock_height: number
    locked_address: number
    contract_name: number
    _all: number
  }


  export type Stx_lock_eventsAvgAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
    locked_amount?: true
    unlock_height?: true
  }

  export type Stx_lock_eventsSumAggregateInputType = {
    id?: true
    event_index?: true
    tx_index?: true
    block_height?: true
    microblock_sequence?: true
    locked_amount?: true
    unlock_height?: true
  }

  export type Stx_lock_eventsMinAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    locked_amount?: true
    unlock_height?: true
    locked_address?: true
    contract_name?: true
  }

  export type Stx_lock_eventsMaxAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    locked_amount?: true
    unlock_height?: true
    locked_address?: true
    contract_name?: true
  }

  export type Stx_lock_eventsCountAggregateInputType = {
    id?: true
    event_index?: true
    tx_id?: true
    tx_index?: true
    block_height?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    canonical?: true
    locked_amount?: true
    unlock_height?: true
    locked_address?: true
    contract_name?: true
    _all?: true
  }

  export type Stx_lock_eventsAggregateArgs = {
    /**
     * Filter which stx_lock_events to aggregate.
     * 
    **/
    where?: stx_lock_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stx_lock_events to fetch.
     * 
    **/
    orderBy?: Enumerable<stx_lock_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: stx_lock_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stx_lock_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stx_lock_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stx_lock_events
    **/
    _count?: true | Stx_lock_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Stx_lock_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Stx_lock_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Stx_lock_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Stx_lock_eventsMaxAggregateInputType
  }

  export type GetStx_lock_eventsAggregateType<T extends Stx_lock_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateStx_lock_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStx_lock_events[P]>
      : GetScalarType<T[P], AggregateStx_lock_events[P]>
  }




  export type Stx_lock_eventsGroupByArgs = {
    where?: stx_lock_eventsWhereInput
    orderBy?: Enumerable<stx_lock_eventsOrderByWithAggregationInput>
    by: Array<Stx_lock_eventsScalarFieldEnum>
    having?: stx_lock_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Stx_lock_eventsCountAggregateInputType | true
    _avg?: Stx_lock_eventsAvgAggregateInputType
    _sum?: Stx_lock_eventsSumAggregateInputType
    _min?: Stx_lock_eventsMinAggregateInputType
    _max?: Stx_lock_eventsMaxAggregateInputType
  }


  export type Stx_lock_eventsGroupByOutputType = {
    id: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    locked_amount: Decimal
    unlock_height: number
    locked_address: string
    contract_name: string
    _count: Stx_lock_eventsCountAggregateOutputType | null
    _avg: Stx_lock_eventsAvgAggregateOutputType | null
    _sum: Stx_lock_eventsSumAggregateOutputType | null
    _min: Stx_lock_eventsMinAggregateOutputType | null
    _max: Stx_lock_eventsMaxAggregateOutputType | null
  }

  type GetStx_lock_eventsGroupByPayload<T extends Stx_lock_eventsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Stx_lock_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Stx_lock_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Stx_lock_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Stx_lock_eventsGroupByOutputType[P]>
        }
      >
    >


  export type stx_lock_eventsSelect = {
    id?: boolean
    event_index?: boolean
    tx_id?: boolean
    tx_index?: boolean
    block_height?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_canonical?: boolean
    canonical?: boolean
    locked_amount?: boolean
    unlock_height?: boolean
    locked_address?: boolean
    contract_name?: boolean
  }


  export type stx_lock_eventsGetPayload<S extends boolean | null | undefined | stx_lock_eventsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? stx_lock_events :
    S extends undefined ? never :
    S extends { include: any } & (stx_lock_eventsArgs | stx_lock_eventsFindManyArgs)
    ? stx_lock_events 
    : S extends { select: any } & (stx_lock_eventsArgs | stx_lock_eventsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof stx_lock_events ? stx_lock_events[P] : never
  } 
      : stx_lock_events


  type stx_lock_eventsCountArgs = Merge<
    Omit<stx_lock_eventsFindManyArgs, 'select' | 'include'> & {
      select?: Stx_lock_eventsCountAggregateInputType | true
    }
  >

  export interface stx_lock_eventsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Stx_lock_events that matches the filter.
     * @param {stx_lock_eventsFindUniqueArgs} args - Arguments to find a Stx_lock_events
     * @example
     * // Get one Stx_lock_events
     * const stx_lock_events = await prisma.stx_lock_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends stx_lock_eventsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, stx_lock_eventsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'stx_lock_events'> extends True ? Prisma__stx_lock_eventsClient<stx_lock_eventsGetPayload<T>> : Prisma__stx_lock_eventsClient<stx_lock_eventsGetPayload<T> | null, null>

    /**
     * Find one Stx_lock_events that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {stx_lock_eventsFindUniqueOrThrowArgs} args - Arguments to find a Stx_lock_events
     * @example
     * // Get one Stx_lock_events
     * const stx_lock_events = await prisma.stx_lock_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends stx_lock_eventsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, stx_lock_eventsFindUniqueOrThrowArgs>
    ): Prisma__stx_lock_eventsClient<stx_lock_eventsGetPayload<T>>

    /**
     * Find the first Stx_lock_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stx_lock_eventsFindFirstArgs} args - Arguments to find a Stx_lock_events
     * @example
     * // Get one Stx_lock_events
     * const stx_lock_events = await prisma.stx_lock_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends stx_lock_eventsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, stx_lock_eventsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'stx_lock_events'> extends True ? Prisma__stx_lock_eventsClient<stx_lock_eventsGetPayload<T>> : Prisma__stx_lock_eventsClient<stx_lock_eventsGetPayload<T> | null, null>

    /**
     * Find the first Stx_lock_events that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stx_lock_eventsFindFirstOrThrowArgs} args - Arguments to find a Stx_lock_events
     * @example
     * // Get one Stx_lock_events
     * const stx_lock_events = await prisma.stx_lock_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends stx_lock_eventsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, stx_lock_eventsFindFirstOrThrowArgs>
    ): Prisma__stx_lock_eventsClient<stx_lock_eventsGetPayload<T>>

    /**
     * Find zero or more Stx_lock_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stx_lock_eventsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stx_lock_events
     * const stx_lock_events = await prisma.stx_lock_events.findMany()
     * 
     * // Get first 10 Stx_lock_events
     * const stx_lock_events = await prisma.stx_lock_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stx_lock_eventsWithIdOnly = await prisma.stx_lock_events.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends stx_lock_eventsFindManyArgs>(
      args?: SelectSubset<T, stx_lock_eventsFindManyArgs>
    ): PrismaPromise<Array<stx_lock_eventsGetPayload<T>>>

    /**
     * Create a Stx_lock_events.
     * @param {stx_lock_eventsCreateArgs} args - Arguments to create a Stx_lock_events.
     * @example
     * // Create one Stx_lock_events
     * const Stx_lock_events = await prisma.stx_lock_events.create({
     *   data: {
     *     // ... data to create a Stx_lock_events
     *   }
     * })
     * 
    **/
    create<T extends stx_lock_eventsCreateArgs>(
      args: SelectSubset<T, stx_lock_eventsCreateArgs>
    ): Prisma__stx_lock_eventsClient<stx_lock_eventsGetPayload<T>>

    /**
     * Create many Stx_lock_events.
     *     @param {stx_lock_eventsCreateManyArgs} args - Arguments to create many Stx_lock_events.
     *     @example
     *     // Create many Stx_lock_events
     *     const stx_lock_events = await prisma.stx_lock_events.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends stx_lock_eventsCreateManyArgs>(
      args?: SelectSubset<T, stx_lock_eventsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Stx_lock_events.
     * @param {stx_lock_eventsDeleteArgs} args - Arguments to delete one Stx_lock_events.
     * @example
     * // Delete one Stx_lock_events
     * const Stx_lock_events = await prisma.stx_lock_events.delete({
     *   where: {
     *     // ... filter to delete one Stx_lock_events
     *   }
     * })
     * 
    **/
    delete<T extends stx_lock_eventsDeleteArgs>(
      args: SelectSubset<T, stx_lock_eventsDeleteArgs>
    ): Prisma__stx_lock_eventsClient<stx_lock_eventsGetPayload<T>>

    /**
     * Update one Stx_lock_events.
     * @param {stx_lock_eventsUpdateArgs} args - Arguments to update one Stx_lock_events.
     * @example
     * // Update one Stx_lock_events
     * const stx_lock_events = await prisma.stx_lock_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends stx_lock_eventsUpdateArgs>(
      args: SelectSubset<T, stx_lock_eventsUpdateArgs>
    ): Prisma__stx_lock_eventsClient<stx_lock_eventsGetPayload<T>>

    /**
     * Delete zero or more Stx_lock_events.
     * @param {stx_lock_eventsDeleteManyArgs} args - Arguments to filter Stx_lock_events to delete.
     * @example
     * // Delete a few Stx_lock_events
     * const { count } = await prisma.stx_lock_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends stx_lock_eventsDeleteManyArgs>(
      args?: SelectSubset<T, stx_lock_eventsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stx_lock_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stx_lock_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stx_lock_events
     * const stx_lock_events = await prisma.stx_lock_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends stx_lock_eventsUpdateManyArgs>(
      args: SelectSubset<T, stx_lock_eventsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Stx_lock_events.
     * @param {stx_lock_eventsUpsertArgs} args - Arguments to update or create a Stx_lock_events.
     * @example
     * // Update or create a Stx_lock_events
     * const stx_lock_events = await prisma.stx_lock_events.upsert({
     *   create: {
     *     // ... data to create a Stx_lock_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stx_lock_events we want to update
     *   }
     * })
    **/
    upsert<T extends stx_lock_eventsUpsertArgs>(
      args: SelectSubset<T, stx_lock_eventsUpsertArgs>
    ): Prisma__stx_lock_eventsClient<stx_lock_eventsGetPayload<T>>

    /**
     * Count the number of Stx_lock_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {stx_lock_eventsCountArgs} args - Arguments to filter Stx_lock_events to count.
     * @example
     * // Count the number of Stx_lock_events
     * const count = await prisma.stx_lock_events.count({
     *   where: {
     *     // ... the filter for the Stx_lock_events we want to count
     *   }
     * })
    **/
    count<T extends stx_lock_eventsCountArgs>(
      args?: Subset<T, stx_lock_eventsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Stx_lock_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stx_lock_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stx_lock_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Stx_lock_eventsAggregateArgs>(args: Subset<T, Stx_lock_eventsAggregateArgs>): PrismaPromise<GetStx_lock_eventsAggregateType<T>>

    /**
     * Group by Stx_lock_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Stx_lock_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Stx_lock_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Stx_lock_eventsGroupByArgs['orderBy'] }
        : { orderBy?: Stx_lock_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Stx_lock_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStx_lock_eventsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for stx_lock_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__stx_lock_eventsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * stx_lock_events base type for findUnique actions
   */
  export type stx_lock_eventsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the stx_lock_events
     * 
    **/
    select?: stx_lock_eventsSelect | null
    /**
     * Filter, which stx_lock_events to fetch.
     * 
    **/
    where: stx_lock_eventsWhereUniqueInput
  }

  /**
   * stx_lock_events: findUnique
   */
  export interface stx_lock_eventsFindUniqueArgs extends stx_lock_eventsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * stx_lock_events findUniqueOrThrow
   */
  export type stx_lock_eventsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the stx_lock_events
     * 
    **/
    select?: stx_lock_eventsSelect | null
    /**
     * Filter, which stx_lock_events to fetch.
     * 
    **/
    where: stx_lock_eventsWhereUniqueInput
  }


  /**
   * stx_lock_events base type for findFirst actions
   */
  export type stx_lock_eventsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the stx_lock_events
     * 
    **/
    select?: stx_lock_eventsSelect | null
    /**
     * Filter, which stx_lock_events to fetch.
     * 
    **/
    where?: stx_lock_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stx_lock_events to fetch.
     * 
    **/
    orderBy?: Enumerable<stx_lock_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stx_lock_events.
     * 
    **/
    cursor?: stx_lock_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stx_lock_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stx_lock_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stx_lock_events.
     * 
    **/
    distinct?: Enumerable<Stx_lock_eventsScalarFieldEnum>
  }

  /**
   * stx_lock_events: findFirst
   */
  export interface stx_lock_eventsFindFirstArgs extends stx_lock_eventsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * stx_lock_events findFirstOrThrow
   */
  export type stx_lock_eventsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the stx_lock_events
     * 
    **/
    select?: stx_lock_eventsSelect | null
    /**
     * Filter, which stx_lock_events to fetch.
     * 
    **/
    where?: stx_lock_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stx_lock_events to fetch.
     * 
    **/
    orderBy?: Enumerable<stx_lock_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stx_lock_events.
     * 
    **/
    cursor?: stx_lock_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stx_lock_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stx_lock_events.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stx_lock_events.
     * 
    **/
    distinct?: Enumerable<Stx_lock_eventsScalarFieldEnum>
  }


  /**
   * stx_lock_events findMany
   */
  export type stx_lock_eventsFindManyArgs = {
    /**
     * Select specific fields to fetch from the stx_lock_events
     * 
    **/
    select?: stx_lock_eventsSelect | null
    /**
     * Filter, which stx_lock_events to fetch.
     * 
    **/
    where?: stx_lock_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stx_lock_events to fetch.
     * 
    **/
    orderBy?: Enumerable<stx_lock_eventsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stx_lock_events.
     * 
    **/
    cursor?: stx_lock_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stx_lock_events from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stx_lock_events.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Stx_lock_eventsScalarFieldEnum>
  }


  /**
   * stx_lock_events create
   */
  export type stx_lock_eventsCreateArgs = {
    /**
     * Select specific fields to fetch from the stx_lock_events
     * 
    **/
    select?: stx_lock_eventsSelect | null
    /**
     * The data needed to create a stx_lock_events.
     * 
    **/
    data: XOR<stx_lock_eventsCreateInput, stx_lock_eventsUncheckedCreateInput>
  }


  /**
   * stx_lock_events createMany
   */
  export type stx_lock_eventsCreateManyArgs = {
    /**
     * The data used to create many stx_lock_events.
     * 
    **/
    data: Enumerable<stx_lock_eventsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * stx_lock_events update
   */
  export type stx_lock_eventsUpdateArgs = {
    /**
     * Select specific fields to fetch from the stx_lock_events
     * 
    **/
    select?: stx_lock_eventsSelect | null
    /**
     * The data needed to update a stx_lock_events.
     * 
    **/
    data: XOR<stx_lock_eventsUpdateInput, stx_lock_eventsUncheckedUpdateInput>
    /**
     * Choose, which stx_lock_events to update.
     * 
    **/
    where: stx_lock_eventsWhereUniqueInput
  }


  /**
   * stx_lock_events updateMany
   */
  export type stx_lock_eventsUpdateManyArgs = {
    /**
     * The data used to update stx_lock_events.
     * 
    **/
    data: XOR<stx_lock_eventsUpdateManyMutationInput, stx_lock_eventsUncheckedUpdateManyInput>
    /**
     * Filter which stx_lock_events to update
     * 
    **/
    where?: stx_lock_eventsWhereInput
  }


  /**
   * stx_lock_events upsert
   */
  export type stx_lock_eventsUpsertArgs = {
    /**
     * Select specific fields to fetch from the stx_lock_events
     * 
    **/
    select?: stx_lock_eventsSelect | null
    /**
     * The filter to search for the stx_lock_events to update in case it exists.
     * 
    **/
    where: stx_lock_eventsWhereUniqueInput
    /**
     * In case the stx_lock_events found by the `where` argument doesn't exist, create a new stx_lock_events with this data.
     * 
    **/
    create: XOR<stx_lock_eventsCreateInput, stx_lock_eventsUncheckedCreateInput>
    /**
     * In case the stx_lock_events was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<stx_lock_eventsUpdateInput, stx_lock_eventsUncheckedUpdateInput>
  }


  /**
   * stx_lock_events delete
   */
  export type stx_lock_eventsDeleteArgs = {
    /**
     * Select specific fields to fetch from the stx_lock_events
     * 
    **/
    select?: stx_lock_eventsSelect | null
    /**
     * Filter which stx_lock_events to delete.
     * 
    **/
    where: stx_lock_eventsWhereUniqueInput
  }


  /**
   * stx_lock_events deleteMany
   */
  export type stx_lock_eventsDeleteManyArgs = {
    /**
     * Filter which stx_lock_events to delete
     * 
    **/
    where?: stx_lock_eventsWhereInput
  }


  /**
   * stx_lock_events without action
   */
  export type stx_lock_eventsArgs = {
    /**
     * Select specific fields to fetch from the stx_lock_events
     * 
    **/
    select?: stx_lock_eventsSelect | null
  }



  /**
   * Model subdomains
   */


  export type AggregateSubdomains = {
    _count: SubdomainsCountAggregateOutputType | null
    _avg: SubdomainsAvgAggregateOutputType | null
    _sum: SubdomainsSumAggregateOutputType | null
    _min: SubdomainsMinAggregateOutputType | null
    _max: SubdomainsMaxAggregateOutputType | null
  }

  export type SubdomainsAvgAggregateOutputType = {
    id: number | null
    parent_zonefile_index: number | null
    tx_index: number | null
    block_height: number | null
    zonefile_offset: number | null
    microblock_sequence: number | null
  }

  export type SubdomainsSumAggregateOutputType = {
    id: number | null
    parent_zonefile_index: number | null
    tx_index: number | null
    block_height: number | null
    zonefile_offset: number | null
    microblock_sequence: number | null
  }

  export type SubdomainsMinAggregateOutputType = {
    id: number | null
    name: string | null
    namespace_id: string | null
    fully_qualified_subdomain: string | null
    owner: string | null
    zonefile_hash: string | null
    parent_zonefile_hash: string | null
    parent_zonefile_index: number | null
    tx_index: number | null
    block_height: number | null
    zonefile_offset: number | null
    resolver: string | null
    tx_id: Buffer | null
    canonical: boolean | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
  }

  export type SubdomainsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    namespace_id: string | null
    fully_qualified_subdomain: string | null
    owner: string | null
    zonefile_hash: string | null
    parent_zonefile_hash: string | null
    parent_zonefile_index: number | null
    tx_index: number | null
    block_height: number | null
    zonefile_offset: number | null
    resolver: string | null
    tx_id: Buffer | null
    canonical: boolean | null
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    microblock_hash: Buffer | null
    microblock_sequence: number | null
    microblock_canonical: boolean | null
  }

  export type SubdomainsCountAggregateOutputType = {
    id: number
    name: number
    namespace_id: number
    fully_qualified_subdomain: number
    owner: number
    zonefile_hash: number
    parent_zonefile_hash: number
    parent_zonefile_index: number
    tx_index: number
    block_height: number
    zonefile_offset: number
    resolver: number
    tx_id: number
    canonical: number
    index_block_hash: number
    parent_index_block_hash: number
    microblock_hash: number
    microblock_sequence: number
    microblock_canonical: number
    _all: number
  }


  export type SubdomainsAvgAggregateInputType = {
    id?: true
    parent_zonefile_index?: true
    tx_index?: true
    block_height?: true
    zonefile_offset?: true
    microblock_sequence?: true
  }

  export type SubdomainsSumAggregateInputType = {
    id?: true
    parent_zonefile_index?: true
    tx_index?: true
    block_height?: true
    zonefile_offset?: true
    microblock_sequence?: true
  }

  export type SubdomainsMinAggregateInputType = {
    id?: true
    name?: true
    namespace_id?: true
    fully_qualified_subdomain?: true
    owner?: true
    zonefile_hash?: true
    parent_zonefile_hash?: true
    parent_zonefile_index?: true
    tx_index?: true
    block_height?: true
    zonefile_offset?: true
    resolver?: true
    tx_id?: true
    canonical?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
  }

  export type SubdomainsMaxAggregateInputType = {
    id?: true
    name?: true
    namespace_id?: true
    fully_qualified_subdomain?: true
    owner?: true
    zonefile_hash?: true
    parent_zonefile_hash?: true
    parent_zonefile_index?: true
    tx_index?: true
    block_height?: true
    zonefile_offset?: true
    resolver?: true
    tx_id?: true
    canonical?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
  }

  export type SubdomainsCountAggregateInputType = {
    id?: true
    name?: true
    namespace_id?: true
    fully_qualified_subdomain?: true
    owner?: true
    zonefile_hash?: true
    parent_zonefile_hash?: true
    parent_zonefile_index?: true
    tx_index?: true
    block_height?: true
    zonefile_offset?: true
    resolver?: true
    tx_id?: true
    canonical?: true
    index_block_hash?: true
    parent_index_block_hash?: true
    microblock_hash?: true
    microblock_sequence?: true
    microblock_canonical?: true
    _all?: true
  }

  export type SubdomainsAggregateArgs = {
    /**
     * Filter which subdomains to aggregate.
     * 
    **/
    where?: subdomainsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subdomains to fetch.
     * 
    **/
    orderBy?: Enumerable<subdomainsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: subdomainsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subdomains from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subdomains.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subdomains
    **/
    _count?: true | SubdomainsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubdomainsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubdomainsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubdomainsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubdomainsMaxAggregateInputType
  }

  export type GetSubdomainsAggregateType<T extends SubdomainsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubdomains]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubdomains[P]>
      : GetScalarType<T[P], AggregateSubdomains[P]>
  }




  export type SubdomainsGroupByArgs = {
    where?: subdomainsWhereInput
    orderBy?: Enumerable<subdomainsOrderByWithAggregationInput>
    by: Array<SubdomainsScalarFieldEnum>
    having?: subdomainsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubdomainsCountAggregateInputType | true
    _avg?: SubdomainsAvgAggregateInputType
    _sum?: SubdomainsSumAggregateInputType
    _min?: SubdomainsMinAggregateInputType
    _max?: SubdomainsMaxAggregateInputType
  }


  export type SubdomainsGroupByOutputType = {
    id: number
    name: string
    namespace_id: string
    fully_qualified_subdomain: string
    owner: string
    zonefile_hash: string
    parent_zonefile_hash: string
    parent_zonefile_index: number
    tx_index: number
    block_height: number
    zonefile_offset: number | null
    resolver: string | null
    tx_id: Buffer | null
    canonical: boolean
    index_block_hash: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    _count: SubdomainsCountAggregateOutputType | null
    _avg: SubdomainsAvgAggregateOutputType | null
    _sum: SubdomainsSumAggregateOutputType | null
    _min: SubdomainsMinAggregateOutputType | null
    _max: SubdomainsMaxAggregateOutputType | null
  }

  type GetSubdomainsGroupByPayload<T extends SubdomainsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SubdomainsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubdomainsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubdomainsGroupByOutputType[P]>
            : GetScalarType<T[P], SubdomainsGroupByOutputType[P]>
        }
      >
    >


  export type subdomainsSelect = {
    id?: boolean
    name?: boolean
    namespace_id?: boolean
    fully_qualified_subdomain?: boolean
    owner?: boolean
    zonefile_hash?: boolean
    parent_zonefile_hash?: boolean
    parent_zonefile_index?: boolean
    tx_index?: boolean
    block_height?: boolean
    zonefile_offset?: boolean
    resolver?: boolean
    tx_id?: boolean
    canonical?: boolean
    index_block_hash?: boolean
    parent_index_block_hash?: boolean
    microblock_hash?: boolean
    microblock_sequence?: boolean
    microblock_canonical?: boolean
  }


  export type subdomainsGetPayload<S extends boolean | null | undefined | subdomainsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? subdomains :
    S extends undefined ? never :
    S extends { include: any } & (subdomainsArgs | subdomainsFindManyArgs)
    ? subdomains 
    : S extends { select: any } & (subdomainsArgs | subdomainsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof subdomains ? subdomains[P] : never
  } 
      : subdomains


  type subdomainsCountArgs = Merge<
    Omit<subdomainsFindManyArgs, 'select' | 'include'> & {
      select?: SubdomainsCountAggregateInputType | true
    }
  >

  export interface subdomainsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Subdomains that matches the filter.
     * @param {subdomainsFindUniqueArgs} args - Arguments to find a Subdomains
     * @example
     * // Get one Subdomains
     * const subdomains = await prisma.subdomains.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subdomainsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subdomainsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subdomains'> extends True ? Prisma__subdomainsClient<subdomainsGetPayload<T>> : Prisma__subdomainsClient<subdomainsGetPayload<T> | null, null>

    /**
     * Find one Subdomains that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {subdomainsFindUniqueOrThrowArgs} args - Arguments to find a Subdomains
     * @example
     * // Get one Subdomains
     * const subdomains = await prisma.subdomains.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subdomainsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subdomainsFindUniqueOrThrowArgs>
    ): Prisma__subdomainsClient<subdomainsGetPayload<T>>

    /**
     * Find the first Subdomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subdomainsFindFirstArgs} args - Arguments to find a Subdomains
     * @example
     * // Get one Subdomains
     * const subdomains = await prisma.subdomains.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subdomainsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subdomainsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subdomains'> extends True ? Prisma__subdomainsClient<subdomainsGetPayload<T>> : Prisma__subdomainsClient<subdomainsGetPayload<T> | null, null>

    /**
     * Find the first Subdomains that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subdomainsFindFirstOrThrowArgs} args - Arguments to find a Subdomains
     * @example
     * // Get one Subdomains
     * const subdomains = await prisma.subdomains.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subdomainsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subdomainsFindFirstOrThrowArgs>
    ): Prisma__subdomainsClient<subdomainsGetPayload<T>>

    /**
     * Find zero or more Subdomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subdomainsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subdomains
     * const subdomains = await prisma.subdomains.findMany()
     * 
     * // Get first 10 Subdomains
     * const subdomains = await prisma.subdomains.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subdomainsWithIdOnly = await prisma.subdomains.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subdomainsFindManyArgs>(
      args?: SelectSubset<T, subdomainsFindManyArgs>
    ): PrismaPromise<Array<subdomainsGetPayload<T>>>

    /**
     * Create a Subdomains.
     * @param {subdomainsCreateArgs} args - Arguments to create a Subdomains.
     * @example
     * // Create one Subdomains
     * const Subdomains = await prisma.subdomains.create({
     *   data: {
     *     // ... data to create a Subdomains
     *   }
     * })
     * 
    **/
    create<T extends subdomainsCreateArgs>(
      args: SelectSubset<T, subdomainsCreateArgs>
    ): Prisma__subdomainsClient<subdomainsGetPayload<T>>

    /**
     * Create many Subdomains.
     *     @param {subdomainsCreateManyArgs} args - Arguments to create many Subdomains.
     *     @example
     *     // Create many Subdomains
     *     const subdomains = await prisma.subdomains.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends subdomainsCreateManyArgs>(
      args?: SelectSubset<T, subdomainsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Subdomains.
     * @param {subdomainsDeleteArgs} args - Arguments to delete one Subdomains.
     * @example
     * // Delete one Subdomains
     * const Subdomains = await prisma.subdomains.delete({
     *   where: {
     *     // ... filter to delete one Subdomains
     *   }
     * })
     * 
    **/
    delete<T extends subdomainsDeleteArgs>(
      args: SelectSubset<T, subdomainsDeleteArgs>
    ): Prisma__subdomainsClient<subdomainsGetPayload<T>>

    /**
     * Update one Subdomains.
     * @param {subdomainsUpdateArgs} args - Arguments to update one Subdomains.
     * @example
     * // Update one Subdomains
     * const subdomains = await prisma.subdomains.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subdomainsUpdateArgs>(
      args: SelectSubset<T, subdomainsUpdateArgs>
    ): Prisma__subdomainsClient<subdomainsGetPayload<T>>

    /**
     * Delete zero or more Subdomains.
     * @param {subdomainsDeleteManyArgs} args - Arguments to filter Subdomains to delete.
     * @example
     * // Delete a few Subdomains
     * const { count } = await prisma.subdomains.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subdomainsDeleteManyArgs>(
      args?: SelectSubset<T, subdomainsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subdomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subdomainsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subdomains
     * const subdomains = await prisma.subdomains.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subdomainsUpdateManyArgs>(
      args: SelectSubset<T, subdomainsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Subdomains.
     * @param {subdomainsUpsertArgs} args - Arguments to update or create a Subdomains.
     * @example
     * // Update or create a Subdomains
     * const subdomains = await prisma.subdomains.upsert({
     *   create: {
     *     // ... data to create a Subdomains
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subdomains we want to update
     *   }
     * })
    **/
    upsert<T extends subdomainsUpsertArgs>(
      args: SelectSubset<T, subdomainsUpsertArgs>
    ): Prisma__subdomainsClient<subdomainsGetPayload<T>>

    /**
     * Count the number of Subdomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subdomainsCountArgs} args - Arguments to filter Subdomains to count.
     * @example
     * // Count the number of Subdomains
     * const count = await prisma.subdomains.count({
     *   where: {
     *     // ... the filter for the Subdomains we want to count
     *   }
     * })
    **/
    count<T extends subdomainsCountArgs>(
      args?: Subset<T, subdomainsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubdomainsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subdomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdomainsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubdomainsAggregateArgs>(args: Subset<T, SubdomainsAggregateArgs>): PrismaPromise<GetSubdomainsAggregateType<T>>

    /**
     * Group by Subdomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubdomainsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubdomainsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubdomainsGroupByArgs['orderBy'] }
        : { orderBy?: SubdomainsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubdomainsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubdomainsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for subdomains.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subdomainsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * subdomains base type for findUnique actions
   */
  export type subdomainsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subdomains
     * 
    **/
    select?: subdomainsSelect | null
    /**
     * Filter, which subdomains to fetch.
     * 
    **/
    where: subdomainsWhereUniqueInput
  }

  /**
   * subdomains: findUnique
   */
  export interface subdomainsFindUniqueArgs extends subdomainsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subdomains findUniqueOrThrow
   */
  export type subdomainsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the subdomains
     * 
    **/
    select?: subdomainsSelect | null
    /**
     * Filter, which subdomains to fetch.
     * 
    **/
    where: subdomainsWhereUniqueInput
  }


  /**
   * subdomains base type for findFirst actions
   */
  export type subdomainsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subdomains
     * 
    **/
    select?: subdomainsSelect | null
    /**
     * Filter, which subdomains to fetch.
     * 
    **/
    where?: subdomainsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subdomains to fetch.
     * 
    **/
    orderBy?: Enumerable<subdomainsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subdomains.
     * 
    **/
    cursor?: subdomainsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subdomains from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subdomains.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subdomains.
     * 
    **/
    distinct?: Enumerable<SubdomainsScalarFieldEnum>
  }

  /**
   * subdomains: findFirst
   */
  export interface subdomainsFindFirstArgs extends subdomainsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subdomains findFirstOrThrow
   */
  export type subdomainsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the subdomains
     * 
    **/
    select?: subdomainsSelect | null
    /**
     * Filter, which subdomains to fetch.
     * 
    **/
    where?: subdomainsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subdomains to fetch.
     * 
    **/
    orderBy?: Enumerable<subdomainsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subdomains.
     * 
    **/
    cursor?: subdomainsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subdomains from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subdomains.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subdomains.
     * 
    **/
    distinct?: Enumerable<SubdomainsScalarFieldEnum>
  }


  /**
   * subdomains findMany
   */
  export type subdomainsFindManyArgs = {
    /**
     * Select specific fields to fetch from the subdomains
     * 
    **/
    select?: subdomainsSelect | null
    /**
     * Filter, which subdomains to fetch.
     * 
    **/
    where?: subdomainsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subdomains to fetch.
     * 
    **/
    orderBy?: Enumerable<subdomainsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subdomains.
     * 
    **/
    cursor?: subdomainsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subdomains from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subdomains.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SubdomainsScalarFieldEnum>
  }


  /**
   * subdomains create
   */
  export type subdomainsCreateArgs = {
    /**
     * Select specific fields to fetch from the subdomains
     * 
    **/
    select?: subdomainsSelect | null
    /**
     * The data needed to create a subdomains.
     * 
    **/
    data: XOR<subdomainsCreateInput, subdomainsUncheckedCreateInput>
  }


  /**
   * subdomains createMany
   */
  export type subdomainsCreateManyArgs = {
    /**
     * The data used to create many subdomains.
     * 
    **/
    data: Enumerable<subdomainsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * subdomains update
   */
  export type subdomainsUpdateArgs = {
    /**
     * Select specific fields to fetch from the subdomains
     * 
    **/
    select?: subdomainsSelect | null
    /**
     * The data needed to update a subdomains.
     * 
    **/
    data: XOR<subdomainsUpdateInput, subdomainsUncheckedUpdateInput>
    /**
     * Choose, which subdomains to update.
     * 
    **/
    where: subdomainsWhereUniqueInput
  }


  /**
   * subdomains updateMany
   */
  export type subdomainsUpdateManyArgs = {
    /**
     * The data used to update subdomains.
     * 
    **/
    data: XOR<subdomainsUpdateManyMutationInput, subdomainsUncheckedUpdateManyInput>
    /**
     * Filter which subdomains to update
     * 
    **/
    where?: subdomainsWhereInput
  }


  /**
   * subdomains upsert
   */
  export type subdomainsUpsertArgs = {
    /**
     * Select specific fields to fetch from the subdomains
     * 
    **/
    select?: subdomainsSelect | null
    /**
     * The filter to search for the subdomains to update in case it exists.
     * 
    **/
    where: subdomainsWhereUniqueInput
    /**
     * In case the subdomains found by the `where` argument doesn't exist, create a new subdomains with this data.
     * 
    **/
    create: XOR<subdomainsCreateInput, subdomainsUncheckedCreateInput>
    /**
     * In case the subdomains was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<subdomainsUpdateInput, subdomainsUncheckedUpdateInput>
  }


  /**
   * subdomains delete
   */
  export type subdomainsDeleteArgs = {
    /**
     * Select specific fields to fetch from the subdomains
     * 
    **/
    select?: subdomainsSelect | null
    /**
     * Filter which subdomains to delete.
     * 
    **/
    where: subdomainsWhereUniqueInput
  }


  /**
   * subdomains deleteMany
   */
  export type subdomainsDeleteManyArgs = {
    /**
     * Filter which subdomains to delete
     * 
    **/
    where?: subdomainsWhereInput
  }


  /**
   * subdomains without action
   */
  export type subdomainsArgs = {
    /**
     * Select specific fields to fetch from the subdomains
     * 
    **/
    select?: subdomainsSelect | null
  }



  /**
   * Model token_metadata_queue
   */


  export type AggregateToken_metadata_queue = {
    _count: Token_metadata_queueCountAggregateOutputType | null
    _avg: Token_metadata_queueAvgAggregateOutputType | null
    _sum: Token_metadata_queueSumAggregateOutputType | null
    _min: Token_metadata_queueMinAggregateOutputType | null
    _max: Token_metadata_queueMaxAggregateOutputType | null
  }

  export type Token_metadata_queueAvgAggregateOutputType = {
    queue_id: number | null
    block_height: number | null
    retry_count: number | null
  }

  export type Token_metadata_queueSumAggregateOutputType = {
    queue_id: number | null
    block_height: number | null
    retry_count: number | null
  }

  export type Token_metadata_queueMinAggregateOutputType = {
    queue_id: number | null
    tx_id: Buffer | null
    contract_id: string | null
    contract_abi: string | null
    block_height: number | null
    processed: boolean | null
    retry_count: number | null
  }

  export type Token_metadata_queueMaxAggregateOutputType = {
    queue_id: number | null
    tx_id: Buffer | null
    contract_id: string | null
    contract_abi: string | null
    block_height: number | null
    processed: boolean | null
    retry_count: number | null
  }

  export type Token_metadata_queueCountAggregateOutputType = {
    queue_id: number
    tx_id: number
    contract_id: number
    contract_abi: number
    block_height: number
    processed: number
    retry_count: number
    _all: number
  }


  export type Token_metadata_queueAvgAggregateInputType = {
    queue_id?: true
    block_height?: true
    retry_count?: true
  }

  export type Token_metadata_queueSumAggregateInputType = {
    queue_id?: true
    block_height?: true
    retry_count?: true
  }

  export type Token_metadata_queueMinAggregateInputType = {
    queue_id?: true
    tx_id?: true
    contract_id?: true
    contract_abi?: true
    block_height?: true
    processed?: true
    retry_count?: true
  }

  export type Token_metadata_queueMaxAggregateInputType = {
    queue_id?: true
    tx_id?: true
    contract_id?: true
    contract_abi?: true
    block_height?: true
    processed?: true
    retry_count?: true
  }

  export type Token_metadata_queueCountAggregateInputType = {
    queue_id?: true
    tx_id?: true
    contract_id?: true
    contract_abi?: true
    block_height?: true
    processed?: true
    retry_count?: true
    _all?: true
  }

  export type Token_metadata_queueAggregateArgs = {
    /**
     * Filter which token_metadata_queue to aggregate.
     * 
    **/
    where?: token_metadata_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_metadata_queues to fetch.
     * 
    **/
    orderBy?: Enumerable<token_metadata_queueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: token_metadata_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_metadata_queues from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_metadata_queues.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned token_metadata_queues
    **/
    _count?: true | Token_metadata_queueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Token_metadata_queueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Token_metadata_queueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Token_metadata_queueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Token_metadata_queueMaxAggregateInputType
  }

  export type GetToken_metadata_queueAggregateType<T extends Token_metadata_queueAggregateArgs> = {
        [P in keyof T & keyof AggregateToken_metadata_queue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken_metadata_queue[P]>
      : GetScalarType<T[P], AggregateToken_metadata_queue[P]>
  }




  export type Token_metadata_queueGroupByArgs = {
    where?: token_metadata_queueWhereInput
    orderBy?: Enumerable<token_metadata_queueOrderByWithAggregationInput>
    by: Array<Token_metadata_queueScalarFieldEnum>
    having?: token_metadata_queueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Token_metadata_queueCountAggregateInputType | true
    _avg?: Token_metadata_queueAvgAggregateInputType
    _sum?: Token_metadata_queueSumAggregateInputType
    _min?: Token_metadata_queueMinAggregateInputType
    _max?: Token_metadata_queueMaxAggregateInputType
  }


  export type Token_metadata_queueGroupByOutputType = {
    queue_id: number
    tx_id: Buffer
    contract_id: string
    contract_abi: string
    block_height: number
    processed: boolean
    retry_count: number
    _count: Token_metadata_queueCountAggregateOutputType | null
    _avg: Token_metadata_queueAvgAggregateOutputType | null
    _sum: Token_metadata_queueSumAggregateOutputType | null
    _min: Token_metadata_queueMinAggregateOutputType | null
    _max: Token_metadata_queueMaxAggregateOutputType | null
  }

  type GetToken_metadata_queueGroupByPayload<T extends Token_metadata_queueGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Token_metadata_queueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Token_metadata_queueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Token_metadata_queueGroupByOutputType[P]>
            : GetScalarType<T[P], Token_metadata_queueGroupByOutputType[P]>
        }
      >
    >


  export type token_metadata_queueSelect = {
    queue_id?: boolean
    tx_id?: boolean
    contract_id?: boolean
    contract_abi?: boolean
    block_height?: boolean
    processed?: boolean
    retry_count?: boolean
  }


  export type token_metadata_queueGetPayload<S extends boolean | null | undefined | token_metadata_queueArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? token_metadata_queue :
    S extends undefined ? never :
    S extends { include: any } & (token_metadata_queueArgs | token_metadata_queueFindManyArgs)
    ? token_metadata_queue 
    : S extends { select: any } & (token_metadata_queueArgs | token_metadata_queueFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof token_metadata_queue ? token_metadata_queue[P] : never
  } 
      : token_metadata_queue


  type token_metadata_queueCountArgs = Merge<
    Omit<token_metadata_queueFindManyArgs, 'select' | 'include'> & {
      select?: Token_metadata_queueCountAggregateInputType | true
    }
  >

  export interface token_metadata_queueDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Token_metadata_queue that matches the filter.
     * @param {token_metadata_queueFindUniqueArgs} args - Arguments to find a Token_metadata_queue
     * @example
     * // Get one Token_metadata_queue
     * const token_metadata_queue = await prisma.token_metadata_queue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends token_metadata_queueFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, token_metadata_queueFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'token_metadata_queue'> extends True ? Prisma__token_metadata_queueClient<token_metadata_queueGetPayload<T>> : Prisma__token_metadata_queueClient<token_metadata_queueGetPayload<T> | null, null>

    /**
     * Find one Token_metadata_queue that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {token_metadata_queueFindUniqueOrThrowArgs} args - Arguments to find a Token_metadata_queue
     * @example
     * // Get one Token_metadata_queue
     * const token_metadata_queue = await prisma.token_metadata_queue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends token_metadata_queueFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, token_metadata_queueFindUniqueOrThrowArgs>
    ): Prisma__token_metadata_queueClient<token_metadata_queueGetPayload<T>>

    /**
     * Find the first Token_metadata_queue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_metadata_queueFindFirstArgs} args - Arguments to find a Token_metadata_queue
     * @example
     * // Get one Token_metadata_queue
     * const token_metadata_queue = await prisma.token_metadata_queue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends token_metadata_queueFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, token_metadata_queueFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'token_metadata_queue'> extends True ? Prisma__token_metadata_queueClient<token_metadata_queueGetPayload<T>> : Prisma__token_metadata_queueClient<token_metadata_queueGetPayload<T> | null, null>

    /**
     * Find the first Token_metadata_queue that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_metadata_queueFindFirstOrThrowArgs} args - Arguments to find a Token_metadata_queue
     * @example
     * // Get one Token_metadata_queue
     * const token_metadata_queue = await prisma.token_metadata_queue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends token_metadata_queueFindFirstOrThrowArgs>(
      args?: SelectSubset<T, token_metadata_queueFindFirstOrThrowArgs>
    ): Prisma__token_metadata_queueClient<token_metadata_queueGetPayload<T>>

    /**
     * Find zero or more Token_metadata_queues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_metadata_queueFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Token_metadata_queues
     * const token_metadata_queues = await prisma.token_metadata_queue.findMany()
     * 
     * // Get first 10 Token_metadata_queues
     * const token_metadata_queues = await prisma.token_metadata_queue.findMany({ take: 10 })
     * 
     * // Only select the `queue_id`
     * const token_metadata_queueWithQueue_idOnly = await prisma.token_metadata_queue.findMany({ select: { queue_id: true } })
     * 
    **/
    findMany<T extends token_metadata_queueFindManyArgs>(
      args?: SelectSubset<T, token_metadata_queueFindManyArgs>
    ): PrismaPromise<Array<token_metadata_queueGetPayload<T>>>

    /**
     * Create a Token_metadata_queue.
     * @param {token_metadata_queueCreateArgs} args - Arguments to create a Token_metadata_queue.
     * @example
     * // Create one Token_metadata_queue
     * const Token_metadata_queue = await prisma.token_metadata_queue.create({
     *   data: {
     *     // ... data to create a Token_metadata_queue
     *   }
     * })
     * 
    **/
    create<T extends token_metadata_queueCreateArgs>(
      args: SelectSubset<T, token_metadata_queueCreateArgs>
    ): Prisma__token_metadata_queueClient<token_metadata_queueGetPayload<T>>

    /**
     * Create many Token_metadata_queues.
     *     @param {token_metadata_queueCreateManyArgs} args - Arguments to create many Token_metadata_queues.
     *     @example
     *     // Create many Token_metadata_queues
     *     const token_metadata_queue = await prisma.token_metadata_queue.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends token_metadata_queueCreateManyArgs>(
      args?: SelectSubset<T, token_metadata_queueCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Token_metadata_queue.
     * @param {token_metadata_queueDeleteArgs} args - Arguments to delete one Token_metadata_queue.
     * @example
     * // Delete one Token_metadata_queue
     * const Token_metadata_queue = await prisma.token_metadata_queue.delete({
     *   where: {
     *     // ... filter to delete one Token_metadata_queue
     *   }
     * })
     * 
    **/
    delete<T extends token_metadata_queueDeleteArgs>(
      args: SelectSubset<T, token_metadata_queueDeleteArgs>
    ): Prisma__token_metadata_queueClient<token_metadata_queueGetPayload<T>>

    /**
     * Update one Token_metadata_queue.
     * @param {token_metadata_queueUpdateArgs} args - Arguments to update one Token_metadata_queue.
     * @example
     * // Update one Token_metadata_queue
     * const token_metadata_queue = await prisma.token_metadata_queue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends token_metadata_queueUpdateArgs>(
      args: SelectSubset<T, token_metadata_queueUpdateArgs>
    ): Prisma__token_metadata_queueClient<token_metadata_queueGetPayload<T>>

    /**
     * Delete zero or more Token_metadata_queues.
     * @param {token_metadata_queueDeleteManyArgs} args - Arguments to filter Token_metadata_queues to delete.
     * @example
     * // Delete a few Token_metadata_queues
     * const { count } = await prisma.token_metadata_queue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends token_metadata_queueDeleteManyArgs>(
      args?: SelectSubset<T, token_metadata_queueDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Token_metadata_queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_metadata_queueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Token_metadata_queues
     * const token_metadata_queue = await prisma.token_metadata_queue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends token_metadata_queueUpdateManyArgs>(
      args: SelectSubset<T, token_metadata_queueUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Token_metadata_queue.
     * @param {token_metadata_queueUpsertArgs} args - Arguments to update or create a Token_metadata_queue.
     * @example
     * // Update or create a Token_metadata_queue
     * const token_metadata_queue = await prisma.token_metadata_queue.upsert({
     *   create: {
     *     // ... data to create a Token_metadata_queue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token_metadata_queue we want to update
     *   }
     * })
    **/
    upsert<T extends token_metadata_queueUpsertArgs>(
      args: SelectSubset<T, token_metadata_queueUpsertArgs>
    ): Prisma__token_metadata_queueClient<token_metadata_queueGetPayload<T>>

    /**
     * Count the number of Token_metadata_queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_metadata_queueCountArgs} args - Arguments to filter Token_metadata_queues to count.
     * @example
     * // Count the number of Token_metadata_queues
     * const count = await prisma.token_metadata_queue.count({
     *   where: {
     *     // ... the filter for the Token_metadata_queues we want to count
     *   }
     * })
    **/
    count<T extends token_metadata_queueCountArgs>(
      args?: Subset<T, token_metadata_queueCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Token_metadata_queueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token_metadata_queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_metadata_queueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Token_metadata_queueAggregateArgs>(args: Subset<T, Token_metadata_queueAggregateArgs>): PrismaPromise<GetToken_metadata_queueAggregateType<T>>

    /**
     * Group by Token_metadata_queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_metadata_queueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Token_metadata_queueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Token_metadata_queueGroupByArgs['orderBy'] }
        : { orderBy?: Token_metadata_queueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Token_metadata_queueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToken_metadata_queueGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for token_metadata_queue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__token_metadata_queueClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * token_metadata_queue base type for findUnique actions
   */
  export type token_metadata_queueFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the token_metadata_queue
     * 
    **/
    select?: token_metadata_queueSelect | null
    /**
     * Filter, which token_metadata_queue to fetch.
     * 
    **/
    where: token_metadata_queueWhereUniqueInput
  }

  /**
   * token_metadata_queue: findUnique
   */
  export interface token_metadata_queueFindUniqueArgs extends token_metadata_queueFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * token_metadata_queue findUniqueOrThrow
   */
  export type token_metadata_queueFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the token_metadata_queue
     * 
    **/
    select?: token_metadata_queueSelect | null
    /**
     * Filter, which token_metadata_queue to fetch.
     * 
    **/
    where: token_metadata_queueWhereUniqueInput
  }


  /**
   * token_metadata_queue base type for findFirst actions
   */
  export type token_metadata_queueFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the token_metadata_queue
     * 
    **/
    select?: token_metadata_queueSelect | null
    /**
     * Filter, which token_metadata_queue to fetch.
     * 
    **/
    where?: token_metadata_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_metadata_queues to fetch.
     * 
    **/
    orderBy?: Enumerable<token_metadata_queueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_metadata_queues.
     * 
    **/
    cursor?: token_metadata_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_metadata_queues from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_metadata_queues.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_metadata_queues.
     * 
    **/
    distinct?: Enumerable<Token_metadata_queueScalarFieldEnum>
  }

  /**
   * token_metadata_queue: findFirst
   */
  export interface token_metadata_queueFindFirstArgs extends token_metadata_queueFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * token_metadata_queue findFirstOrThrow
   */
  export type token_metadata_queueFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the token_metadata_queue
     * 
    **/
    select?: token_metadata_queueSelect | null
    /**
     * Filter, which token_metadata_queue to fetch.
     * 
    **/
    where?: token_metadata_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_metadata_queues to fetch.
     * 
    **/
    orderBy?: Enumerable<token_metadata_queueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_metadata_queues.
     * 
    **/
    cursor?: token_metadata_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_metadata_queues from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_metadata_queues.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_metadata_queues.
     * 
    **/
    distinct?: Enumerable<Token_metadata_queueScalarFieldEnum>
  }


  /**
   * token_metadata_queue findMany
   */
  export type token_metadata_queueFindManyArgs = {
    /**
     * Select specific fields to fetch from the token_metadata_queue
     * 
    **/
    select?: token_metadata_queueSelect | null
    /**
     * Filter, which token_metadata_queues to fetch.
     * 
    **/
    where?: token_metadata_queueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_metadata_queues to fetch.
     * 
    **/
    orderBy?: Enumerable<token_metadata_queueOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing token_metadata_queues.
     * 
    **/
    cursor?: token_metadata_queueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_metadata_queues from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_metadata_queues.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Token_metadata_queueScalarFieldEnum>
  }


  /**
   * token_metadata_queue create
   */
  export type token_metadata_queueCreateArgs = {
    /**
     * Select specific fields to fetch from the token_metadata_queue
     * 
    **/
    select?: token_metadata_queueSelect | null
    /**
     * The data needed to create a token_metadata_queue.
     * 
    **/
    data: XOR<token_metadata_queueCreateInput, token_metadata_queueUncheckedCreateInput>
  }


  /**
   * token_metadata_queue createMany
   */
  export type token_metadata_queueCreateManyArgs = {
    /**
     * The data used to create many token_metadata_queues.
     * 
    **/
    data: Enumerable<token_metadata_queueCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * token_metadata_queue update
   */
  export type token_metadata_queueUpdateArgs = {
    /**
     * Select specific fields to fetch from the token_metadata_queue
     * 
    **/
    select?: token_metadata_queueSelect | null
    /**
     * The data needed to update a token_metadata_queue.
     * 
    **/
    data: XOR<token_metadata_queueUpdateInput, token_metadata_queueUncheckedUpdateInput>
    /**
     * Choose, which token_metadata_queue to update.
     * 
    **/
    where: token_metadata_queueWhereUniqueInput
  }


  /**
   * token_metadata_queue updateMany
   */
  export type token_metadata_queueUpdateManyArgs = {
    /**
     * The data used to update token_metadata_queues.
     * 
    **/
    data: XOR<token_metadata_queueUpdateManyMutationInput, token_metadata_queueUncheckedUpdateManyInput>
    /**
     * Filter which token_metadata_queues to update
     * 
    **/
    where?: token_metadata_queueWhereInput
  }


  /**
   * token_metadata_queue upsert
   */
  export type token_metadata_queueUpsertArgs = {
    /**
     * Select specific fields to fetch from the token_metadata_queue
     * 
    **/
    select?: token_metadata_queueSelect | null
    /**
     * The filter to search for the token_metadata_queue to update in case it exists.
     * 
    **/
    where: token_metadata_queueWhereUniqueInput
    /**
     * In case the token_metadata_queue found by the `where` argument doesn't exist, create a new token_metadata_queue with this data.
     * 
    **/
    create: XOR<token_metadata_queueCreateInput, token_metadata_queueUncheckedCreateInput>
    /**
     * In case the token_metadata_queue was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<token_metadata_queueUpdateInput, token_metadata_queueUncheckedUpdateInput>
  }


  /**
   * token_metadata_queue delete
   */
  export type token_metadata_queueDeleteArgs = {
    /**
     * Select specific fields to fetch from the token_metadata_queue
     * 
    **/
    select?: token_metadata_queueSelect | null
    /**
     * Filter which token_metadata_queue to delete.
     * 
    **/
    where: token_metadata_queueWhereUniqueInput
  }


  /**
   * token_metadata_queue deleteMany
   */
  export type token_metadata_queueDeleteManyArgs = {
    /**
     * Filter which token_metadata_queues to delete
     * 
    **/
    where?: token_metadata_queueWhereInput
  }


  /**
   * token_metadata_queue without action
   */
  export type token_metadata_queueArgs = {
    /**
     * Select specific fields to fetch from the token_metadata_queue
     * 
    **/
    select?: token_metadata_queueSelect | null
  }



  /**
   * Model token_offering_locked
   */


  export type AggregateToken_offering_locked = {
    _count: Token_offering_lockedCountAggregateOutputType | null
    _avg: Token_offering_lockedAvgAggregateOutputType | null
    _sum: Token_offering_lockedSumAggregateOutputType | null
    _min: Token_offering_lockedMinAggregateOutputType | null
    _max: Token_offering_lockedMaxAggregateOutputType | null
  }

  export type Token_offering_lockedAvgAggregateOutputType = {
    id: number | null
    value: number | null
    block: number | null
  }

  export type Token_offering_lockedSumAggregateOutputType = {
    id: number | null
    value: bigint | null
    block: number | null
  }

  export type Token_offering_lockedMinAggregateOutputType = {
    id: number | null
    address: string | null
    value: bigint | null
    block: number | null
  }

  export type Token_offering_lockedMaxAggregateOutputType = {
    id: number | null
    address: string | null
    value: bigint | null
    block: number | null
  }

  export type Token_offering_lockedCountAggregateOutputType = {
    id: number
    address: number
    value: number
    block: number
    _all: number
  }


  export type Token_offering_lockedAvgAggregateInputType = {
    id?: true
    value?: true
    block?: true
  }

  export type Token_offering_lockedSumAggregateInputType = {
    id?: true
    value?: true
    block?: true
  }

  export type Token_offering_lockedMinAggregateInputType = {
    id?: true
    address?: true
    value?: true
    block?: true
  }

  export type Token_offering_lockedMaxAggregateInputType = {
    id?: true
    address?: true
    value?: true
    block?: true
  }

  export type Token_offering_lockedCountAggregateInputType = {
    id?: true
    address?: true
    value?: true
    block?: true
    _all?: true
  }

  export type Token_offering_lockedAggregateArgs = {
    /**
     * Filter which token_offering_locked to aggregate.
     * 
    **/
    where?: token_offering_lockedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_offering_lockeds to fetch.
     * 
    **/
    orderBy?: Enumerable<token_offering_lockedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: token_offering_lockedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_offering_lockeds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_offering_lockeds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned token_offering_lockeds
    **/
    _count?: true | Token_offering_lockedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Token_offering_lockedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Token_offering_lockedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Token_offering_lockedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Token_offering_lockedMaxAggregateInputType
  }

  export type GetToken_offering_lockedAggregateType<T extends Token_offering_lockedAggregateArgs> = {
        [P in keyof T & keyof AggregateToken_offering_locked]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken_offering_locked[P]>
      : GetScalarType<T[P], AggregateToken_offering_locked[P]>
  }




  export type Token_offering_lockedGroupByArgs = {
    where?: token_offering_lockedWhereInput
    orderBy?: Enumerable<token_offering_lockedOrderByWithAggregationInput>
    by: Array<Token_offering_lockedScalarFieldEnum>
    having?: token_offering_lockedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Token_offering_lockedCountAggregateInputType | true
    _avg?: Token_offering_lockedAvgAggregateInputType
    _sum?: Token_offering_lockedSumAggregateInputType
    _min?: Token_offering_lockedMinAggregateInputType
    _max?: Token_offering_lockedMaxAggregateInputType
  }


  export type Token_offering_lockedGroupByOutputType = {
    id: number
    address: string
    value: bigint
    block: number
    _count: Token_offering_lockedCountAggregateOutputType | null
    _avg: Token_offering_lockedAvgAggregateOutputType | null
    _sum: Token_offering_lockedSumAggregateOutputType | null
    _min: Token_offering_lockedMinAggregateOutputType | null
    _max: Token_offering_lockedMaxAggregateOutputType | null
  }

  type GetToken_offering_lockedGroupByPayload<T extends Token_offering_lockedGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Token_offering_lockedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Token_offering_lockedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Token_offering_lockedGroupByOutputType[P]>
            : GetScalarType<T[P], Token_offering_lockedGroupByOutputType[P]>
        }
      >
    >


  export type token_offering_lockedSelect = {
    id?: boolean
    address?: boolean
    value?: boolean
    block?: boolean
  }


  export type token_offering_lockedGetPayload<S extends boolean | null | undefined | token_offering_lockedArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? token_offering_locked :
    S extends undefined ? never :
    S extends { include: any } & (token_offering_lockedArgs | token_offering_lockedFindManyArgs)
    ? token_offering_locked 
    : S extends { select: any } & (token_offering_lockedArgs | token_offering_lockedFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof token_offering_locked ? token_offering_locked[P] : never
  } 
      : token_offering_locked


  type token_offering_lockedCountArgs = Merge<
    Omit<token_offering_lockedFindManyArgs, 'select' | 'include'> & {
      select?: Token_offering_lockedCountAggregateInputType | true
    }
  >

  export interface token_offering_lockedDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Token_offering_locked that matches the filter.
     * @param {token_offering_lockedFindUniqueArgs} args - Arguments to find a Token_offering_locked
     * @example
     * // Get one Token_offering_locked
     * const token_offering_locked = await prisma.token_offering_locked.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends token_offering_lockedFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, token_offering_lockedFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'token_offering_locked'> extends True ? Prisma__token_offering_lockedClient<token_offering_lockedGetPayload<T>> : Prisma__token_offering_lockedClient<token_offering_lockedGetPayload<T> | null, null>

    /**
     * Find one Token_offering_locked that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {token_offering_lockedFindUniqueOrThrowArgs} args - Arguments to find a Token_offering_locked
     * @example
     * // Get one Token_offering_locked
     * const token_offering_locked = await prisma.token_offering_locked.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends token_offering_lockedFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, token_offering_lockedFindUniqueOrThrowArgs>
    ): Prisma__token_offering_lockedClient<token_offering_lockedGetPayload<T>>

    /**
     * Find the first Token_offering_locked that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_offering_lockedFindFirstArgs} args - Arguments to find a Token_offering_locked
     * @example
     * // Get one Token_offering_locked
     * const token_offering_locked = await prisma.token_offering_locked.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends token_offering_lockedFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, token_offering_lockedFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'token_offering_locked'> extends True ? Prisma__token_offering_lockedClient<token_offering_lockedGetPayload<T>> : Prisma__token_offering_lockedClient<token_offering_lockedGetPayload<T> | null, null>

    /**
     * Find the first Token_offering_locked that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_offering_lockedFindFirstOrThrowArgs} args - Arguments to find a Token_offering_locked
     * @example
     * // Get one Token_offering_locked
     * const token_offering_locked = await prisma.token_offering_locked.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends token_offering_lockedFindFirstOrThrowArgs>(
      args?: SelectSubset<T, token_offering_lockedFindFirstOrThrowArgs>
    ): Prisma__token_offering_lockedClient<token_offering_lockedGetPayload<T>>

    /**
     * Find zero or more Token_offering_lockeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_offering_lockedFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Token_offering_lockeds
     * const token_offering_lockeds = await prisma.token_offering_locked.findMany()
     * 
     * // Get first 10 Token_offering_lockeds
     * const token_offering_lockeds = await prisma.token_offering_locked.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const token_offering_lockedWithIdOnly = await prisma.token_offering_locked.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends token_offering_lockedFindManyArgs>(
      args?: SelectSubset<T, token_offering_lockedFindManyArgs>
    ): PrismaPromise<Array<token_offering_lockedGetPayload<T>>>

    /**
     * Create a Token_offering_locked.
     * @param {token_offering_lockedCreateArgs} args - Arguments to create a Token_offering_locked.
     * @example
     * // Create one Token_offering_locked
     * const Token_offering_locked = await prisma.token_offering_locked.create({
     *   data: {
     *     // ... data to create a Token_offering_locked
     *   }
     * })
     * 
    **/
    create<T extends token_offering_lockedCreateArgs>(
      args: SelectSubset<T, token_offering_lockedCreateArgs>
    ): Prisma__token_offering_lockedClient<token_offering_lockedGetPayload<T>>

    /**
     * Create many Token_offering_lockeds.
     *     @param {token_offering_lockedCreateManyArgs} args - Arguments to create many Token_offering_lockeds.
     *     @example
     *     // Create many Token_offering_lockeds
     *     const token_offering_locked = await prisma.token_offering_locked.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends token_offering_lockedCreateManyArgs>(
      args?: SelectSubset<T, token_offering_lockedCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Token_offering_locked.
     * @param {token_offering_lockedDeleteArgs} args - Arguments to delete one Token_offering_locked.
     * @example
     * // Delete one Token_offering_locked
     * const Token_offering_locked = await prisma.token_offering_locked.delete({
     *   where: {
     *     // ... filter to delete one Token_offering_locked
     *   }
     * })
     * 
    **/
    delete<T extends token_offering_lockedDeleteArgs>(
      args: SelectSubset<T, token_offering_lockedDeleteArgs>
    ): Prisma__token_offering_lockedClient<token_offering_lockedGetPayload<T>>

    /**
     * Update one Token_offering_locked.
     * @param {token_offering_lockedUpdateArgs} args - Arguments to update one Token_offering_locked.
     * @example
     * // Update one Token_offering_locked
     * const token_offering_locked = await prisma.token_offering_locked.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends token_offering_lockedUpdateArgs>(
      args: SelectSubset<T, token_offering_lockedUpdateArgs>
    ): Prisma__token_offering_lockedClient<token_offering_lockedGetPayload<T>>

    /**
     * Delete zero or more Token_offering_lockeds.
     * @param {token_offering_lockedDeleteManyArgs} args - Arguments to filter Token_offering_lockeds to delete.
     * @example
     * // Delete a few Token_offering_lockeds
     * const { count } = await prisma.token_offering_locked.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends token_offering_lockedDeleteManyArgs>(
      args?: SelectSubset<T, token_offering_lockedDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Token_offering_lockeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_offering_lockedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Token_offering_lockeds
     * const token_offering_locked = await prisma.token_offering_locked.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends token_offering_lockedUpdateManyArgs>(
      args: SelectSubset<T, token_offering_lockedUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Token_offering_locked.
     * @param {token_offering_lockedUpsertArgs} args - Arguments to update or create a Token_offering_locked.
     * @example
     * // Update or create a Token_offering_locked
     * const token_offering_locked = await prisma.token_offering_locked.upsert({
     *   create: {
     *     // ... data to create a Token_offering_locked
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token_offering_locked we want to update
     *   }
     * })
    **/
    upsert<T extends token_offering_lockedUpsertArgs>(
      args: SelectSubset<T, token_offering_lockedUpsertArgs>
    ): Prisma__token_offering_lockedClient<token_offering_lockedGetPayload<T>>

    /**
     * Count the number of Token_offering_lockeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {token_offering_lockedCountArgs} args - Arguments to filter Token_offering_lockeds to count.
     * @example
     * // Count the number of Token_offering_lockeds
     * const count = await prisma.token_offering_locked.count({
     *   where: {
     *     // ... the filter for the Token_offering_lockeds we want to count
     *   }
     * })
    **/
    count<T extends token_offering_lockedCountArgs>(
      args?: Subset<T, token_offering_lockedCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Token_offering_lockedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token_offering_locked.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_offering_lockedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Token_offering_lockedAggregateArgs>(args: Subset<T, Token_offering_lockedAggregateArgs>): PrismaPromise<GetToken_offering_lockedAggregateType<T>>

    /**
     * Group by Token_offering_locked.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Token_offering_lockedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Token_offering_lockedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Token_offering_lockedGroupByArgs['orderBy'] }
        : { orderBy?: Token_offering_lockedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Token_offering_lockedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetToken_offering_lockedGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for token_offering_locked.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__token_offering_lockedClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * token_offering_locked base type for findUnique actions
   */
  export type token_offering_lockedFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the token_offering_locked
     * 
    **/
    select?: token_offering_lockedSelect | null
    /**
     * Filter, which token_offering_locked to fetch.
     * 
    **/
    where: token_offering_lockedWhereUniqueInput
  }

  /**
   * token_offering_locked: findUnique
   */
  export interface token_offering_lockedFindUniqueArgs extends token_offering_lockedFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * token_offering_locked findUniqueOrThrow
   */
  export type token_offering_lockedFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the token_offering_locked
     * 
    **/
    select?: token_offering_lockedSelect | null
    /**
     * Filter, which token_offering_locked to fetch.
     * 
    **/
    where: token_offering_lockedWhereUniqueInput
  }


  /**
   * token_offering_locked base type for findFirst actions
   */
  export type token_offering_lockedFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the token_offering_locked
     * 
    **/
    select?: token_offering_lockedSelect | null
    /**
     * Filter, which token_offering_locked to fetch.
     * 
    **/
    where?: token_offering_lockedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_offering_lockeds to fetch.
     * 
    **/
    orderBy?: Enumerable<token_offering_lockedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_offering_lockeds.
     * 
    **/
    cursor?: token_offering_lockedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_offering_lockeds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_offering_lockeds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_offering_lockeds.
     * 
    **/
    distinct?: Enumerable<Token_offering_lockedScalarFieldEnum>
  }

  /**
   * token_offering_locked: findFirst
   */
  export interface token_offering_lockedFindFirstArgs extends token_offering_lockedFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * token_offering_locked findFirstOrThrow
   */
  export type token_offering_lockedFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the token_offering_locked
     * 
    **/
    select?: token_offering_lockedSelect | null
    /**
     * Filter, which token_offering_locked to fetch.
     * 
    **/
    where?: token_offering_lockedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_offering_lockeds to fetch.
     * 
    **/
    orderBy?: Enumerable<token_offering_lockedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for token_offering_lockeds.
     * 
    **/
    cursor?: token_offering_lockedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_offering_lockeds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_offering_lockeds.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of token_offering_lockeds.
     * 
    **/
    distinct?: Enumerable<Token_offering_lockedScalarFieldEnum>
  }


  /**
   * token_offering_locked findMany
   */
  export type token_offering_lockedFindManyArgs = {
    /**
     * Select specific fields to fetch from the token_offering_locked
     * 
    **/
    select?: token_offering_lockedSelect | null
    /**
     * Filter, which token_offering_lockeds to fetch.
     * 
    **/
    where?: token_offering_lockedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of token_offering_lockeds to fetch.
     * 
    **/
    orderBy?: Enumerable<token_offering_lockedOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing token_offering_lockeds.
     * 
    **/
    cursor?: token_offering_lockedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` token_offering_lockeds from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` token_offering_lockeds.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Token_offering_lockedScalarFieldEnum>
  }


  /**
   * token_offering_locked create
   */
  export type token_offering_lockedCreateArgs = {
    /**
     * Select specific fields to fetch from the token_offering_locked
     * 
    **/
    select?: token_offering_lockedSelect | null
    /**
     * The data needed to create a token_offering_locked.
     * 
    **/
    data: XOR<token_offering_lockedCreateInput, token_offering_lockedUncheckedCreateInput>
  }


  /**
   * token_offering_locked createMany
   */
  export type token_offering_lockedCreateManyArgs = {
    /**
     * The data used to create many token_offering_lockeds.
     * 
    **/
    data: Enumerable<token_offering_lockedCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * token_offering_locked update
   */
  export type token_offering_lockedUpdateArgs = {
    /**
     * Select specific fields to fetch from the token_offering_locked
     * 
    **/
    select?: token_offering_lockedSelect | null
    /**
     * The data needed to update a token_offering_locked.
     * 
    **/
    data: XOR<token_offering_lockedUpdateInput, token_offering_lockedUncheckedUpdateInput>
    /**
     * Choose, which token_offering_locked to update.
     * 
    **/
    where: token_offering_lockedWhereUniqueInput
  }


  /**
   * token_offering_locked updateMany
   */
  export type token_offering_lockedUpdateManyArgs = {
    /**
     * The data used to update token_offering_lockeds.
     * 
    **/
    data: XOR<token_offering_lockedUpdateManyMutationInput, token_offering_lockedUncheckedUpdateManyInput>
    /**
     * Filter which token_offering_lockeds to update
     * 
    **/
    where?: token_offering_lockedWhereInput
  }


  /**
   * token_offering_locked upsert
   */
  export type token_offering_lockedUpsertArgs = {
    /**
     * Select specific fields to fetch from the token_offering_locked
     * 
    **/
    select?: token_offering_lockedSelect | null
    /**
     * The filter to search for the token_offering_locked to update in case it exists.
     * 
    **/
    where: token_offering_lockedWhereUniqueInput
    /**
     * In case the token_offering_locked found by the `where` argument doesn't exist, create a new token_offering_locked with this data.
     * 
    **/
    create: XOR<token_offering_lockedCreateInput, token_offering_lockedUncheckedCreateInput>
    /**
     * In case the token_offering_locked was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<token_offering_lockedUpdateInput, token_offering_lockedUncheckedUpdateInput>
  }


  /**
   * token_offering_locked delete
   */
  export type token_offering_lockedDeleteArgs = {
    /**
     * Select specific fields to fetch from the token_offering_locked
     * 
    **/
    select?: token_offering_lockedSelect | null
    /**
     * Filter which token_offering_locked to delete.
     * 
    **/
    where: token_offering_lockedWhereUniqueInput
  }


  /**
   * token_offering_locked deleteMany
   */
  export type token_offering_lockedDeleteManyArgs = {
    /**
     * Filter which token_offering_lockeds to delete
     * 
    **/
    where?: token_offering_lockedWhereInput
  }


  /**
   * token_offering_locked without action
   */
  export type token_offering_lockedArgs = {
    /**
     * Select specific fields to fetch from the token_offering_locked
     * 
    **/
    select?: token_offering_lockedSelect | null
  }



  /**
   * Model txs
   */


  export type AggregateTxs = {
    _count: TxsCountAggregateOutputType | null
    _avg: TxsAvgAggregateOutputType | null
    _sum: TxsSumAggregateOutputType | null
    _min: TxsMinAggregateOutputType | null
    _max: TxsMaxAggregateOutputType | null
  }

  export type TxsAvgAggregateOutputType = {
    id: number | null
    tx_index: number | null
    block_height: number | null
    burn_block_time: number | null
    parent_burn_block_time: number | null
    type_id: number | null
    anchor_mode: number | null
    status: number | null
    nonce: number | null
    fee_rate: number | null
    sponsor_nonce: number | null
    origin_hash_mode: number | null
    event_count: number | null
    execution_cost_read_count: number | null
    execution_cost_read_length: number | null
    execution_cost_runtime: number | null
    execution_cost_write_count: number | null
    execution_cost_write_length: number | null
    microblock_sequence: number | null
    token_transfer_amount: number | null
    smart_contract_clarity_version: number | null
  }

  export type TxsSumAggregateOutputType = {
    id: number | null
    tx_index: number | null
    block_height: number | null
    burn_block_time: number | null
    parent_burn_block_time: number | null
    type_id: number | null
    anchor_mode: number | null
    status: number | null
    nonce: number | null
    fee_rate: bigint | null
    sponsor_nonce: number | null
    origin_hash_mode: number | null
    event_count: number | null
    execution_cost_read_count: bigint | null
    execution_cost_read_length: bigint | null
    execution_cost_runtime: bigint | null
    execution_cost_write_count: bigint | null
    execution_cost_write_length: bigint | null
    microblock_sequence: number | null
    token_transfer_amount: bigint | null
    smart_contract_clarity_version: number | null
  }

  export type TxsMinAggregateOutputType = {
    id: number | null
    tx_id: Buffer | null
    tx_index: number | null
    raw_result: Buffer | null
    index_block_hash: Buffer | null
    block_hash: Buffer | null
    block_height: number | null
    parent_block_hash: Buffer | null
    burn_block_time: number | null
    parent_burn_block_time: number | null
    type_id: number | null
    anchor_mode: number | null
    status: number | null
    canonical: boolean | null
    post_conditions: Buffer | null
    nonce: number | null
    fee_rate: bigint | null
    sponsored: boolean | null
    sponsor_address: string | null
    sponsor_nonce: number | null
    sender_address: string | null
    origin_hash_mode: number | null
    event_count: number | null
    execution_cost_read_count: bigint | null
    execution_cost_read_length: bigint | null
    execution_cost_runtime: bigint | null
    execution_cost_write_count: bigint | null
    execution_cost_write_length: bigint | null
    raw_tx: Buffer | null
    microblock_canonical: boolean | null
    microblock_sequence: number | null
    microblock_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    token_transfer_recipient_address: string | null
    token_transfer_amount: bigint | null
    token_transfer_memo: Buffer | null
    smart_contract_clarity_version: number | null
    smart_contract_contract_id: string | null
    smart_contract_source_code: string | null
    contract_call_contract_id: string | null
    contract_call_function_name: string | null
    contract_call_function_args: Buffer | null
    poison_microblock_header_1: Buffer | null
    poison_microblock_header_2: Buffer | null
    coinbase_payload: Buffer | null
    coinbase_alt_recipient: string | null
  }

  export type TxsMaxAggregateOutputType = {
    id: number | null
    tx_id: Buffer | null
    tx_index: number | null
    raw_result: Buffer | null
    index_block_hash: Buffer | null
    block_hash: Buffer | null
    block_height: number | null
    parent_block_hash: Buffer | null
    burn_block_time: number | null
    parent_burn_block_time: number | null
    type_id: number | null
    anchor_mode: number | null
    status: number | null
    canonical: boolean | null
    post_conditions: Buffer | null
    nonce: number | null
    fee_rate: bigint | null
    sponsored: boolean | null
    sponsor_address: string | null
    sponsor_nonce: number | null
    sender_address: string | null
    origin_hash_mode: number | null
    event_count: number | null
    execution_cost_read_count: bigint | null
    execution_cost_read_length: bigint | null
    execution_cost_runtime: bigint | null
    execution_cost_write_count: bigint | null
    execution_cost_write_length: bigint | null
    raw_tx: Buffer | null
    microblock_canonical: boolean | null
    microblock_sequence: number | null
    microblock_hash: Buffer | null
    parent_index_block_hash: Buffer | null
    token_transfer_recipient_address: string | null
    token_transfer_amount: bigint | null
    token_transfer_memo: Buffer | null
    smart_contract_clarity_version: number | null
    smart_contract_contract_id: string | null
    smart_contract_source_code: string | null
    contract_call_contract_id: string | null
    contract_call_function_name: string | null
    contract_call_function_args: Buffer | null
    poison_microblock_header_1: Buffer | null
    poison_microblock_header_2: Buffer | null
    coinbase_payload: Buffer | null
    coinbase_alt_recipient: string | null
  }

  export type TxsCountAggregateOutputType = {
    id: number
    tx_id: number
    tx_index: number
    raw_result: number
    index_block_hash: number
    block_hash: number
    block_height: number
    parent_block_hash: number
    burn_block_time: number
    parent_burn_block_time: number
    type_id: number
    anchor_mode: number
    status: number
    canonical: number
    post_conditions: number
    nonce: number
    fee_rate: number
    sponsored: number
    sponsor_address: number
    sponsor_nonce: number
    sender_address: number
    origin_hash_mode: number
    event_count: number
    execution_cost_read_count: number
    execution_cost_read_length: number
    execution_cost_runtime: number
    execution_cost_write_count: number
    execution_cost_write_length: number
    raw_tx: number
    microblock_canonical: number
    microblock_sequence: number
    microblock_hash: number
    parent_index_block_hash: number
    token_transfer_recipient_address: number
    token_transfer_amount: number
    token_transfer_memo: number
    smart_contract_clarity_version: number
    smart_contract_contract_id: number
    smart_contract_source_code: number
    contract_call_contract_id: number
    contract_call_function_name: number
    contract_call_function_args: number
    poison_microblock_header_1: number
    poison_microblock_header_2: number
    coinbase_payload: number
    coinbase_alt_recipient: number
    _all: number
  }


  export type TxsAvgAggregateInputType = {
    id?: true
    tx_index?: true
    block_height?: true
    burn_block_time?: true
    parent_burn_block_time?: true
    type_id?: true
    anchor_mode?: true
    status?: true
    nonce?: true
    fee_rate?: true
    sponsor_nonce?: true
    origin_hash_mode?: true
    event_count?: true
    execution_cost_read_count?: true
    execution_cost_read_length?: true
    execution_cost_runtime?: true
    execution_cost_write_count?: true
    execution_cost_write_length?: true
    microblock_sequence?: true
    token_transfer_amount?: true
    smart_contract_clarity_version?: true
  }

  export type TxsSumAggregateInputType = {
    id?: true
    tx_index?: true
    block_height?: true
    burn_block_time?: true
    parent_burn_block_time?: true
    type_id?: true
    anchor_mode?: true
    status?: true
    nonce?: true
    fee_rate?: true
    sponsor_nonce?: true
    origin_hash_mode?: true
    event_count?: true
    execution_cost_read_count?: true
    execution_cost_read_length?: true
    execution_cost_runtime?: true
    execution_cost_write_count?: true
    execution_cost_write_length?: true
    microblock_sequence?: true
    token_transfer_amount?: true
    smart_contract_clarity_version?: true
  }

  export type TxsMinAggregateInputType = {
    id?: true
    tx_id?: true
    tx_index?: true
    raw_result?: true
    index_block_hash?: true
    block_hash?: true
    block_height?: true
    parent_block_hash?: true
    burn_block_time?: true
    parent_burn_block_time?: true
    type_id?: true
    anchor_mode?: true
    status?: true
    canonical?: true
    post_conditions?: true
    nonce?: true
    fee_rate?: true
    sponsored?: true
    sponsor_address?: true
    sponsor_nonce?: true
    sender_address?: true
    origin_hash_mode?: true
    event_count?: true
    execution_cost_read_count?: true
    execution_cost_read_length?: true
    execution_cost_runtime?: true
    execution_cost_write_count?: true
    execution_cost_write_length?: true
    raw_tx?: true
    microblock_canonical?: true
    microblock_sequence?: true
    microblock_hash?: true
    parent_index_block_hash?: true
    token_transfer_recipient_address?: true
    token_transfer_amount?: true
    token_transfer_memo?: true
    smart_contract_clarity_version?: true
    smart_contract_contract_id?: true
    smart_contract_source_code?: true
    contract_call_contract_id?: true
    contract_call_function_name?: true
    contract_call_function_args?: true
    poison_microblock_header_1?: true
    poison_microblock_header_2?: true
    coinbase_payload?: true
    coinbase_alt_recipient?: true
  }

  export type TxsMaxAggregateInputType = {
    id?: true
    tx_id?: true
    tx_index?: true
    raw_result?: true
    index_block_hash?: true
    block_hash?: true
    block_height?: true
    parent_block_hash?: true
    burn_block_time?: true
    parent_burn_block_time?: true
    type_id?: true
    anchor_mode?: true
    status?: true
    canonical?: true
    post_conditions?: true
    nonce?: true
    fee_rate?: true
    sponsored?: true
    sponsor_address?: true
    sponsor_nonce?: true
    sender_address?: true
    origin_hash_mode?: true
    event_count?: true
    execution_cost_read_count?: true
    execution_cost_read_length?: true
    execution_cost_runtime?: true
    execution_cost_write_count?: true
    execution_cost_write_length?: true
    raw_tx?: true
    microblock_canonical?: true
    microblock_sequence?: true
    microblock_hash?: true
    parent_index_block_hash?: true
    token_transfer_recipient_address?: true
    token_transfer_amount?: true
    token_transfer_memo?: true
    smart_contract_clarity_version?: true
    smart_contract_contract_id?: true
    smart_contract_source_code?: true
    contract_call_contract_id?: true
    contract_call_function_name?: true
    contract_call_function_args?: true
    poison_microblock_header_1?: true
    poison_microblock_header_2?: true
    coinbase_payload?: true
    coinbase_alt_recipient?: true
  }

  export type TxsCountAggregateInputType = {
    id?: true
    tx_id?: true
    tx_index?: true
    raw_result?: true
    index_block_hash?: true
    block_hash?: true
    block_height?: true
    parent_block_hash?: true
    burn_block_time?: true
    parent_burn_block_time?: true
    type_id?: true
    anchor_mode?: true
    status?: true
    canonical?: true
    post_conditions?: true
    nonce?: true
    fee_rate?: true
    sponsored?: true
    sponsor_address?: true
    sponsor_nonce?: true
    sender_address?: true
    origin_hash_mode?: true
    event_count?: true
    execution_cost_read_count?: true
    execution_cost_read_length?: true
    execution_cost_runtime?: true
    execution_cost_write_count?: true
    execution_cost_write_length?: true
    raw_tx?: true
    microblock_canonical?: true
    microblock_sequence?: true
    microblock_hash?: true
    parent_index_block_hash?: true
    token_transfer_recipient_address?: true
    token_transfer_amount?: true
    token_transfer_memo?: true
    smart_contract_clarity_version?: true
    smart_contract_contract_id?: true
    smart_contract_source_code?: true
    contract_call_contract_id?: true
    contract_call_function_name?: true
    contract_call_function_args?: true
    poison_microblock_header_1?: true
    poison_microblock_header_2?: true
    coinbase_payload?: true
    coinbase_alt_recipient?: true
    _all?: true
  }

  export type TxsAggregateArgs = {
    /**
     * Filter which txs to aggregate.
     * 
    **/
    where?: txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of txs to fetch.
     * 
    **/
    orderBy?: Enumerable<txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` txs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned txs
    **/
    _count?: true | TxsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TxsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TxsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TxsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TxsMaxAggregateInputType
  }

  export type GetTxsAggregateType<T extends TxsAggregateArgs> = {
        [P in keyof T & keyof AggregateTxs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTxs[P]>
      : GetScalarType<T[P], AggregateTxs[P]>
  }




  export type TxsGroupByArgs = {
    where?: txsWhereInput
    orderBy?: Enumerable<txsOrderByWithAggregationInput>
    by: Array<TxsScalarFieldEnum>
    having?: txsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TxsCountAggregateInputType | true
    _avg?: TxsAvgAggregateInputType
    _sum?: TxsSumAggregateInputType
    _min?: TxsMinAggregateInputType
    _max?: TxsMaxAggregateInputType
  }


  export type TxsGroupByOutputType = {
    id: number
    tx_id: Buffer
    tx_index: number
    raw_result: Buffer
    index_block_hash: Buffer
    block_hash: Buffer
    block_height: number
    parent_block_hash: Buffer
    burn_block_time: number
    parent_burn_block_time: number
    type_id: number
    anchor_mode: number
    status: number
    canonical: boolean
    post_conditions: Buffer
    nonce: number
    fee_rate: bigint
    sponsored: boolean
    sponsor_address: string | null
    sponsor_nonce: number | null
    sender_address: string
    origin_hash_mode: number
    event_count: number
    execution_cost_read_count: bigint
    execution_cost_read_length: bigint
    execution_cost_runtime: bigint
    execution_cost_write_count: bigint
    execution_cost_write_length: bigint
    raw_tx: Buffer
    microblock_canonical: boolean
    microblock_sequence: number
    microblock_hash: Buffer
    parent_index_block_hash: Buffer
    token_transfer_recipient_address: string | null
    token_transfer_amount: bigint | null
    token_transfer_memo: Buffer | null
    smart_contract_clarity_version: number | null
    smart_contract_contract_id: string | null
    smart_contract_source_code: string | null
    contract_call_contract_id: string | null
    contract_call_function_name: string | null
    contract_call_function_args: Buffer | null
    poison_microblock_header_1: Buffer | null
    poison_microblock_header_2: Buffer | null
    coinbase_payload: Buffer | null
    coinbase_alt_recipient: string | null
    _count: TxsCountAggregateOutputType | null
    _avg: TxsAvgAggregateOutputType | null
    _sum: TxsSumAggregateOutputType | null
    _min: TxsMinAggregateOutputType | null
    _max: TxsMaxAggregateOutputType | null
  }

  type GetTxsGroupByPayload<T extends TxsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TxsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TxsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TxsGroupByOutputType[P]>
            : GetScalarType<T[P], TxsGroupByOutputType[P]>
        }
      >
    >


  export type txsSelect = {
    id?: boolean
    tx_id?: boolean
    tx_index?: boolean
    raw_result?: boolean
    index_block_hash?: boolean
    block_hash?: boolean
    block_height?: boolean
    parent_block_hash?: boolean
    burn_block_time?: boolean
    parent_burn_block_time?: boolean
    type_id?: boolean
    anchor_mode?: boolean
    status?: boolean
    canonical?: boolean
    post_conditions?: boolean
    nonce?: boolean
    fee_rate?: boolean
    sponsored?: boolean
    sponsor_address?: boolean
    sponsor_nonce?: boolean
    sender_address?: boolean
    origin_hash_mode?: boolean
    event_count?: boolean
    execution_cost_read_count?: boolean
    execution_cost_read_length?: boolean
    execution_cost_runtime?: boolean
    execution_cost_write_count?: boolean
    execution_cost_write_length?: boolean
    raw_tx?: boolean
    microblock_canonical?: boolean
    microblock_sequence?: boolean
    microblock_hash?: boolean
    parent_index_block_hash?: boolean
    token_transfer_recipient_address?: boolean
    token_transfer_amount?: boolean
    token_transfer_memo?: boolean
    smart_contract_clarity_version?: boolean
    smart_contract_contract_id?: boolean
    smart_contract_source_code?: boolean
    contract_call_contract_id?: boolean
    contract_call_function_name?: boolean
    contract_call_function_args?: boolean
    poison_microblock_header_1?: boolean
    poison_microblock_header_2?: boolean
    coinbase_payload?: boolean
    coinbase_alt_recipient?: boolean
  }


  export type txsGetPayload<S extends boolean | null | undefined | txsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? txs :
    S extends undefined ? never :
    S extends { include: any } & (txsArgs | txsFindManyArgs)
    ? txs 
    : S extends { select: any } & (txsArgs | txsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof txs ? txs[P] : never
  } 
      : txs


  type txsCountArgs = Merge<
    Omit<txsFindManyArgs, 'select' | 'include'> & {
      select?: TxsCountAggregateInputType | true
    }
  >

  export interface txsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Txs that matches the filter.
     * @param {txsFindUniqueArgs} args - Arguments to find a Txs
     * @example
     * // Get one Txs
     * const txs = await prisma.txs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends txsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, txsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'txs'> extends True ? Prisma__txsClient<txsGetPayload<T>> : Prisma__txsClient<txsGetPayload<T> | null, null>

    /**
     * Find one Txs that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {txsFindUniqueOrThrowArgs} args - Arguments to find a Txs
     * @example
     * // Get one Txs
     * const txs = await prisma.txs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends txsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, txsFindUniqueOrThrowArgs>
    ): Prisma__txsClient<txsGetPayload<T>>

    /**
     * Find the first Txs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txsFindFirstArgs} args - Arguments to find a Txs
     * @example
     * // Get one Txs
     * const txs = await prisma.txs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends txsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, txsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'txs'> extends True ? Prisma__txsClient<txsGetPayload<T>> : Prisma__txsClient<txsGetPayload<T> | null, null>

    /**
     * Find the first Txs that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txsFindFirstOrThrowArgs} args - Arguments to find a Txs
     * @example
     * // Get one Txs
     * const txs = await prisma.txs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends txsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, txsFindFirstOrThrowArgs>
    ): Prisma__txsClient<txsGetPayload<T>>

    /**
     * Find zero or more Txs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Txs
     * const txs = await prisma.txs.findMany()
     * 
     * // Get first 10 Txs
     * const txs = await prisma.txs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const txsWithIdOnly = await prisma.txs.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends txsFindManyArgs>(
      args?: SelectSubset<T, txsFindManyArgs>
    ): PrismaPromise<Array<txsGetPayload<T>>>

    /**
     * Create a Txs.
     * @param {txsCreateArgs} args - Arguments to create a Txs.
     * @example
     * // Create one Txs
     * const Txs = await prisma.txs.create({
     *   data: {
     *     // ... data to create a Txs
     *   }
     * })
     * 
    **/
    create<T extends txsCreateArgs>(
      args: SelectSubset<T, txsCreateArgs>
    ): Prisma__txsClient<txsGetPayload<T>>

    /**
     * Create many Txs.
     *     @param {txsCreateManyArgs} args - Arguments to create many Txs.
     *     @example
     *     // Create many Txs
     *     const txs = await prisma.txs.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends txsCreateManyArgs>(
      args?: SelectSubset<T, txsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Txs.
     * @param {txsDeleteArgs} args - Arguments to delete one Txs.
     * @example
     * // Delete one Txs
     * const Txs = await prisma.txs.delete({
     *   where: {
     *     // ... filter to delete one Txs
     *   }
     * })
     * 
    **/
    delete<T extends txsDeleteArgs>(
      args: SelectSubset<T, txsDeleteArgs>
    ): Prisma__txsClient<txsGetPayload<T>>

    /**
     * Update one Txs.
     * @param {txsUpdateArgs} args - Arguments to update one Txs.
     * @example
     * // Update one Txs
     * const txs = await prisma.txs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends txsUpdateArgs>(
      args: SelectSubset<T, txsUpdateArgs>
    ): Prisma__txsClient<txsGetPayload<T>>

    /**
     * Delete zero or more Txs.
     * @param {txsDeleteManyArgs} args - Arguments to filter Txs to delete.
     * @example
     * // Delete a few Txs
     * const { count } = await prisma.txs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends txsDeleteManyArgs>(
      args?: SelectSubset<T, txsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Txs
     * const txs = await prisma.txs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends txsUpdateManyArgs>(
      args: SelectSubset<T, txsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Txs.
     * @param {txsUpsertArgs} args - Arguments to update or create a Txs.
     * @example
     * // Update or create a Txs
     * const txs = await prisma.txs.upsert({
     *   create: {
     *     // ... data to create a Txs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Txs we want to update
     *   }
     * })
    **/
    upsert<T extends txsUpsertArgs>(
      args: SelectSubset<T, txsUpsertArgs>
    ): Prisma__txsClient<txsGetPayload<T>>

    /**
     * Count the number of Txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {txsCountArgs} args - Arguments to filter Txs to count.
     * @example
     * // Count the number of Txs
     * const count = await prisma.txs.count({
     *   where: {
     *     // ... the filter for the Txs we want to count
     *   }
     * })
    **/
    count<T extends txsCountArgs>(
      args?: Subset<T, txsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TxsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TxsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TxsAggregateArgs>(args: Subset<T, TxsAggregateArgs>): PrismaPromise<GetTxsAggregateType<T>>

    /**
     * Group by Txs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TxsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TxsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TxsGroupByArgs['orderBy'] }
        : { orderBy?: TxsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TxsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTxsGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for txs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__txsClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * txs base type for findUnique actions
   */
  export type txsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the txs
     * 
    **/
    select?: txsSelect | null
    /**
     * Filter, which txs to fetch.
     * 
    **/
    where: txsWhereUniqueInput
  }

  /**
   * txs: findUnique
   */
  export interface txsFindUniqueArgs extends txsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * txs findUniqueOrThrow
   */
  export type txsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the txs
     * 
    **/
    select?: txsSelect | null
    /**
     * Filter, which txs to fetch.
     * 
    **/
    where: txsWhereUniqueInput
  }


  /**
   * txs base type for findFirst actions
   */
  export type txsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the txs
     * 
    **/
    select?: txsSelect | null
    /**
     * Filter, which txs to fetch.
     * 
    **/
    where?: txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of txs to fetch.
     * 
    **/
    orderBy?: Enumerable<txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for txs.
     * 
    **/
    cursor?: txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` txs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of txs.
     * 
    **/
    distinct?: Enumerable<TxsScalarFieldEnum>
  }

  /**
   * txs: findFirst
   */
  export interface txsFindFirstArgs extends txsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * txs findFirstOrThrow
   */
  export type txsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the txs
     * 
    **/
    select?: txsSelect | null
    /**
     * Filter, which txs to fetch.
     * 
    **/
    where?: txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of txs to fetch.
     * 
    **/
    orderBy?: Enumerable<txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for txs.
     * 
    **/
    cursor?: txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` txs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of txs.
     * 
    **/
    distinct?: Enumerable<TxsScalarFieldEnum>
  }


  /**
   * txs findMany
   */
  export type txsFindManyArgs = {
    /**
     * Select specific fields to fetch from the txs
     * 
    **/
    select?: txsSelect | null
    /**
     * Filter, which txs to fetch.
     * 
    **/
    where?: txsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of txs to fetch.
     * 
    **/
    orderBy?: Enumerable<txsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing txs.
     * 
    **/
    cursor?: txsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` txs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` txs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TxsScalarFieldEnum>
  }


  /**
   * txs create
   */
  export type txsCreateArgs = {
    /**
     * Select specific fields to fetch from the txs
     * 
    **/
    select?: txsSelect | null
    /**
     * The data needed to create a txs.
     * 
    **/
    data: XOR<txsCreateInput, txsUncheckedCreateInput>
  }


  /**
   * txs createMany
   */
  export type txsCreateManyArgs = {
    /**
     * The data used to create many txs.
     * 
    **/
    data: Enumerable<txsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * txs update
   */
  export type txsUpdateArgs = {
    /**
     * Select specific fields to fetch from the txs
     * 
    **/
    select?: txsSelect | null
    /**
     * The data needed to update a txs.
     * 
    **/
    data: XOR<txsUpdateInput, txsUncheckedUpdateInput>
    /**
     * Choose, which txs to update.
     * 
    **/
    where: txsWhereUniqueInput
  }


  /**
   * txs updateMany
   */
  export type txsUpdateManyArgs = {
    /**
     * The data used to update txs.
     * 
    **/
    data: XOR<txsUpdateManyMutationInput, txsUncheckedUpdateManyInput>
    /**
     * Filter which txs to update
     * 
    **/
    where?: txsWhereInput
  }


  /**
   * txs upsert
   */
  export type txsUpsertArgs = {
    /**
     * Select specific fields to fetch from the txs
     * 
    **/
    select?: txsSelect | null
    /**
     * The filter to search for the txs to update in case it exists.
     * 
    **/
    where: txsWhereUniqueInput
    /**
     * In case the txs found by the `where` argument doesn't exist, create a new txs with this data.
     * 
    **/
    create: XOR<txsCreateInput, txsUncheckedCreateInput>
    /**
     * In case the txs was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<txsUpdateInput, txsUncheckedUpdateInput>
  }


  /**
   * txs delete
   */
  export type txsDeleteArgs = {
    /**
     * Select specific fields to fetch from the txs
     * 
    **/
    select?: txsSelect | null
    /**
     * Filter which txs to delete.
     * 
    **/
    where: txsWhereUniqueInput
  }


  /**
   * txs deleteMany
   */
  export type txsDeleteManyArgs = {
    /**
     * Filter which txs to delete
     * 
    **/
    where?: txsWhereInput
  }


  /**
   * txs without action
   */
  export type txsArgs = {
    /**
     * Select specific fields to fetch from the txs
     * 
    **/
    select?: txsSelect | null
  }



  /**
   * Model zonefiles
   */


  export type AggregateZonefiles = {
    _count: ZonefilesCountAggregateOutputType | null
    _avg: ZonefilesAvgAggregateOutputType | null
    _sum: ZonefilesSumAggregateOutputType | null
    _min: ZonefilesMinAggregateOutputType | null
    _max: ZonefilesMaxAggregateOutputType | null
  }

  export type ZonefilesAvgAggregateOutputType = {
    id: number | null
  }

  export type ZonefilesSumAggregateOutputType = {
    id: number | null
  }

  export type ZonefilesMinAggregateOutputType = {
    id: number | null
    name: string | null
    zonefile: string | null
    zonefile_hash: string | null
    tx_id: Buffer | null
    index_block_hash: Buffer | null
  }

  export type ZonefilesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    zonefile: string | null
    zonefile_hash: string | null
    tx_id: Buffer | null
    index_block_hash: Buffer | null
  }

  export type ZonefilesCountAggregateOutputType = {
    id: number
    name: number
    zonefile: number
    zonefile_hash: number
    tx_id: number
    index_block_hash: number
    _all: number
  }


  export type ZonefilesAvgAggregateInputType = {
    id?: true
  }

  export type ZonefilesSumAggregateInputType = {
    id?: true
  }

  export type ZonefilesMinAggregateInputType = {
    id?: true
    name?: true
    zonefile?: true
    zonefile_hash?: true
    tx_id?: true
    index_block_hash?: true
  }

  export type ZonefilesMaxAggregateInputType = {
    id?: true
    name?: true
    zonefile?: true
    zonefile_hash?: true
    tx_id?: true
    index_block_hash?: true
  }

  export type ZonefilesCountAggregateInputType = {
    id?: true
    name?: true
    zonefile?: true
    zonefile_hash?: true
    tx_id?: true
    index_block_hash?: true
    _all?: true
  }

  export type ZonefilesAggregateArgs = {
    /**
     * Filter which zonefiles to aggregate.
     * 
    **/
    where?: zonefilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zonefiles to fetch.
     * 
    **/
    orderBy?: Enumerable<zonefilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: zonefilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zonefiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zonefiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned zonefiles
    **/
    _count?: true | ZonefilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZonefilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZonefilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZonefilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZonefilesMaxAggregateInputType
  }

  export type GetZonefilesAggregateType<T extends ZonefilesAggregateArgs> = {
        [P in keyof T & keyof AggregateZonefiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZonefiles[P]>
      : GetScalarType<T[P], AggregateZonefiles[P]>
  }




  export type ZonefilesGroupByArgs = {
    where?: zonefilesWhereInput
    orderBy?: Enumerable<zonefilesOrderByWithAggregationInput>
    by: Array<ZonefilesScalarFieldEnum>
    having?: zonefilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZonefilesCountAggregateInputType | true
    _avg?: ZonefilesAvgAggregateInputType
    _sum?: ZonefilesSumAggregateInputType
    _min?: ZonefilesMinAggregateInputType
    _max?: ZonefilesMaxAggregateInputType
  }


  export type ZonefilesGroupByOutputType = {
    id: number
    name: string
    zonefile: string
    zonefile_hash: string
    tx_id: Buffer | null
    index_block_hash: Buffer | null
    _count: ZonefilesCountAggregateOutputType | null
    _avg: ZonefilesAvgAggregateOutputType | null
    _sum: ZonefilesSumAggregateOutputType | null
    _min: ZonefilesMinAggregateOutputType | null
    _max: ZonefilesMaxAggregateOutputType | null
  }

  type GetZonefilesGroupByPayload<T extends ZonefilesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ZonefilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZonefilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZonefilesGroupByOutputType[P]>
            : GetScalarType<T[P], ZonefilesGroupByOutputType[P]>
        }
      >
    >


  export type zonefilesSelect = {
    id?: boolean
    name?: boolean
    zonefile?: boolean
    zonefile_hash?: boolean
    tx_id?: boolean
    index_block_hash?: boolean
  }


  export type zonefilesGetPayload<S extends boolean | null | undefined | zonefilesArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? zonefiles :
    S extends undefined ? never :
    S extends { include: any } & (zonefilesArgs | zonefilesFindManyArgs)
    ? zonefiles 
    : S extends { select: any } & (zonefilesArgs | zonefilesFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof zonefiles ? zonefiles[P] : never
  } 
      : zonefiles


  type zonefilesCountArgs = Merge<
    Omit<zonefilesFindManyArgs, 'select' | 'include'> & {
      select?: ZonefilesCountAggregateInputType | true
    }
  >

  export interface zonefilesDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Zonefiles that matches the filter.
     * @param {zonefilesFindUniqueArgs} args - Arguments to find a Zonefiles
     * @example
     * // Get one Zonefiles
     * const zonefiles = await prisma.zonefiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends zonefilesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, zonefilesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'zonefiles'> extends True ? Prisma__zonefilesClient<zonefilesGetPayload<T>> : Prisma__zonefilesClient<zonefilesGetPayload<T> | null, null>

    /**
     * Find one Zonefiles that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {zonefilesFindUniqueOrThrowArgs} args - Arguments to find a Zonefiles
     * @example
     * // Get one Zonefiles
     * const zonefiles = await prisma.zonefiles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends zonefilesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, zonefilesFindUniqueOrThrowArgs>
    ): Prisma__zonefilesClient<zonefilesGetPayload<T>>

    /**
     * Find the first Zonefiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonefilesFindFirstArgs} args - Arguments to find a Zonefiles
     * @example
     * // Get one Zonefiles
     * const zonefiles = await prisma.zonefiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends zonefilesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, zonefilesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'zonefiles'> extends True ? Prisma__zonefilesClient<zonefilesGetPayload<T>> : Prisma__zonefilesClient<zonefilesGetPayload<T> | null, null>

    /**
     * Find the first Zonefiles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonefilesFindFirstOrThrowArgs} args - Arguments to find a Zonefiles
     * @example
     * // Get one Zonefiles
     * const zonefiles = await prisma.zonefiles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends zonefilesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, zonefilesFindFirstOrThrowArgs>
    ): Prisma__zonefilesClient<zonefilesGetPayload<T>>

    /**
     * Find zero or more Zonefiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonefilesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zonefiles
     * const zonefiles = await prisma.zonefiles.findMany()
     * 
     * // Get first 10 Zonefiles
     * const zonefiles = await prisma.zonefiles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zonefilesWithIdOnly = await prisma.zonefiles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends zonefilesFindManyArgs>(
      args?: SelectSubset<T, zonefilesFindManyArgs>
    ): PrismaPromise<Array<zonefilesGetPayload<T>>>

    /**
     * Create a Zonefiles.
     * @param {zonefilesCreateArgs} args - Arguments to create a Zonefiles.
     * @example
     * // Create one Zonefiles
     * const Zonefiles = await prisma.zonefiles.create({
     *   data: {
     *     // ... data to create a Zonefiles
     *   }
     * })
     * 
    **/
    create<T extends zonefilesCreateArgs>(
      args: SelectSubset<T, zonefilesCreateArgs>
    ): Prisma__zonefilesClient<zonefilesGetPayload<T>>

    /**
     * Create many Zonefiles.
     *     @param {zonefilesCreateManyArgs} args - Arguments to create many Zonefiles.
     *     @example
     *     // Create many Zonefiles
     *     const zonefiles = await prisma.zonefiles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends zonefilesCreateManyArgs>(
      args?: SelectSubset<T, zonefilesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Zonefiles.
     * @param {zonefilesDeleteArgs} args - Arguments to delete one Zonefiles.
     * @example
     * // Delete one Zonefiles
     * const Zonefiles = await prisma.zonefiles.delete({
     *   where: {
     *     // ... filter to delete one Zonefiles
     *   }
     * })
     * 
    **/
    delete<T extends zonefilesDeleteArgs>(
      args: SelectSubset<T, zonefilesDeleteArgs>
    ): Prisma__zonefilesClient<zonefilesGetPayload<T>>

    /**
     * Update one Zonefiles.
     * @param {zonefilesUpdateArgs} args - Arguments to update one Zonefiles.
     * @example
     * // Update one Zonefiles
     * const zonefiles = await prisma.zonefiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends zonefilesUpdateArgs>(
      args: SelectSubset<T, zonefilesUpdateArgs>
    ): Prisma__zonefilesClient<zonefilesGetPayload<T>>

    /**
     * Delete zero or more Zonefiles.
     * @param {zonefilesDeleteManyArgs} args - Arguments to filter Zonefiles to delete.
     * @example
     * // Delete a few Zonefiles
     * const { count } = await prisma.zonefiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends zonefilesDeleteManyArgs>(
      args?: SelectSubset<T, zonefilesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zonefiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonefilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zonefiles
     * const zonefiles = await prisma.zonefiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends zonefilesUpdateManyArgs>(
      args: SelectSubset<T, zonefilesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Zonefiles.
     * @param {zonefilesUpsertArgs} args - Arguments to update or create a Zonefiles.
     * @example
     * // Update or create a Zonefiles
     * const zonefiles = await prisma.zonefiles.upsert({
     *   create: {
     *     // ... data to create a Zonefiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zonefiles we want to update
     *   }
     * })
    **/
    upsert<T extends zonefilesUpsertArgs>(
      args: SelectSubset<T, zonefilesUpsertArgs>
    ): Prisma__zonefilesClient<zonefilesGetPayload<T>>

    /**
     * Count the number of Zonefiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {zonefilesCountArgs} args - Arguments to filter Zonefiles to count.
     * @example
     * // Count the number of Zonefiles
     * const count = await prisma.zonefiles.count({
     *   where: {
     *     // ... the filter for the Zonefiles we want to count
     *   }
     * })
    **/
    count<T extends zonefilesCountArgs>(
      args?: Subset<T, zonefilesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZonefilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zonefiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZonefilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZonefilesAggregateArgs>(args: Subset<T, ZonefilesAggregateArgs>): PrismaPromise<GetZonefilesAggregateType<T>>

    /**
     * Group by Zonefiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZonefilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZonefilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZonefilesGroupByArgs['orderBy'] }
        : { orderBy?: ZonefilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZonefilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZonefilesGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for zonefiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__zonefilesClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * zonefiles base type for findUnique actions
   */
  export type zonefilesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the zonefiles
     * 
    **/
    select?: zonefilesSelect | null
    /**
     * Filter, which zonefiles to fetch.
     * 
    **/
    where: zonefilesWhereUniqueInput
  }

  /**
   * zonefiles: findUnique
   */
  export interface zonefilesFindUniqueArgs extends zonefilesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * zonefiles findUniqueOrThrow
   */
  export type zonefilesFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the zonefiles
     * 
    **/
    select?: zonefilesSelect | null
    /**
     * Filter, which zonefiles to fetch.
     * 
    **/
    where: zonefilesWhereUniqueInput
  }


  /**
   * zonefiles base type for findFirst actions
   */
  export type zonefilesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the zonefiles
     * 
    **/
    select?: zonefilesSelect | null
    /**
     * Filter, which zonefiles to fetch.
     * 
    **/
    where?: zonefilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zonefiles to fetch.
     * 
    **/
    orderBy?: Enumerable<zonefilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zonefiles.
     * 
    **/
    cursor?: zonefilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zonefiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zonefiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zonefiles.
     * 
    **/
    distinct?: Enumerable<ZonefilesScalarFieldEnum>
  }

  /**
   * zonefiles: findFirst
   */
  export interface zonefilesFindFirstArgs extends zonefilesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * zonefiles findFirstOrThrow
   */
  export type zonefilesFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the zonefiles
     * 
    **/
    select?: zonefilesSelect | null
    /**
     * Filter, which zonefiles to fetch.
     * 
    **/
    where?: zonefilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zonefiles to fetch.
     * 
    **/
    orderBy?: Enumerable<zonefilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for zonefiles.
     * 
    **/
    cursor?: zonefilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zonefiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zonefiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of zonefiles.
     * 
    **/
    distinct?: Enumerable<ZonefilesScalarFieldEnum>
  }


  /**
   * zonefiles findMany
   */
  export type zonefilesFindManyArgs = {
    /**
     * Select specific fields to fetch from the zonefiles
     * 
    **/
    select?: zonefilesSelect | null
    /**
     * Filter, which zonefiles to fetch.
     * 
    **/
    where?: zonefilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of zonefiles to fetch.
     * 
    **/
    orderBy?: Enumerable<zonefilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing zonefiles.
     * 
    **/
    cursor?: zonefilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` zonefiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` zonefiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ZonefilesScalarFieldEnum>
  }


  /**
   * zonefiles create
   */
  export type zonefilesCreateArgs = {
    /**
     * Select specific fields to fetch from the zonefiles
     * 
    **/
    select?: zonefilesSelect | null
    /**
     * The data needed to create a zonefiles.
     * 
    **/
    data: XOR<zonefilesCreateInput, zonefilesUncheckedCreateInput>
  }


  /**
   * zonefiles createMany
   */
  export type zonefilesCreateManyArgs = {
    /**
     * The data used to create many zonefiles.
     * 
    **/
    data: Enumerable<zonefilesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * zonefiles update
   */
  export type zonefilesUpdateArgs = {
    /**
     * Select specific fields to fetch from the zonefiles
     * 
    **/
    select?: zonefilesSelect | null
    /**
     * The data needed to update a zonefiles.
     * 
    **/
    data: XOR<zonefilesUpdateInput, zonefilesUncheckedUpdateInput>
    /**
     * Choose, which zonefiles to update.
     * 
    **/
    where: zonefilesWhereUniqueInput
  }


  /**
   * zonefiles updateMany
   */
  export type zonefilesUpdateManyArgs = {
    /**
     * The data used to update zonefiles.
     * 
    **/
    data: XOR<zonefilesUpdateManyMutationInput, zonefilesUncheckedUpdateManyInput>
    /**
     * Filter which zonefiles to update
     * 
    **/
    where?: zonefilesWhereInput
  }


  /**
   * zonefiles upsert
   */
  export type zonefilesUpsertArgs = {
    /**
     * Select specific fields to fetch from the zonefiles
     * 
    **/
    select?: zonefilesSelect | null
    /**
     * The filter to search for the zonefiles to update in case it exists.
     * 
    **/
    where: zonefilesWhereUniqueInput
    /**
     * In case the zonefiles found by the `where` argument doesn't exist, create a new zonefiles with this data.
     * 
    **/
    create: XOR<zonefilesCreateInput, zonefilesUncheckedCreateInput>
    /**
     * In case the zonefiles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<zonefilesUpdateInput, zonefilesUncheckedUpdateInput>
  }


  /**
   * zonefiles delete
   */
  export type zonefilesDeleteArgs = {
    /**
     * Select specific fields to fetch from the zonefiles
     * 
    **/
    select?: zonefilesSelect | null
    /**
     * Filter which zonefiles to delete.
     * 
    **/
    where: zonefilesWhereUniqueInput
  }


  /**
   * zonefiles deleteMany
   */
  export type zonefilesDeleteManyArgs = {
    /**
     * Filter which zonefiles to delete
     * 
    **/
    where?: zonefilesWhereInput
  }


  /**
   * zonefiles without action
   */
  export type zonefilesArgs = {
    /**
     * Select specific fields to fetch from the zonefiles
     * 
    **/
    select?: zonefilesSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const BlocksScalarFieldEnum: {
    index_block_hash: 'index_block_hash',
    block_hash: 'block_hash',
    block_height: 'block_height',
    burn_block_time: 'burn_block_time',
    burn_block_hash: 'burn_block_hash',
    burn_block_height: 'burn_block_height',
    miner_txid: 'miner_txid',
    parent_index_block_hash: 'parent_index_block_hash',
    parent_block_hash: 'parent_block_hash',
    parent_microblock_hash: 'parent_microblock_hash',
    parent_microblock_sequence: 'parent_microblock_sequence',
    canonical: 'canonical',
    execution_cost_read_count: 'execution_cost_read_count',
    execution_cost_read_length: 'execution_cost_read_length',
    execution_cost_runtime: 'execution_cost_runtime',
    execution_cost_write_count: 'execution_cost_write_count',
    execution_cost_write_length: 'execution_cost_write_length'
  };

  export type BlocksScalarFieldEnum = (typeof BlocksScalarFieldEnum)[keyof typeof BlocksScalarFieldEnum]


  export const Burnchain_rewardsScalarFieldEnum: {
    id: 'id',
    canonical: 'canonical',
    burn_block_hash: 'burn_block_hash',
    burn_block_height: 'burn_block_height',
    burn_amount: 'burn_amount',
    reward_recipient: 'reward_recipient',
    reward_amount: 'reward_amount',
    reward_index: 'reward_index'
  };

  export type Burnchain_rewardsScalarFieldEnum = (typeof Burnchain_rewardsScalarFieldEnum)[keyof typeof Burnchain_rewardsScalarFieldEnum]


  export const Config_stateScalarFieldEnum: {
    id: 'id',
    bns_names_onchain_imported: 'bns_names_onchain_imported',
    bns_subdomains_imported: 'bns_subdomains_imported',
    token_offering_imported: 'token_offering_imported'
  };

  export type Config_stateScalarFieldEnum = (typeof Config_stateScalarFieldEnum)[keyof typeof Config_stateScalarFieldEnum]


  export const ContractLogsScalarFieldEnum: {
    id: 'id',
    event_index: 'event_index',
    tx_id: 'tx_id',
    tx_index: 'tx_index',
    block_height: 'block_height',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_canonical: 'microblock_canonical',
    canonical: 'canonical',
    contract_identifier: 'contract_identifier',
    topic: 'topic',
    value: 'value'
  };

  export type ContractLogsScalarFieldEnum = (typeof ContractLogsScalarFieldEnum)[keyof typeof ContractLogsScalarFieldEnum]


  export const Event_observer_requestsScalarFieldEnum: {
    id: 'id',
    receive_timestamp: 'receive_timestamp',
    event_path: 'event_path',
    payload: 'payload'
  };

  export type Event_observer_requestsScalarFieldEnum = (typeof Event_observer_requestsScalarFieldEnum)[keyof typeof Event_observer_requestsScalarFieldEnum]


  export const Faucet_requestsScalarFieldEnum: {
    id: 'id',
    currency: 'currency',
    address: 'address',
    ip: 'ip',
    occurred_at: 'occurred_at'
  };

  export type Faucet_requestsScalarFieldEnum = (typeof Faucet_requestsScalarFieldEnum)[keyof typeof Faucet_requestsScalarFieldEnum]


  export const Ft_eventsScalarFieldEnum: {
    id: 'id',
    event_index: 'event_index',
    tx_id: 'tx_id',
    tx_index: 'tx_index',
    block_height: 'block_height',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_canonical: 'microblock_canonical',
    canonical: 'canonical',
    asset_event_type_id: 'asset_event_type_id',
    asset_identifier: 'asset_identifier',
    amount: 'amount',
    sender: 'sender',
    recipient: 'recipient'
  };

  export type Ft_eventsScalarFieldEnum = (typeof Ft_eventsScalarFieldEnum)[keyof typeof Ft_eventsScalarFieldEnum]


  export const Ft_metadataScalarFieldEnum: {
    id: 'id',
    name: 'name',
    token_uri: 'token_uri',
    description: 'description',
    image_uri: 'image_uri',
    image_canonical_uri: 'image_canonical_uri',
    contract_id: 'contract_id',
    symbol: 'symbol',
    decimals: 'decimals',
    tx_id: 'tx_id',
    sender_address: 'sender_address'
  };

  export type Ft_metadataScalarFieldEnum = (typeof Ft_metadataScalarFieldEnum)[keyof typeof Ft_metadataScalarFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const Mempool_txsScalarFieldEnum: {
    id: 'id',
    pruned: 'pruned',
    tx_id: 'tx_id',
    type_id: 'type_id',
    anchor_mode: 'anchor_mode',
    status: 'status',
    post_conditions: 'post_conditions',
    nonce: 'nonce',
    fee_rate: 'fee_rate',
    sponsored: 'sponsored',
    sponsor_address: 'sponsor_address',
    sponsor_nonce: 'sponsor_nonce',
    sender_address: 'sender_address',
    origin_hash_mode: 'origin_hash_mode',
    raw_tx: 'raw_tx',
    receipt_time: 'receipt_time',
    receipt_block_height: 'receipt_block_height',
    token_transfer_recipient_address: 'token_transfer_recipient_address',
    token_transfer_amount: 'token_transfer_amount',
    token_transfer_memo: 'token_transfer_memo',
    smart_contract_clarity_version: 'smart_contract_clarity_version',
    smart_contract_contract_id: 'smart_contract_contract_id',
    smart_contract_source_code: 'smart_contract_source_code',
    contract_call_contract_id: 'contract_call_contract_id',
    contract_call_function_name: 'contract_call_function_name',
    contract_call_function_args: 'contract_call_function_args',
    poison_microblock_header_1: 'poison_microblock_header_1',
    poison_microblock_header_2: 'poison_microblock_header_2',
    coinbase_payload: 'coinbase_payload',
    coinbase_alt_recipient: 'coinbase_alt_recipient',
    tx_size: 'tx_size'
  };

  export type Mempool_txsScalarFieldEnum = (typeof Mempool_txsScalarFieldEnum)[keyof typeof Mempool_txsScalarFieldEnum]


  export const MicroblocksScalarFieldEnum: {
    id: 'id',
    receive_timestamp: 'receive_timestamp',
    canonical: 'canonical',
    microblock_canonical: 'microblock_canonical',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_parent_hash: 'microblock_parent_hash',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    block_height: 'block_height',
    parent_block_height: 'parent_block_height',
    parent_block_hash: 'parent_block_hash',
    parent_burn_block_height: 'parent_burn_block_height',
    parent_burn_block_time: 'parent_burn_block_time',
    parent_burn_block_hash: 'parent_burn_block_hash',
    block_hash: 'block_hash'
  };

  export type MicroblocksScalarFieldEnum = (typeof MicroblocksScalarFieldEnum)[keyof typeof MicroblocksScalarFieldEnum]


  export const Miner_rewardsScalarFieldEnum: {
    id: 'id',
    block_hash: 'block_hash',
    index_block_hash: 'index_block_hash',
    from_index_block_hash: 'from_index_block_hash',
    mature_block_height: 'mature_block_height',
    canonical: 'canonical',
    recipient: 'recipient',
    miner_address: 'miner_address',
    coinbase_amount: 'coinbase_amount',
    tx_fees_anchored: 'tx_fees_anchored',
    tx_fees_streamed_confirmed: 'tx_fees_streamed_confirmed',
    tx_fees_streamed_produced: 'tx_fees_streamed_produced'
  };

  export type Miner_rewardsScalarFieldEnum = (typeof Miner_rewardsScalarFieldEnum)[keyof typeof Miner_rewardsScalarFieldEnum]


  export const NamesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    registered_at: 'registered_at',
    expire_block: 'expire_block',
    zonefile_hash: 'zonefile_hash',
    namespace_id: 'namespace_id',
    grace_period: 'grace_period',
    renewal_deadline: 'renewal_deadline',
    resolver: 'resolver',
    tx_id: 'tx_id',
    tx_index: 'tx_index',
    event_index: 'event_index',
    status: 'status',
    canonical: 'canonical',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_canonical: 'microblock_canonical'
  };

  export type NamesScalarFieldEnum = (typeof NamesScalarFieldEnum)[keyof typeof NamesScalarFieldEnum]


  export const NamespacesScalarFieldEnum: {
    id: 'id',
    namespace_id: 'namespace_id',
    launched_at: 'launched_at',
    address: 'address',
    reveal_block: 'reveal_block',
    ready_block: 'ready_block',
    buckets: 'buckets',
    base: 'base',
    coeff: 'coeff',
    nonalpha_discount: 'nonalpha_discount',
    no_vowel_discount: 'no_vowel_discount',
    lifetime: 'lifetime',
    status: 'status',
    tx_id: 'tx_id',
    tx_index: 'tx_index',
    canonical: 'canonical',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_canonical: 'microblock_canonical'
  };

  export type NamespacesScalarFieldEnum = (typeof NamespacesScalarFieldEnum)[keyof typeof NamespacesScalarFieldEnum]


  export const Nft_eventsScalarFieldEnum: {
    id: 'id',
    event_index: 'event_index',
    tx_id: 'tx_id',
    tx_index: 'tx_index',
    block_height: 'block_height',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_canonical: 'microblock_canonical',
    canonical: 'canonical',
    asset_event_type_id: 'asset_event_type_id',
    asset_identifier: 'asset_identifier',
    value: 'value',
    sender: 'sender',
    recipient: 'recipient'
  };

  export type Nft_eventsScalarFieldEnum = (typeof Nft_eventsScalarFieldEnum)[keyof typeof Nft_eventsScalarFieldEnum]


  export const Nft_metadataScalarFieldEnum: {
    id: 'id',
    name: 'name',
    token_uri: 'token_uri',
    description: 'description',
    image_uri: 'image_uri',
    image_canonical_uri: 'image_canonical_uri',
    contract_id: 'contract_id',
    tx_id: 'tx_id',
    sender_address: 'sender_address'
  };

  export type Nft_metadataScalarFieldEnum = (typeof Nft_metadataScalarFieldEnum)[keyof typeof Nft_metadataScalarFieldEnum]


  export const PgmigrationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    run_on: 'run_on'
  };

  export type PgmigrationsScalarFieldEnum = (typeof PgmigrationsScalarFieldEnum)[keyof typeof PgmigrationsScalarFieldEnum]


  export const Pox2_eventsScalarFieldEnum: {
    id: 'id',
    event_index: 'event_index',
    tx_id: 'tx_id',
    tx_index: 'tx_index',
    block_height: 'block_height',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_canonical: 'microblock_canonical',
    canonical: 'canonical',
    stacker: 'stacker',
    locked: 'locked',
    balance: 'balance',
    burnchain_unlock_height: 'burnchain_unlock_height',
    name: 'name',
    pox_addr: 'pox_addr',
    pox_addr_raw: 'pox_addr_raw',
    first_cycle_locked: 'first_cycle_locked',
    first_unlocked_cycle: 'first_unlocked_cycle',
    lock_period: 'lock_period',
    lock_amount: 'lock_amount',
    start_burn_height: 'start_burn_height',
    unlock_burn_height: 'unlock_burn_height',
    delegator: 'delegator',
    increase_by: 'increase_by',
    total_locked: 'total_locked',
    extend_count: 'extend_count',
    reward_cycle: 'reward_cycle',
    amount_ustx: 'amount_ustx'
  };

  export type Pox2_eventsScalarFieldEnum = (typeof Pox2_eventsScalarFieldEnum)[keyof typeof Pox2_eventsScalarFieldEnum]


  export const Pox_stateScalarFieldEnum: {
    id: 'id',
    pox_v1_unlock_height: 'pox_v1_unlock_height'
  };

  export type Pox_stateScalarFieldEnum = (typeof Pox_stateScalarFieldEnum)[keyof typeof Pox_stateScalarFieldEnum]


  export const Principal_stx_txsScalarFieldEnum: {
    id: 'id',
    principal: 'principal',
    tx_id: 'tx_id',
    block_height: 'block_height',
    index_block_hash: 'index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    tx_index: 'tx_index',
    canonical: 'canonical',
    microblock_canonical: 'microblock_canonical'
  };

  export type Principal_stx_txsScalarFieldEnum = (typeof Principal_stx_txsScalarFieldEnum)[keyof typeof Principal_stx_txsScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const Reward_slot_holdersScalarFieldEnum: {
    id: 'id',
    canonical: 'canonical',
    burn_block_hash: 'burn_block_hash',
    burn_block_height: 'burn_block_height',
    address: 'address',
    slot_index: 'slot_index'
  };

  export type Reward_slot_holdersScalarFieldEnum = (typeof Reward_slot_holdersScalarFieldEnum)[keyof typeof Reward_slot_holdersScalarFieldEnum]


  export const Smart_contractsScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    canonical: 'canonical',
    contract_id: 'contract_id',
    block_height: 'block_height',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_canonical: 'microblock_canonical',
    clarity_version: 'clarity_version',
    source_code: 'source_code',
    abi: 'abi'
  };

  export type Smart_contractsScalarFieldEnum = (typeof Smart_contractsScalarFieldEnum)[keyof typeof Smart_contractsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const Stx_eventsScalarFieldEnum: {
    id: 'id',
    event_index: 'event_index',
    tx_id: 'tx_id',
    tx_index: 'tx_index',
    block_height: 'block_height',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_canonical: 'microblock_canonical',
    canonical: 'canonical',
    asset_event_type_id: 'asset_event_type_id',
    amount: 'amount',
    sender: 'sender',
    recipient: 'recipient',
    memo: 'memo'
  };

  export type Stx_eventsScalarFieldEnum = (typeof Stx_eventsScalarFieldEnum)[keyof typeof Stx_eventsScalarFieldEnum]


  export const Stx_lock_eventsScalarFieldEnum: {
    id: 'id',
    event_index: 'event_index',
    tx_id: 'tx_id',
    tx_index: 'tx_index',
    block_height: 'block_height',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_canonical: 'microblock_canonical',
    canonical: 'canonical',
    locked_amount: 'locked_amount',
    unlock_height: 'unlock_height',
    locked_address: 'locked_address',
    contract_name: 'contract_name'
  };

  export type Stx_lock_eventsScalarFieldEnum = (typeof Stx_lock_eventsScalarFieldEnum)[keyof typeof Stx_lock_eventsScalarFieldEnum]


  export const SubdomainsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    namespace_id: 'namespace_id',
    fully_qualified_subdomain: 'fully_qualified_subdomain',
    owner: 'owner',
    zonefile_hash: 'zonefile_hash',
    parent_zonefile_hash: 'parent_zonefile_hash',
    parent_zonefile_index: 'parent_zonefile_index',
    tx_index: 'tx_index',
    block_height: 'block_height',
    zonefile_offset: 'zonefile_offset',
    resolver: 'resolver',
    tx_id: 'tx_id',
    canonical: 'canonical',
    index_block_hash: 'index_block_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    microblock_hash: 'microblock_hash',
    microblock_sequence: 'microblock_sequence',
    microblock_canonical: 'microblock_canonical'
  };

  export type SubdomainsScalarFieldEnum = (typeof SubdomainsScalarFieldEnum)[keyof typeof SubdomainsScalarFieldEnum]


  export const Token_metadata_queueScalarFieldEnum: {
    queue_id: 'queue_id',
    tx_id: 'tx_id',
    contract_id: 'contract_id',
    contract_abi: 'contract_abi',
    block_height: 'block_height',
    processed: 'processed',
    retry_count: 'retry_count'
  };

  export type Token_metadata_queueScalarFieldEnum = (typeof Token_metadata_queueScalarFieldEnum)[keyof typeof Token_metadata_queueScalarFieldEnum]


  export const Token_offering_lockedScalarFieldEnum: {
    id: 'id',
    address: 'address',
    value: 'value',
    block: 'block'
  };

  export type Token_offering_lockedScalarFieldEnum = (typeof Token_offering_lockedScalarFieldEnum)[keyof typeof Token_offering_lockedScalarFieldEnum]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TxsScalarFieldEnum: {
    id: 'id',
    tx_id: 'tx_id',
    tx_index: 'tx_index',
    raw_result: 'raw_result',
    index_block_hash: 'index_block_hash',
    block_hash: 'block_hash',
    block_height: 'block_height',
    parent_block_hash: 'parent_block_hash',
    burn_block_time: 'burn_block_time',
    parent_burn_block_time: 'parent_burn_block_time',
    type_id: 'type_id',
    anchor_mode: 'anchor_mode',
    status: 'status',
    canonical: 'canonical',
    post_conditions: 'post_conditions',
    nonce: 'nonce',
    fee_rate: 'fee_rate',
    sponsored: 'sponsored',
    sponsor_address: 'sponsor_address',
    sponsor_nonce: 'sponsor_nonce',
    sender_address: 'sender_address',
    origin_hash_mode: 'origin_hash_mode',
    event_count: 'event_count',
    execution_cost_read_count: 'execution_cost_read_count',
    execution_cost_read_length: 'execution_cost_read_length',
    execution_cost_runtime: 'execution_cost_runtime',
    execution_cost_write_count: 'execution_cost_write_count',
    execution_cost_write_length: 'execution_cost_write_length',
    raw_tx: 'raw_tx',
    microblock_canonical: 'microblock_canonical',
    microblock_sequence: 'microblock_sequence',
    microblock_hash: 'microblock_hash',
    parent_index_block_hash: 'parent_index_block_hash',
    token_transfer_recipient_address: 'token_transfer_recipient_address',
    token_transfer_amount: 'token_transfer_amount',
    token_transfer_memo: 'token_transfer_memo',
    smart_contract_clarity_version: 'smart_contract_clarity_version',
    smart_contract_contract_id: 'smart_contract_contract_id',
    smart_contract_source_code: 'smart_contract_source_code',
    contract_call_contract_id: 'contract_call_contract_id',
    contract_call_function_name: 'contract_call_function_name',
    contract_call_function_args: 'contract_call_function_args',
    poison_microblock_header_1: 'poison_microblock_header_1',
    poison_microblock_header_2: 'poison_microblock_header_2',
    coinbase_payload: 'coinbase_payload',
    coinbase_alt_recipient: 'coinbase_alt_recipient'
  };

  export type TxsScalarFieldEnum = (typeof TxsScalarFieldEnum)[keyof typeof TxsScalarFieldEnum]


  export const ZonefilesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    zonefile: 'zonefile',
    zonefile_hash: 'zonefile_hash',
    tx_id: 'tx_id',
    index_block_hash: 'index_block_hash'
  };

  export type ZonefilesScalarFieldEnum = (typeof ZonefilesScalarFieldEnum)[keyof typeof ZonefilesScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type blocksWhereInput = {
    AND?: Enumerable<blocksWhereInput>
    OR?: Enumerable<blocksWhereInput>
    NOT?: Enumerable<blocksWhereInput>
    index_block_hash?: BytesFilter | Buffer
    block_hash?: BytesFilter | Buffer
    block_height?: IntFilter | number
    burn_block_time?: IntFilter | number
    burn_block_hash?: BytesFilter | Buffer
    burn_block_height?: IntFilter | number
    miner_txid?: BytesFilter | Buffer
    parent_index_block_hash?: BytesFilter | Buffer
    parent_block_hash?: BytesFilter | Buffer
    parent_microblock_hash?: BytesFilter | Buffer
    parent_microblock_sequence?: IntFilter | number
    canonical?: BoolFilter | boolean
    execution_cost_read_count?: BigIntFilter | bigint | number
    execution_cost_read_length?: BigIntFilter | bigint | number
    execution_cost_runtime?: BigIntFilter | bigint | number
    execution_cost_write_count?: BigIntFilter | bigint | number
    execution_cost_write_length?: BigIntFilter | bigint | number
  }

  export type blocksOrderByWithRelationInput = {
    index_block_hash?: SortOrder
    block_hash?: SortOrder
    block_height?: SortOrder
    burn_block_time?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    miner_txid?: SortOrder
    parent_index_block_hash?: SortOrder
    parent_block_hash?: SortOrder
    parent_microblock_hash?: SortOrder
    parent_microblock_sequence?: SortOrder
    canonical?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
  }

  export type blocksWhereUniqueInput = {
    index_block_hash?: Buffer
  }

  export type blocksOrderByWithAggregationInput = {
    index_block_hash?: SortOrder
    block_hash?: SortOrder
    block_height?: SortOrder
    burn_block_time?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    miner_txid?: SortOrder
    parent_index_block_hash?: SortOrder
    parent_block_hash?: SortOrder
    parent_microblock_hash?: SortOrder
    parent_microblock_sequence?: SortOrder
    canonical?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
    _count?: blocksCountOrderByAggregateInput
    _avg?: blocksAvgOrderByAggregateInput
    _max?: blocksMaxOrderByAggregateInput
    _min?: blocksMinOrderByAggregateInput
    _sum?: blocksSumOrderByAggregateInput
  }

  export type blocksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<blocksScalarWhereWithAggregatesInput>
    OR?: Enumerable<blocksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<blocksScalarWhereWithAggregatesInput>
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    block_hash?: BytesWithAggregatesFilter | Buffer
    block_height?: IntWithAggregatesFilter | number
    burn_block_time?: IntWithAggregatesFilter | number
    burn_block_hash?: BytesWithAggregatesFilter | Buffer
    burn_block_height?: IntWithAggregatesFilter | number
    miner_txid?: BytesWithAggregatesFilter | Buffer
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_microblock_hash?: BytesWithAggregatesFilter | Buffer
    parent_microblock_sequence?: IntWithAggregatesFilter | number
    canonical?: BoolWithAggregatesFilter | boolean
    execution_cost_read_count?: BigIntWithAggregatesFilter | bigint | number
    execution_cost_read_length?: BigIntWithAggregatesFilter | bigint | number
    execution_cost_runtime?: BigIntWithAggregatesFilter | bigint | number
    execution_cost_write_count?: BigIntWithAggregatesFilter | bigint | number
    execution_cost_write_length?: BigIntWithAggregatesFilter | bigint | number
  }

  export type burnchain_rewardsWhereInput = {
    AND?: Enumerable<burnchain_rewardsWhereInput>
    OR?: Enumerable<burnchain_rewardsWhereInput>
    NOT?: Enumerable<burnchain_rewardsWhereInput>
    id?: IntFilter | number
    canonical?: BoolFilter | boolean
    burn_block_hash?: BytesFilter | Buffer
    burn_block_height?: IntFilter | number
    burn_amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    reward_recipient?: StringFilter | string
    reward_amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    reward_index?: IntFilter | number
  }

  export type burnchain_rewardsOrderByWithRelationInput = {
    id?: SortOrder
    canonical?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    burn_amount?: SortOrder
    reward_recipient?: SortOrder
    reward_amount?: SortOrder
    reward_index?: SortOrder
  }

  export type burnchain_rewardsWhereUniqueInput = {
    id?: number
  }

  export type burnchain_rewardsOrderByWithAggregationInput = {
    id?: SortOrder
    canonical?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    burn_amount?: SortOrder
    reward_recipient?: SortOrder
    reward_amount?: SortOrder
    reward_index?: SortOrder
    _count?: burnchain_rewardsCountOrderByAggregateInput
    _avg?: burnchain_rewardsAvgOrderByAggregateInput
    _max?: burnchain_rewardsMaxOrderByAggregateInput
    _min?: burnchain_rewardsMinOrderByAggregateInput
    _sum?: burnchain_rewardsSumOrderByAggregateInput
  }

  export type burnchain_rewardsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<burnchain_rewardsScalarWhereWithAggregatesInput>
    OR?: Enumerable<burnchain_rewardsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<burnchain_rewardsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    canonical?: BoolWithAggregatesFilter | boolean
    burn_block_hash?: BytesWithAggregatesFilter | Buffer
    burn_block_height?: IntWithAggregatesFilter | number
    burn_amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    reward_recipient?: StringWithAggregatesFilter | string
    reward_amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    reward_index?: IntWithAggregatesFilter | number
  }

  export type config_stateWhereInput = {
    AND?: Enumerable<config_stateWhereInput>
    OR?: Enumerable<config_stateWhereInput>
    NOT?: Enumerable<config_stateWhereInput>
    id?: BoolFilter | boolean
    bns_names_onchain_imported?: BoolFilter | boolean
    bns_subdomains_imported?: BoolFilter | boolean
    token_offering_imported?: BoolFilter | boolean
  }

  export type config_stateOrderByWithRelationInput = {
    id?: SortOrder
    bns_names_onchain_imported?: SortOrder
    bns_subdomains_imported?: SortOrder
    token_offering_imported?: SortOrder
  }

  export type config_stateWhereUniqueInput = {
    id?: boolean
  }

  export type config_stateOrderByWithAggregationInput = {
    id?: SortOrder
    bns_names_onchain_imported?: SortOrder
    bns_subdomains_imported?: SortOrder
    token_offering_imported?: SortOrder
    _count?: config_stateCountOrderByAggregateInput
    _max?: config_stateMaxOrderByAggregateInput
    _min?: config_stateMinOrderByAggregateInput
  }

  export type config_stateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<config_stateScalarWhereWithAggregatesInput>
    OR?: Enumerable<config_stateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<config_stateScalarWhereWithAggregatesInput>
    id?: BoolWithAggregatesFilter | boolean
    bns_names_onchain_imported?: BoolWithAggregatesFilter | boolean
    bns_subdomains_imported?: BoolWithAggregatesFilter | boolean
    token_offering_imported?: BoolWithAggregatesFilter | boolean
  }

  export type ContractLogsWhereInput = {
    AND?: Enumerable<ContractLogsWhereInput>
    OR?: Enumerable<ContractLogsWhereInput>
    NOT?: Enumerable<ContractLogsWhereInput>
    id?: IntFilter | number
    event_index?: IntFilter | number
    tx_id?: BytesFilter | Buffer
    tx_index?: IntFilter | number
    block_height?: IntFilter | number
    index_block_hash?: BytesFilter | Buffer
    parent_index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_canonical?: BoolFilter | boolean
    canonical?: BoolFilter | boolean
    contract_identifier?: StringFilter | string
    topic?: StringFilter | string
    value?: BytesFilter | Buffer
  }

  export type ContractLogsOrderByWithRelationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    contract_identifier?: SortOrder
    topic?: SortOrder
    value?: SortOrder
  }

  export type ContractLogsWhereUniqueInput = {
    id?: number
  }

  export type ContractLogsOrderByWithAggregationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    contract_identifier?: SortOrder
    topic?: SortOrder
    value?: SortOrder
    _count?: ContractLogsCountOrderByAggregateInput
    _avg?: ContractLogsAvgOrderByAggregateInput
    _max?: ContractLogsMaxOrderByAggregateInput
    _min?: ContractLogsMinOrderByAggregateInput
    _sum?: ContractLogsSumOrderByAggregateInput
  }

  export type ContractLogsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ContractLogsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ContractLogsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ContractLogsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    event_index?: IntWithAggregatesFilter | number
    tx_id?: BytesWithAggregatesFilter | Buffer
    tx_index?: IntWithAggregatesFilter | number
    block_height?: IntWithAggregatesFilter | number
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_canonical?: BoolWithAggregatesFilter | boolean
    canonical?: BoolWithAggregatesFilter | boolean
    contract_identifier?: StringWithAggregatesFilter | string
    topic?: StringWithAggregatesFilter | string
    value?: BytesWithAggregatesFilter | Buffer
  }

  export type event_observer_requestsWhereInput = {
    AND?: Enumerable<event_observer_requestsWhereInput>
    OR?: Enumerable<event_observer_requestsWhereInput>
    NOT?: Enumerable<event_observer_requestsWhereInput>
    id?: BigIntFilter | bigint | number
    receive_timestamp?: DateTimeFilter | Date | string
    event_path?: StringFilter | string
    payload?: JsonFilter
  }

  export type event_observer_requestsOrderByWithRelationInput = {
    id?: SortOrder
    receive_timestamp?: SortOrder
    event_path?: SortOrder
    payload?: SortOrder
  }

  export type event_observer_requestsWhereUniqueInput = {
    id?: bigint | number
  }

  export type event_observer_requestsOrderByWithAggregationInput = {
    id?: SortOrder
    receive_timestamp?: SortOrder
    event_path?: SortOrder
    payload?: SortOrder
    _count?: event_observer_requestsCountOrderByAggregateInput
    _avg?: event_observer_requestsAvgOrderByAggregateInput
    _max?: event_observer_requestsMaxOrderByAggregateInput
    _min?: event_observer_requestsMinOrderByAggregateInput
    _sum?: event_observer_requestsSumOrderByAggregateInput
  }

  export type event_observer_requestsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<event_observer_requestsScalarWhereWithAggregatesInput>
    OR?: Enumerable<event_observer_requestsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<event_observer_requestsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    receive_timestamp?: DateTimeWithAggregatesFilter | Date | string
    event_path?: StringWithAggregatesFilter | string
    payload?: JsonWithAggregatesFilter
  }

  export type faucet_requestsWhereInput = {
    AND?: Enumerable<faucet_requestsWhereInput>
    OR?: Enumerable<faucet_requestsWhereInput>
    NOT?: Enumerable<faucet_requestsWhereInput>
    id?: IntFilter | number
    currency?: StringFilter | string
    address?: StringFilter | string
    ip?: StringFilter | string
    occurred_at?: BigIntFilter | bigint | number
  }

  export type faucet_requestsOrderByWithRelationInput = {
    id?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    ip?: SortOrder
    occurred_at?: SortOrder
  }

  export type faucet_requestsWhereUniqueInput = {
    id?: number
  }

  export type faucet_requestsOrderByWithAggregationInput = {
    id?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    ip?: SortOrder
    occurred_at?: SortOrder
    _count?: faucet_requestsCountOrderByAggregateInput
    _avg?: faucet_requestsAvgOrderByAggregateInput
    _max?: faucet_requestsMaxOrderByAggregateInput
    _min?: faucet_requestsMinOrderByAggregateInput
    _sum?: faucet_requestsSumOrderByAggregateInput
  }

  export type faucet_requestsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<faucet_requestsScalarWhereWithAggregatesInput>
    OR?: Enumerable<faucet_requestsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<faucet_requestsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    currency?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    ip?: StringWithAggregatesFilter | string
    occurred_at?: BigIntWithAggregatesFilter | bigint | number
  }

  export type ft_eventsWhereInput = {
    AND?: Enumerable<ft_eventsWhereInput>
    OR?: Enumerable<ft_eventsWhereInput>
    NOT?: Enumerable<ft_eventsWhereInput>
    id?: IntFilter | number
    event_index?: IntFilter | number
    tx_id?: BytesFilter | Buffer
    tx_index?: IntFilter | number
    block_height?: IntFilter | number
    index_block_hash?: BytesFilter | Buffer
    parent_index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_canonical?: BoolFilter | boolean
    canonical?: BoolFilter | boolean
    asset_event_type_id?: IntFilter | number
    asset_identifier?: StringFilter | string
    amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    sender?: StringNullableFilter | string | null
    recipient?: StringNullableFilter | string | null
  }

  export type ft_eventsOrderByWithRelationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    asset_identifier?: SortOrder
    amount?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
  }

  export type ft_eventsWhereUniqueInput = {
    id?: number
  }

  export type ft_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    asset_identifier?: SortOrder
    amount?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    _count?: ft_eventsCountOrderByAggregateInput
    _avg?: ft_eventsAvgOrderByAggregateInput
    _max?: ft_eventsMaxOrderByAggregateInput
    _min?: ft_eventsMinOrderByAggregateInput
    _sum?: ft_eventsSumOrderByAggregateInput
  }

  export type ft_eventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ft_eventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<ft_eventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ft_eventsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    event_index?: IntWithAggregatesFilter | number
    tx_id?: BytesWithAggregatesFilter | Buffer
    tx_index?: IntWithAggregatesFilter | number
    block_height?: IntWithAggregatesFilter | number
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_canonical?: BoolWithAggregatesFilter | boolean
    canonical?: BoolWithAggregatesFilter | boolean
    asset_event_type_id?: IntWithAggregatesFilter | number
    asset_identifier?: StringWithAggregatesFilter | string
    amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    sender?: StringNullableWithAggregatesFilter | string | null
    recipient?: StringNullableWithAggregatesFilter | string | null
  }

  export type ft_metadataWhereInput = {
    AND?: Enumerable<ft_metadataWhereInput>
    OR?: Enumerable<ft_metadataWhereInput>
    NOT?: Enumerable<ft_metadataWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    token_uri?: StringFilter | string
    description?: StringFilter | string
    image_uri?: StringFilter | string
    image_canonical_uri?: StringFilter | string
    contract_id?: StringFilter | string
    symbol?: StringFilter | string
    decimals?: IntFilter | number
    tx_id?: BytesFilter | Buffer
    sender_address?: StringFilter | string
  }

  export type ft_metadataOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    token_uri?: SortOrder
    description?: SortOrder
    image_uri?: SortOrder
    image_canonical_uri?: SortOrder
    contract_id?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    tx_id?: SortOrder
    sender_address?: SortOrder
  }

  export type ft_metadataWhereUniqueInput = {
    id?: number
    contract_id?: string
  }

  export type ft_metadataOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    token_uri?: SortOrder
    description?: SortOrder
    image_uri?: SortOrder
    image_canonical_uri?: SortOrder
    contract_id?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    tx_id?: SortOrder
    sender_address?: SortOrder
    _count?: ft_metadataCountOrderByAggregateInput
    _avg?: ft_metadataAvgOrderByAggregateInput
    _max?: ft_metadataMaxOrderByAggregateInput
    _min?: ft_metadataMinOrderByAggregateInput
    _sum?: ft_metadataSumOrderByAggregateInput
  }

  export type ft_metadataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ft_metadataScalarWhereWithAggregatesInput>
    OR?: Enumerable<ft_metadataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ft_metadataScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    token_uri?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    image_uri?: StringWithAggregatesFilter | string
    image_canonical_uri?: StringWithAggregatesFilter | string
    contract_id?: StringWithAggregatesFilter | string
    symbol?: StringWithAggregatesFilter | string
    decimals?: IntWithAggregatesFilter | number
    tx_id?: BytesWithAggregatesFilter | Buffer
    sender_address?: StringWithAggregatesFilter | string
  }

  export type mempool_txsWhereInput = {
    AND?: Enumerable<mempool_txsWhereInput>
    OR?: Enumerable<mempool_txsWhereInput>
    NOT?: Enumerable<mempool_txsWhereInput>
    id?: IntFilter | number
    pruned?: BoolFilter | boolean
    tx_id?: BytesFilter | Buffer
    type_id?: IntFilter | number
    anchor_mode?: IntFilter | number
    status?: IntFilter | number
    post_conditions?: BytesFilter | Buffer
    nonce?: IntFilter | number
    fee_rate?: BigIntFilter | bigint | number
    sponsored?: BoolFilter | boolean
    sponsor_address?: StringNullableFilter | string | null
    sponsor_nonce?: IntNullableFilter | number | null
    sender_address?: StringFilter | string
    origin_hash_mode?: IntFilter | number
    raw_tx?: BytesFilter | Buffer
    receipt_time?: IntFilter | number
    receipt_block_height?: IntFilter | number
    token_transfer_recipient_address?: StringNullableFilter | string | null
    token_transfer_amount?: BigIntNullableFilter | bigint | number | null
    token_transfer_memo?: BytesNullableFilter | Buffer | null
    smart_contract_clarity_version?: IntNullableFilter | number | null
    smart_contract_contract_id?: StringNullableFilter | string | null
    smart_contract_source_code?: StringNullableFilter | string | null
    contract_call_contract_id?: StringNullableFilter | string | null
    contract_call_function_name?: StringNullableFilter | string | null
    contract_call_function_args?: BytesNullableFilter | Buffer | null
    poison_microblock_header_1?: BytesNullableFilter | Buffer | null
    poison_microblock_header_2?: BytesNullableFilter | Buffer | null
    coinbase_payload?: BytesNullableFilter | Buffer | null
    coinbase_alt_recipient?: StringNullableFilter | string | null
    tx_size?: IntFilter | number
  }

  export type mempool_txsOrderByWithRelationInput = {
    id?: SortOrder
    pruned?: SortOrder
    tx_id?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    post_conditions?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsored?: SortOrder
    sponsor_address?: SortOrder
    sponsor_nonce?: SortOrder
    sender_address?: SortOrder
    origin_hash_mode?: SortOrder
    raw_tx?: SortOrder
    receipt_time?: SortOrder
    receipt_block_height?: SortOrder
    token_transfer_recipient_address?: SortOrder
    token_transfer_amount?: SortOrder
    token_transfer_memo?: SortOrder
    smart_contract_clarity_version?: SortOrder
    smart_contract_contract_id?: SortOrder
    smart_contract_source_code?: SortOrder
    contract_call_contract_id?: SortOrder
    contract_call_function_name?: SortOrder
    contract_call_function_args?: SortOrder
    poison_microblock_header_1?: SortOrder
    poison_microblock_header_2?: SortOrder
    coinbase_payload?: SortOrder
    coinbase_alt_recipient?: SortOrder
    tx_size?: SortOrder
  }

  export type mempool_txsWhereUniqueInput = {
    id?: number
    tx_id?: Buffer
  }

  export type mempool_txsOrderByWithAggregationInput = {
    id?: SortOrder
    pruned?: SortOrder
    tx_id?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    post_conditions?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsored?: SortOrder
    sponsor_address?: SortOrder
    sponsor_nonce?: SortOrder
    sender_address?: SortOrder
    origin_hash_mode?: SortOrder
    raw_tx?: SortOrder
    receipt_time?: SortOrder
    receipt_block_height?: SortOrder
    token_transfer_recipient_address?: SortOrder
    token_transfer_amount?: SortOrder
    token_transfer_memo?: SortOrder
    smart_contract_clarity_version?: SortOrder
    smart_contract_contract_id?: SortOrder
    smart_contract_source_code?: SortOrder
    contract_call_contract_id?: SortOrder
    contract_call_function_name?: SortOrder
    contract_call_function_args?: SortOrder
    poison_microblock_header_1?: SortOrder
    poison_microblock_header_2?: SortOrder
    coinbase_payload?: SortOrder
    coinbase_alt_recipient?: SortOrder
    tx_size?: SortOrder
    _count?: mempool_txsCountOrderByAggregateInput
    _avg?: mempool_txsAvgOrderByAggregateInput
    _max?: mempool_txsMaxOrderByAggregateInput
    _min?: mempool_txsMinOrderByAggregateInput
    _sum?: mempool_txsSumOrderByAggregateInput
  }

  export type mempool_txsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<mempool_txsScalarWhereWithAggregatesInput>
    OR?: Enumerable<mempool_txsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<mempool_txsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    pruned?: BoolWithAggregatesFilter | boolean
    tx_id?: BytesWithAggregatesFilter | Buffer
    type_id?: IntWithAggregatesFilter | number
    anchor_mode?: IntWithAggregatesFilter | number
    status?: IntWithAggregatesFilter | number
    post_conditions?: BytesWithAggregatesFilter | Buffer
    nonce?: IntWithAggregatesFilter | number
    fee_rate?: BigIntWithAggregatesFilter | bigint | number
    sponsored?: BoolWithAggregatesFilter | boolean
    sponsor_address?: StringNullableWithAggregatesFilter | string | null
    sponsor_nonce?: IntNullableWithAggregatesFilter | number | null
    sender_address?: StringWithAggregatesFilter | string
    origin_hash_mode?: IntWithAggregatesFilter | number
    raw_tx?: BytesWithAggregatesFilter | Buffer
    receipt_time?: IntWithAggregatesFilter | number
    receipt_block_height?: IntWithAggregatesFilter | number
    token_transfer_recipient_address?: StringNullableWithAggregatesFilter | string | null
    token_transfer_amount?: BigIntNullableWithAggregatesFilter | bigint | number | null
    token_transfer_memo?: BytesNullableWithAggregatesFilter | Buffer | null
    smart_contract_clarity_version?: IntNullableWithAggregatesFilter | number | null
    smart_contract_contract_id?: StringNullableWithAggregatesFilter | string | null
    smart_contract_source_code?: StringNullableWithAggregatesFilter | string | null
    contract_call_contract_id?: StringNullableWithAggregatesFilter | string | null
    contract_call_function_name?: StringNullableWithAggregatesFilter | string | null
    contract_call_function_args?: BytesNullableWithAggregatesFilter | Buffer | null
    poison_microblock_header_1?: BytesNullableWithAggregatesFilter | Buffer | null
    poison_microblock_header_2?: BytesNullableWithAggregatesFilter | Buffer | null
    coinbase_payload?: BytesNullableWithAggregatesFilter | Buffer | null
    coinbase_alt_recipient?: StringNullableWithAggregatesFilter | string | null
    tx_size?: IntWithAggregatesFilter | number
  }

  export type microblocksWhereInput = {
    AND?: Enumerable<microblocksWhereInput>
    OR?: Enumerable<microblocksWhereInput>
    NOT?: Enumerable<microblocksWhereInput>
    id?: BigIntFilter | bigint | number
    receive_timestamp?: DateTimeFilter | Date | string
    canonical?: BoolFilter | boolean
    microblock_canonical?: BoolFilter | boolean
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_parent_hash?: BytesFilter | Buffer
    index_block_hash?: BytesFilter | Buffer
    parent_index_block_hash?: BytesFilter | Buffer
    block_height?: IntFilter | number
    parent_block_height?: IntFilter | number
    parent_block_hash?: BytesFilter | Buffer
    parent_burn_block_height?: IntFilter | number
    parent_burn_block_time?: IntFilter | number
    parent_burn_block_hash?: BytesFilter | Buffer
    block_hash?: BytesFilter | Buffer
  }

  export type microblocksOrderByWithRelationInput = {
    id?: SortOrder
    receive_timestamp?: SortOrder
    canonical?: SortOrder
    microblock_canonical?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_parent_hash?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    block_height?: SortOrder
    parent_block_height?: SortOrder
    parent_block_hash?: SortOrder
    parent_burn_block_height?: SortOrder
    parent_burn_block_time?: SortOrder
    parent_burn_block_hash?: SortOrder
    block_hash?: SortOrder
  }

  export type microblocksWhereUniqueInput = {
    id?: bigint | number
    microblock_hash?: Buffer
  }

  export type microblocksOrderByWithAggregationInput = {
    id?: SortOrder
    receive_timestamp?: SortOrder
    canonical?: SortOrder
    microblock_canonical?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_parent_hash?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    block_height?: SortOrder
    parent_block_height?: SortOrder
    parent_block_hash?: SortOrder
    parent_burn_block_height?: SortOrder
    parent_burn_block_time?: SortOrder
    parent_burn_block_hash?: SortOrder
    block_hash?: SortOrder
    _count?: microblocksCountOrderByAggregateInput
    _avg?: microblocksAvgOrderByAggregateInput
    _max?: microblocksMaxOrderByAggregateInput
    _min?: microblocksMinOrderByAggregateInput
    _sum?: microblocksSumOrderByAggregateInput
  }

  export type microblocksScalarWhereWithAggregatesInput = {
    AND?: Enumerable<microblocksScalarWhereWithAggregatesInput>
    OR?: Enumerable<microblocksScalarWhereWithAggregatesInput>
    NOT?: Enumerable<microblocksScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    receive_timestamp?: DateTimeWithAggregatesFilter | Date | string
    canonical?: BoolWithAggregatesFilter | boolean
    microblock_canonical?: BoolWithAggregatesFilter | boolean
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_parent_hash?: BytesWithAggregatesFilter | Buffer
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    block_height?: IntWithAggregatesFilter | number
    parent_block_height?: IntWithAggregatesFilter | number
    parent_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_burn_block_height?: IntWithAggregatesFilter | number
    parent_burn_block_time?: IntWithAggregatesFilter | number
    parent_burn_block_hash?: BytesWithAggregatesFilter | Buffer
    block_hash?: BytesWithAggregatesFilter | Buffer
  }

  export type miner_rewardsWhereInput = {
    AND?: Enumerable<miner_rewardsWhereInput>
    OR?: Enumerable<miner_rewardsWhereInput>
    NOT?: Enumerable<miner_rewardsWhereInput>
    id?: IntFilter | number
    block_hash?: BytesFilter | Buffer
    index_block_hash?: BytesFilter | Buffer
    from_index_block_hash?: BytesFilter | Buffer
    mature_block_height?: IntFilter | number
    canonical?: BoolFilter | boolean
    recipient?: StringFilter | string
    miner_address?: StringNullableFilter | string | null
    coinbase_amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    tx_fees_anchored?: DecimalFilter | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_confirmed?: DecimalFilter | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_produced?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type miner_rewardsOrderByWithRelationInput = {
    id?: SortOrder
    block_hash?: SortOrder
    index_block_hash?: SortOrder
    from_index_block_hash?: SortOrder
    mature_block_height?: SortOrder
    canonical?: SortOrder
    recipient?: SortOrder
    miner_address?: SortOrder
    coinbase_amount?: SortOrder
    tx_fees_anchored?: SortOrder
    tx_fees_streamed_confirmed?: SortOrder
    tx_fees_streamed_produced?: SortOrder
  }

  export type miner_rewardsWhereUniqueInput = {
    id?: number
  }

  export type miner_rewardsOrderByWithAggregationInput = {
    id?: SortOrder
    block_hash?: SortOrder
    index_block_hash?: SortOrder
    from_index_block_hash?: SortOrder
    mature_block_height?: SortOrder
    canonical?: SortOrder
    recipient?: SortOrder
    miner_address?: SortOrder
    coinbase_amount?: SortOrder
    tx_fees_anchored?: SortOrder
    tx_fees_streamed_confirmed?: SortOrder
    tx_fees_streamed_produced?: SortOrder
    _count?: miner_rewardsCountOrderByAggregateInput
    _avg?: miner_rewardsAvgOrderByAggregateInput
    _max?: miner_rewardsMaxOrderByAggregateInput
    _min?: miner_rewardsMinOrderByAggregateInput
    _sum?: miner_rewardsSumOrderByAggregateInput
  }

  export type miner_rewardsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<miner_rewardsScalarWhereWithAggregatesInput>
    OR?: Enumerable<miner_rewardsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<miner_rewardsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    block_hash?: BytesWithAggregatesFilter | Buffer
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    from_index_block_hash?: BytesWithAggregatesFilter | Buffer
    mature_block_height?: IntWithAggregatesFilter | number
    canonical?: BoolWithAggregatesFilter | boolean
    recipient?: StringWithAggregatesFilter | string
    miner_address?: StringNullableWithAggregatesFilter | string | null
    coinbase_amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    tx_fees_anchored?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_confirmed?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_produced?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type namesWhereInput = {
    AND?: Enumerable<namesWhereInput>
    OR?: Enumerable<namesWhereInput>
    NOT?: Enumerable<namesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    address?: StringFilter | string
    registered_at?: IntFilter | number
    expire_block?: IntFilter | number
    zonefile_hash?: StringFilter | string
    namespace_id?: StringFilter | string
    grace_period?: StringNullableFilter | string | null
    renewal_deadline?: IntNullableFilter | number | null
    resolver?: StringNullableFilter | string | null
    tx_id?: BytesNullableFilter | Buffer | null
    tx_index?: IntFilter | number
    event_index?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
    canonical?: BoolFilter | boolean
    index_block_hash?: BytesNullableFilter | Buffer | null
    parent_index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_canonical?: BoolFilter | boolean
  }

  export type namesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    registered_at?: SortOrder
    expire_block?: SortOrder
    zonefile_hash?: SortOrder
    namespace_id?: SortOrder
    grace_period?: SortOrder
    renewal_deadline?: SortOrder
    resolver?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    event_index?: SortOrder
    status?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type namesWhereUniqueInput = {
    id?: number
    name_tx_id_index_block_hash_microblock_hash_event_index?: namesNameTx_idIndex_block_hashMicroblock_hashEvent_indexCompoundUniqueInput
  }

  export type namesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    registered_at?: SortOrder
    expire_block?: SortOrder
    zonefile_hash?: SortOrder
    namespace_id?: SortOrder
    grace_period?: SortOrder
    renewal_deadline?: SortOrder
    resolver?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    event_index?: SortOrder
    status?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    _count?: namesCountOrderByAggregateInput
    _avg?: namesAvgOrderByAggregateInput
    _max?: namesMaxOrderByAggregateInput
    _min?: namesMinOrderByAggregateInput
    _sum?: namesSumOrderByAggregateInput
  }

  export type namesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<namesScalarWhereWithAggregatesInput>
    OR?: Enumerable<namesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<namesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    registered_at?: IntWithAggregatesFilter | number
    expire_block?: IntWithAggregatesFilter | number
    zonefile_hash?: StringWithAggregatesFilter | string
    namespace_id?: StringWithAggregatesFilter | string
    grace_period?: StringNullableWithAggregatesFilter | string | null
    renewal_deadline?: IntNullableWithAggregatesFilter | number | null
    resolver?: StringNullableWithAggregatesFilter | string | null
    tx_id?: BytesNullableWithAggregatesFilter | Buffer | null
    tx_index?: IntWithAggregatesFilter | number
    event_index?: IntNullableWithAggregatesFilter | number | null
    status?: StringNullableWithAggregatesFilter | string | null
    canonical?: BoolWithAggregatesFilter | boolean
    index_block_hash?: BytesNullableWithAggregatesFilter | Buffer | null
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_canonical?: BoolWithAggregatesFilter | boolean
  }

  export type namespacesWhereInput = {
    AND?: Enumerable<namespacesWhereInput>
    OR?: Enumerable<namespacesWhereInput>
    NOT?: Enumerable<namespacesWhereInput>
    id?: IntFilter | number
    namespace_id?: StringFilter | string
    launched_at?: IntNullableFilter | number | null
    address?: StringFilter | string
    reveal_block?: IntFilter | number
    ready_block?: IntFilter | number
    buckets?: StringFilter | string
    base?: DecimalFilter | Decimal | DecimalJsLike | number | string
    coeff?: DecimalFilter | Decimal | DecimalJsLike | number | string
    nonalpha_discount?: IntFilter | number
    no_vowel_discount?: IntFilter | number
    lifetime?: IntFilter | number
    status?: StringNullableFilter | string | null
    tx_id?: BytesNullableFilter | Buffer | null
    tx_index?: IntFilter | number
    canonical?: BoolFilter | boolean
    index_block_hash?: BytesNullableFilter | Buffer | null
    parent_index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_canonical?: BoolFilter | boolean
  }

  export type namespacesOrderByWithRelationInput = {
    id?: SortOrder
    namespace_id?: SortOrder
    launched_at?: SortOrder
    address?: SortOrder
    reveal_block?: SortOrder
    ready_block?: SortOrder
    buckets?: SortOrder
    base?: SortOrder
    coeff?: SortOrder
    nonalpha_discount?: SortOrder
    no_vowel_discount?: SortOrder
    lifetime?: SortOrder
    status?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type namespacesWhereUniqueInput = {
    id?: number
    namespace_id_tx_id_index_block_hash_microblock_hash?: namespacesNamespace_idTx_idIndex_block_hashMicroblock_hashCompoundUniqueInput
  }

  export type namespacesOrderByWithAggregationInput = {
    id?: SortOrder
    namespace_id?: SortOrder
    launched_at?: SortOrder
    address?: SortOrder
    reveal_block?: SortOrder
    ready_block?: SortOrder
    buckets?: SortOrder
    base?: SortOrder
    coeff?: SortOrder
    nonalpha_discount?: SortOrder
    no_vowel_discount?: SortOrder
    lifetime?: SortOrder
    status?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    _count?: namespacesCountOrderByAggregateInput
    _avg?: namespacesAvgOrderByAggregateInput
    _max?: namespacesMaxOrderByAggregateInput
    _min?: namespacesMinOrderByAggregateInput
    _sum?: namespacesSumOrderByAggregateInput
  }

  export type namespacesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<namespacesScalarWhereWithAggregatesInput>
    OR?: Enumerable<namespacesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<namespacesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    namespace_id?: StringWithAggregatesFilter | string
    launched_at?: IntNullableWithAggregatesFilter | number | null
    address?: StringWithAggregatesFilter | string
    reveal_block?: IntWithAggregatesFilter | number
    ready_block?: IntWithAggregatesFilter | number
    buckets?: StringWithAggregatesFilter | string
    base?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    coeff?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    nonalpha_discount?: IntWithAggregatesFilter | number
    no_vowel_discount?: IntWithAggregatesFilter | number
    lifetime?: IntWithAggregatesFilter | number
    status?: StringNullableWithAggregatesFilter | string | null
    tx_id?: BytesNullableWithAggregatesFilter | Buffer | null
    tx_index?: IntWithAggregatesFilter | number
    canonical?: BoolWithAggregatesFilter | boolean
    index_block_hash?: BytesNullableWithAggregatesFilter | Buffer | null
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_canonical?: BoolWithAggregatesFilter | boolean
  }

  export type nft_eventsWhereInput = {
    AND?: Enumerable<nft_eventsWhereInput>
    OR?: Enumerable<nft_eventsWhereInput>
    NOT?: Enumerable<nft_eventsWhereInput>
    id?: IntFilter | number
    event_index?: IntFilter | number
    tx_id?: BytesFilter | Buffer
    tx_index?: IntFilter | number
    block_height?: IntFilter | number
    index_block_hash?: BytesFilter | Buffer
    parent_index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_canonical?: BoolFilter | boolean
    canonical?: BoolFilter | boolean
    asset_event_type_id?: IntFilter | number
    asset_identifier?: StringFilter | string
    value?: BytesFilter | Buffer
    sender?: StringNullableFilter | string | null
    recipient?: StringNullableFilter | string | null
  }

  export type nft_eventsOrderByWithRelationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    asset_identifier?: SortOrder
    value?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
  }

  export type nft_eventsWhereUniqueInput = {
    id?: number
  }

  export type nft_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    asset_identifier?: SortOrder
    value?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    _count?: nft_eventsCountOrderByAggregateInput
    _avg?: nft_eventsAvgOrderByAggregateInput
    _max?: nft_eventsMaxOrderByAggregateInput
    _min?: nft_eventsMinOrderByAggregateInput
    _sum?: nft_eventsSumOrderByAggregateInput
  }

  export type nft_eventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<nft_eventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<nft_eventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<nft_eventsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    event_index?: IntWithAggregatesFilter | number
    tx_id?: BytesWithAggregatesFilter | Buffer
    tx_index?: IntWithAggregatesFilter | number
    block_height?: IntWithAggregatesFilter | number
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_canonical?: BoolWithAggregatesFilter | boolean
    canonical?: BoolWithAggregatesFilter | boolean
    asset_event_type_id?: IntWithAggregatesFilter | number
    asset_identifier?: StringWithAggregatesFilter | string
    value?: BytesWithAggregatesFilter | Buffer
    sender?: StringNullableWithAggregatesFilter | string | null
    recipient?: StringNullableWithAggregatesFilter | string | null
  }

  export type nft_metadataWhereInput = {
    AND?: Enumerable<nft_metadataWhereInput>
    OR?: Enumerable<nft_metadataWhereInput>
    NOT?: Enumerable<nft_metadataWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    token_uri?: StringFilter | string
    description?: StringFilter | string
    image_uri?: StringFilter | string
    image_canonical_uri?: StringFilter | string
    contract_id?: StringFilter | string
    tx_id?: BytesFilter | Buffer
    sender_address?: StringFilter | string
  }

  export type nft_metadataOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    token_uri?: SortOrder
    description?: SortOrder
    image_uri?: SortOrder
    image_canonical_uri?: SortOrder
    contract_id?: SortOrder
    tx_id?: SortOrder
    sender_address?: SortOrder
  }

  export type nft_metadataWhereUniqueInput = {
    id?: number
    contract_id?: string
  }

  export type nft_metadataOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    token_uri?: SortOrder
    description?: SortOrder
    image_uri?: SortOrder
    image_canonical_uri?: SortOrder
    contract_id?: SortOrder
    tx_id?: SortOrder
    sender_address?: SortOrder
    _count?: nft_metadataCountOrderByAggregateInput
    _avg?: nft_metadataAvgOrderByAggregateInput
    _max?: nft_metadataMaxOrderByAggregateInput
    _min?: nft_metadataMinOrderByAggregateInput
    _sum?: nft_metadataSumOrderByAggregateInput
  }

  export type nft_metadataScalarWhereWithAggregatesInput = {
    AND?: Enumerable<nft_metadataScalarWhereWithAggregatesInput>
    OR?: Enumerable<nft_metadataScalarWhereWithAggregatesInput>
    NOT?: Enumerable<nft_metadataScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    token_uri?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    image_uri?: StringWithAggregatesFilter | string
    image_canonical_uri?: StringWithAggregatesFilter | string
    contract_id?: StringWithAggregatesFilter | string
    tx_id?: BytesWithAggregatesFilter | Buffer
    sender_address?: StringWithAggregatesFilter | string
  }

  export type pgmigrationsWhereInput = {
    AND?: Enumerable<pgmigrationsWhereInput>
    OR?: Enumerable<pgmigrationsWhereInput>
    NOT?: Enumerable<pgmigrationsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    run_on?: DateTimeFilter | Date | string
  }

  export type pgmigrationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    run_on?: SortOrder
  }

  export type pgmigrationsWhereUniqueInput = {
    id?: number
  }

  export type pgmigrationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    run_on?: SortOrder
    _count?: pgmigrationsCountOrderByAggregateInput
    _avg?: pgmigrationsAvgOrderByAggregateInput
    _max?: pgmigrationsMaxOrderByAggregateInput
    _min?: pgmigrationsMinOrderByAggregateInput
    _sum?: pgmigrationsSumOrderByAggregateInput
  }

  export type pgmigrationsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pgmigrationsScalarWhereWithAggregatesInput>
    OR?: Enumerable<pgmigrationsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pgmigrationsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    run_on?: DateTimeWithAggregatesFilter | Date | string
  }

  export type pox2_eventsWhereInput = {
    AND?: Enumerable<pox2_eventsWhereInput>
    OR?: Enumerable<pox2_eventsWhereInput>
    NOT?: Enumerable<pox2_eventsWhereInput>
    id?: BigIntFilter | bigint | number
    event_index?: IntFilter | number
    tx_id?: BytesFilter | Buffer
    tx_index?: IntFilter | number
    block_height?: IntFilter | number
    index_block_hash?: BytesFilter | Buffer
    parent_index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_canonical?: BoolFilter | boolean
    canonical?: BoolFilter | boolean
    stacker?: StringFilter | string
    locked?: DecimalFilter | Decimal | DecimalJsLike | number | string
    balance?: DecimalFilter | Decimal | DecimalJsLike | number | string
    burnchain_unlock_height?: BigIntFilter | bigint | number
    name?: StringFilter | string
    pox_addr?: StringNullableFilter | string | null
    pox_addr_raw?: BytesNullableFilter | Buffer | null
    first_cycle_locked?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    first_unlocked_cycle?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    lock_period?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    lock_amount?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    start_burn_height?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    unlock_burn_height?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    delegator?: StringNullableFilter | string | null
    increase_by?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    total_locked?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    extend_count?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    reward_cycle?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
    amount_ustx?: DecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type pox2_eventsOrderByWithRelationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    stacker?: SortOrder
    locked?: SortOrder
    balance?: SortOrder
    burnchain_unlock_height?: SortOrder
    name?: SortOrder
    pox_addr?: SortOrder
    pox_addr_raw?: SortOrder
    first_cycle_locked?: SortOrder
    first_unlocked_cycle?: SortOrder
    lock_period?: SortOrder
    lock_amount?: SortOrder
    start_burn_height?: SortOrder
    unlock_burn_height?: SortOrder
    delegator?: SortOrder
    increase_by?: SortOrder
    total_locked?: SortOrder
    extend_count?: SortOrder
    reward_cycle?: SortOrder
    amount_ustx?: SortOrder
  }

  export type pox2_eventsWhereUniqueInput = {
    id?: bigint | number
  }

  export type pox2_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    stacker?: SortOrder
    locked?: SortOrder
    balance?: SortOrder
    burnchain_unlock_height?: SortOrder
    name?: SortOrder
    pox_addr?: SortOrder
    pox_addr_raw?: SortOrder
    first_cycle_locked?: SortOrder
    first_unlocked_cycle?: SortOrder
    lock_period?: SortOrder
    lock_amount?: SortOrder
    start_burn_height?: SortOrder
    unlock_burn_height?: SortOrder
    delegator?: SortOrder
    increase_by?: SortOrder
    total_locked?: SortOrder
    extend_count?: SortOrder
    reward_cycle?: SortOrder
    amount_ustx?: SortOrder
    _count?: pox2_eventsCountOrderByAggregateInput
    _avg?: pox2_eventsAvgOrderByAggregateInput
    _max?: pox2_eventsMaxOrderByAggregateInput
    _min?: pox2_eventsMinOrderByAggregateInput
    _sum?: pox2_eventsSumOrderByAggregateInput
  }

  export type pox2_eventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pox2_eventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<pox2_eventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pox2_eventsScalarWhereWithAggregatesInput>
    id?: BigIntWithAggregatesFilter | bigint | number
    event_index?: IntWithAggregatesFilter | number
    tx_id?: BytesWithAggregatesFilter | Buffer
    tx_index?: IntWithAggregatesFilter | number
    block_height?: IntWithAggregatesFilter | number
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_canonical?: BoolWithAggregatesFilter | boolean
    canonical?: BoolWithAggregatesFilter | boolean
    stacker?: StringWithAggregatesFilter | string
    locked?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    balance?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    burnchain_unlock_height?: BigIntWithAggregatesFilter | bigint | number
    name?: StringWithAggregatesFilter | string
    pox_addr?: StringNullableWithAggregatesFilter | string | null
    pox_addr_raw?: BytesNullableWithAggregatesFilter | Buffer | null
    first_cycle_locked?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    first_unlocked_cycle?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    lock_period?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    lock_amount?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    start_burn_height?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    unlock_burn_height?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    delegator?: StringNullableWithAggregatesFilter | string | null
    increase_by?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    total_locked?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    extend_count?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    reward_cycle?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    amount_ustx?: DecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type pox_stateWhereInput = {
    AND?: Enumerable<pox_stateWhereInput>
    OR?: Enumerable<pox_stateWhereInput>
    NOT?: Enumerable<pox_stateWhereInput>
    id?: BoolFilter | boolean
    pox_v1_unlock_height?: IntFilter | number
  }

  export type pox_stateOrderByWithRelationInput = {
    id?: SortOrder
    pox_v1_unlock_height?: SortOrder
  }

  export type pox_stateWhereUniqueInput = {
    id?: boolean
  }

  export type pox_stateOrderByWithAggregationInput = {
    id?: SortOrder
    pox_v1_unlock_height?: SortOrder
    _count?: pox_stateCountOrderByAggregateInput
    _avg?: pox_stateAvgOrderByAggregateInput
    _max?: pox_stateMaxOrderByAggregateInput
    _min?: pox_stateMinOrderByAggregateInput
    _sum?: pox_stateSumOrderByAggregateInput
  }

  export type pox_stateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<pox_stateScalarWhereWithAggregatesInput>
    OR?: Enumerable<pox_stateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<pox_stateScalarWhereWithAggregatesInput>
    id?: BoolWithAggregatesFilter | boolean
    pox_v1_unlock_height?: IntWithAggregatesFilter | number
  }

  export type principal_stx_txsWhereInput = {
    AND?: Enumerable<principal_stx_txsWhereInput>
    OR?: Enumerable<principal_stx_txsWhereInput>
    NOT?: Enumerable<principal_stx_txsWhereInput>
    id?: IntFilter | number
    principal?: StringFilter | string
    tx_id?: BytesFilter | Buffer
    block_height?: IntFilter | number
    index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    tx_index?: IntFilter | number
    canonical?: BoolFilter | boolean
    microblock_canonical?: BoolFilter | boolean
  }

  export type principal_stx_txsOrderByWithRelationInput = {
    id?: SortOrder
    principal?: SortOrder
    tx_id?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    tx_index?: SortOrder
    canonical?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type principal_stx_txsWhereUniqueInput = {
    id?: number
    principal_tx_id_index_block_hash_microblock_hash?: principal_stx_txsPrincipalTx_idIndex_block_hashMicroblock_hashCompoundUniqueInput
  }

  export type principal_stx_txsOrderByWithAggregationInput = {
    id?: SortOrder
    principal?: SortOrder
    tx_id?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    tx_index?: SortOrder
    canonical?: SortOrder
    microblock_canonical?: SortOrder
    _count?: principal_stx_txsCountOrderByAggregateInput
    _avg?: principal_stx_txsAvgOrderByAggregateInput
    _max?: principal_stx_txsMaxOrderByAggregateInput
    _min?: principal_stx_txsMinOrderByAggregateInput
    _sum?: principal_stx_txsSumOrderByAggregateInput
  }

  export type principal_stx_txsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<principal_stx_txsScalarWhereWithAggregatesInput>
    OR?: Enumerable<principal_stx_txsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<principal_stx_txsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    principal?: StringWithAggregatesFilter | string
    tx_id?: BytesWithAggregatesFilter | Buffer
    block_height?: IntWithAggregatesFilter | number
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    tx_index?: IntWithAggregatesFilter | number
    canonical?: BoolWithAggregatesFilter | boolean
    microblock_canonical?: BoolWithAggregatesFilter | boolean
  }

  export type reward_slot_holdersWhereInput = {
    AND?: Enumerable<reward_slot_holdersWhereInput>
    OR?: Enumerable<reward_slot_holdersWhereInput>
    NOT?: Enumerable<reward_slot_holdersWhereInput>
    id?: IntFilter | number
    canonical?: BoolFilter | boolean
    burn_block_hash?: BytesFilter | Buffer
    burn_block_height?: IntFilter | number
    address?: StringFilter | string
    slot_index?: IntFilter | number
  }

  export type reward_slot_holdersOrderByWithRelationInput = {
    id?: SortOrder
    canonical?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    address?: SortOrder
    slot_index?: SortOrder
  }

  export type reward_slot_holdersWhereUniqueInput = {
    id?: number
  }

  export type reward_slot_holdersOrderByWithAggregationInput = {
    id?: SortOrder
    canonical?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    address?: SortOrder
    slot_index?: SortOrder
    _count?: reward_slot_holdersCountOrderByAggregateInput
    _avg?: reward_slot_holdersAvgOrderByAggregateInput
    _max?: reward_slot_holdersMaxOrderByAggregateInput
    _min?: reward_slot_holdersMinOrderByAggregateInput
    _sum?: reward_slot_holdersSumOrderByAggregateInput
  }

  export type reward_slot_holdersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reward_slot_holdersScalarWhereWithAggregatesInput>
    OR?: Enumerable<reward_slot_holdersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reward_slot_holdersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    canonical?: BoolWithAggregatesFilter | boolean
    burn_block_hash?: BytesWithAggregatesFilter | Buffer
    burn_block_height?: IntWithAggregatesFilter | number
    address?: StringWithAggregatesFilter | string
    slot_index?: IntWithAggregatesFilter | number
  }

  export type smart_contractsWhereInput = {
    AND?: Enumerable<smart_contractsWhereInput>
    OR?: Enumerable<smart_contractsWhereInput>
    NOT?: Enumerable<smart_contractsWhereInput>
    id?: IntFilter | number
    tx_id?: BytesFilter | Buffer
    canonical?: BoolFilter | boolean
    contract_id?: StringFilter | string
    block_height?: IntFilter | number
    index_block_hash?: BytesFilter | Buffer
    parent_index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_canonical?: BoolFilter | boolean
    clarity_version?: IntNullableFilter | number | null
    source_code?: StringFilter | string
    abi?: JsonFilter
  }

  export type smart_contractsOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    canonical?: SortOrder
    contract_id?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    clarity_version?: SortOrder
    source_code?: SortOrder
    abi?: SortOrder
  }

  export type smart_contractsWhereUniqueInput = {
    id?: number
  }

  export type smart_contractsOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    canonical?: SortOrder
    contract_id?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    clarity_version?: SortOrder
    source_code?: SortOrder
    abi?: SortOrder
    _count?: smart_contractsCountOrderByAggregateInput
    _avg?: smart_contractsAvgOrderByAggregateInput
    _max?: smart_contractsMaxOrderByAggregateInput
    _min?: smart_contractsMinOrderByAggregateInput
    _sum?: smart_contractsSumOrderByAggregateInput
  }

  export type smart_contractsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<smart_contractsScalarWhereWithAggregatesInput>
    OR?: Enumerable<smart_contractsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<smart_contractsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    tx_id?: BytesWithAggregatesFilter | Buffer
    canonical?: BoolWithAggregatesFilter | boolean
    contract_id?: StringWithAggregatesFilter | string
    block_height?: IntWithAggregatesFilter | number
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_canonical?: BoolWithAggregatesFilter | boolean
    clarity_version?: IntNullableWithAggregatesFilter | number | null
    source_code?: StringWithAggregatesFilter | string
    abi?: JsonWithAggregatesFilter
  }

  export type stx_eventsWhereInput = {
    AND?: Enumerable<stx_eventsWhereInput>
    OR?: Enumerable<stx_eventsWhereInput>
    NOT?: Enumerable<stx_eventsWhereInput>
    id?: IntFilter | number
    event_index?: IntFilter | number
    tx_id?: BytesFilter | Buffer
    tx_index?: IntFilter | number
    block_height?: IntFilter | number
    index_block_hash?: BytesFilter | Buffer
    parent_index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_canonical?: BoolFilter | boolean
    canonical?: BoolFilter | boolean
    asset_event_type_id?: IntFilter | number
    amount?: BigIntFilter | bigint | number
    sender?: StringNullableFilter | string | null
    recipient?: StringNullableFilter | string | null
    memo?: BytesNullableFilter | Buffer | null
  }

  export type stx_eventsOrderByWithRelationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    amount?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    memo?: SortOrder
  }

  export type stx_eventsWhereUniqueInput = {
    id?: number
  }

  export type stx_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    amount?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    memo?: SortOrder
    _count?: stx_eventsCountOrderByAggregateInput
    _avg?: stx_eventsAvgOrderByAggregateInput
    _max?: stx_eventsMaxOrderByAggregateInput
    _min?: stx_eventsMinOrderByAggregateInput
    _sum?: stx_eventsSumOrderByAggregateInput
  }

  export type stx_eventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<stx_eventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<stx_eventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<stx_eventsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    event_index?: IntWithAggregatesFilter | number
    tx_id?: BytesWithAggregatesFilter | Buffer
    tx_index?: IntWithAggregatesFilter | number
    block_height?: IntWithAggregatesFilter | number
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_canonical?: BoolWithAggregatesFilter | boolean
    canonical?: BoolWithAggregatesFilter | boolean
    asset_event_type_id?: IntWithAggregatesFilter | number
    amount?: BigIntWithAggregatesFilter | bigint | number
    sender?: StringNullableWithAggregatesFilter | string | null
    recipient?: StringNullableWithAggregatesFilter | string | null
    memo?: BytesNullableWithAggregatesFilter | Buffer | null
  }

  export type stx_lock_eventsWhereInput = {
    AND?: Enumerable<stx_lock_eventsWhereInput>
    OR?: Enumerable<stx_lock_eventsWhereInput>
    NOT?: Enumerable<stx_lock_eventsWhereInput>
    id?: IntFilter | number
    event_index?: IntFilter | number
    tx_id?: BytesFilter | Buffer
    tx_index?: IntFilter | number
    block_height?: IntFilter | number
    index_block_hash?: BytesFilter | Buffer
    parent_index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_canonical?: BoolFilter | boolean
    canonical?: BoolFilter | boolean
    locked_amount?: DecimalFilter | Decimal | DecimalJsLike | number | string
    unlock_height?: IntFilter | number
    locked_address?: StringFilter | string
    contract_name?: StringFilter | string
  }

  export type stx_lock_eventsOrderByWithRelationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    locked_amount?: SortOrder
    unlock_height?: SortOrder
    locked_address?: SortOrder
    contract_name?: SortOrder
  }

  export type stx_lock_eventsWhereUniqueInput = {
    id?: number
  }

  export type stx_lock_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    locked_amount?: SortOrder
    unlock_height?: SortOrder
    locked_address?: SortOrder
    contract_name?: SortOrder
    _count?: stx_lock_eventsCountOrderByAggregateInput
    _avg?: stx_lock_eventsAvgOrderByAggregateInput
    _max?: stx_lock_eventsMaxOrderByAggregateInput
    _min?: stx_lock_eventsMinOrderByAggregateInput
    _sum?: stx_lock_eventsSumOrderByAggregateInput
  }

  export type stx_lock_eventsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<stx_lock_eventsScalarWhereWithAggregatesInput>
    OR?: Enumerable<stx_lock_eventsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<stx_lock_eventsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    event_index?: IntWithAggregatesFilter | number
    tx_id?: BytesWithAggregatesFilter | Buffer
    tx_index?: IntWithAggregatesFilter | number
    block_height?: IntWithAggregatesFilter | number
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_canonical?: BoolWithAggregatesFilter | boolean
    canonical?: BoolWithAggregatesFilter | boolean
    locked_amount?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    unlock_height?: IntWithAggregatesFilter | number
    locked_address?: StringWithAggregatesFilter | string
    contract_name?: StringWithAggregatesFilter | string
  }

  export type subdomainsWhereInput = {
    AND?: Enumerable<subdomainsWhereInput>
    OR?: Enumerable<subdomainsWhereInput>
    NOT?: Enumerable<subdomainsWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    namespace_id?: StringFilter | string
    fully_qualified_subdomain?: StringFilter | string
    owner?: StringFilter | string
    zonefile_hash?: StringFilter | string
    parent_zonefile_hash?: StringFilter | string
    parent_zonefile_index?: IntFilter | number
    tx_index?: IntFilter | number
    block_height?: IntFilter | number
    zonefile_offset?: IntNullableFilter | number | null
    resolver?: StringNullableFilter | string | null
    tx_id?: BytesNullableFilter | Buffer | null
    canonical?: BoolFilter | boolean
    index_block_hash?: BytesNullableFilter | Buffer | null
    parent_index_block_hash?: BytesFilter | Buffer
    microblock_hash?: BytesFilter | Buffer
    microblock_sequence?: IntFilter | number
    microblock_canonical?: BoolFilter | boolean
  }

  export type subdomainsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    namespace_id?: SortOrder
    fully_qualified_subdomain?: SortOrder
    owner?: SortOrder
    zonefile_hash?: SortOrder
    parent_zonefile_hash?: SortOrder
    parent_zonefile_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    zonefile_offset?: SortOrder
    resolver?: SortOrder
    tx_id?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type subdomainsWhereUniqueInput = {
    id?: number
    fully_qualified_subdomain_tx_id_index_block_hash_microblock_hash?: subdomainsFully_qualified_subdomainTx_idIndex_block_hashMicroblock_hashCompoundUniqueInput
  }

  export type subdomainsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    namespace_id?: SortOrder
    fully_qualified_subdomain?: SortOrder
    owner?: SortOrder
    zonefile_hash?: SortOrder
    parent_zonefile_hash?: SortOrder
    parent_zonefile_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    zonefile_offset?: SortOrder
    resolver?: SortOrder
    tx_id?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    _count?: subdomainsCountOrderByAggregateInput
    _avg?: subdomainsAvgOrderByAggregateInput
    _max?: subdomainsMaxOrderByAggregateInput
    _min?: subdomainsMinOrderByAggregateInput
    _sum?: subdomainsSumOrderByAggregateInput
  }

  export type subdomainsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subdomainsScalarWhereWithAggregatesInput>
    OR?: Enumerable<subdomainsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subdomainsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    namespace_id?: StringWithAggregatesFilter | string
    fully_qualified_subdomain?: StringWithAggregatesFilter | string
    owner?: StringWithAggregatesFilter | string
    zonefile_hash?: StringWithAggregatesFilter | string
    parent_zonefile_hash?: StringWithAggregatesFilter | string
    parent_zonefile_index?: IntWithAggregatesFilter | number
    tx_index?: IntWithAggregatesFilter | number
    block_height?: IntWithAggregatesFilter | number
    zonefile_offset?: IntNullableWithAggregatesFilter | number | null
    resolver?: StringNullableWithAggregatesFilter | string | null
    tx_id?: BytesNullableWithAggregatesFilter | Buffer | null
    canonical?: BoolWithAggregatesFilter | boolean
    index_block_hash?: BytesNullableWithAggregatesFilter | Buffer | null
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_canonical?: BoolWithAggregatesFilter | boolean
  }

  export type token_metadata_queueWhereInput = {
    AND?: Enumerable<token_metadata_queueWhereInput>
    OR?: Enumerable<token_metadata_queueWhereInput>
    NOT?: Enumerable<token_metadata_queueWhereInput>
    queue_id?: IntFilter | number
    tx_id?: BytesFilter | Buffer
    contract_id?: StringFilter | string
    contract_abi?: StringFilter | string
    block_height?: IntFilter | number
    processed?: BoolFilter | boolean
    retry_count?: IntFilter | number
  }

  export type token_metadata_queueOrderByWithRelationInput = {
    queue_id?: SortOrder
    tx_id?: SortOrder
    contract_id?: SortOrder
    contract_abi?: SortOrder
    block_height?: SortOrder
    processed?: SortOrder
    retry_count?: SortOrder
  }

  export type token_metadata_queueWhereUniqueInput = {
    queue_id?: number
  }

  export type token_metadata_queueOrderByWithAggregationInput = {
    queue_id?: SortOrder
    tx_id?: SortOrder
    contract_id?: SortOrder
    contract_abi?: SortOrder
    block_height?: SortOrder
    processed?: SortOrder
    retry_count?: SortOrder
    _count?: token_metadata_queueCountOrderByAggregateInput
    _avg?: token_metadata_queueAvgOrderByAggregateInput
    _max?: token_metadata_queueMaxOrderByAggregateInput
    _min?: token_metadata_queueMinOrderByAggregateInput
    _sum?: token_metadata_queueSumOrderByAggregateInput
  }

  export type token_metadata_queueScalarWhereWithAggregatesInput = {
    AND?: Enumerable<token_metadata_queueScalarWhereWithAggregatesInput>
    OR?: Enumerable<token_metadata_queueScalarWhereWithAggregatesInput>
    NOT?: Enumerable<token_metadata_queueScalarWhereWithAggregatesInput>
    queue_id?: IntWithAggregatesFilter | number
    tx_id?: BytesWithAggregatesFilter | Buffer
    contract_id?: StringWithAggregatesFilter | string
    contract_abi?: StringWithAggregatesFilter | string
    block_height?: IntWithAggregatesFilter | number
    processed?: BoolWithAggregatesFilter | boolean
    retry_count?: IntWithAggregatesFilter | number
  }

  export type token_offering_lockedWhereInput = {
    AND?: Enumerable<token_offering_lockedWhereInput>
    OR?: Enumerable<token_offering_lockedWhereInput>
    NOT?: Enumerable<token_offering_lockedWhereInput>
    id?: IntFilter | number
    address?: StringFilter | string
    value?: BigIntFilter | bigint | number
    block?: IntFilter | number
  }

  export type token_offering_lockedOrderByWithRelationInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    block?: SortOrder
  }

  export type token_offering_lockedWhereUniqueInput = {
    id?: number
  }

  export type token_offering_lockedOrderByWithAggregationInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    block?: SortOrder
    _count?: token_offering_lockedCountOrderByAggregateInput
    _avg?: token_offering_lockedAvgOrderByAggregateInput
    _max?: token_offering_lockedMaxOrderByAggregateInput
    _min?: token_offering_lockedMinOrderByAggregateInput
    _sum?: token_offering_lockedSumOrderByAggregateInput
  }

  export type token_offering_lockedScalarWhereWithAggregatesInput = {
    AND?: Enumerable<token_offering_lockedScalarWhereWithAggregatesInput>
    OR?: Enumerable<token_offering_lockedScalarWhereWithAggregatesInput>
    NOT?: Enumerable<token_offering_lockedScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    address?: StringWithAggregatesFilter | string
    value?: BigIntWithAggregatesFilter | bigint | number
    block?: IntWithAggregatesFilter | number
  }

  export type txsWhereInput = {
    AND?: Enumerable<txsWhereInput>
    OR?: Enumerable<txsWhereInput>
    NOT?: Enumerable<txsWhereInput>
    id?: IntFilter | number
    tx_id?: BytesFilter | Buffer
    tx_index?: IntFilter | number
    raw_result?: BytesFilter | Buffer
    index_block_hash?: BytesFilter | Buffer
    block_hash?: BytesFilter | Buffer
    block_height?: IntFilter | number
    parent_block_hash?: BytesFilter | Buffer
    burn_block_time?: IntFilter | number
    parent_burn_block_time?: IntFilter | number
    type_id?: IntFilter | number
    anchor_mode?: IntFilter | number
    status?: IntFilter | number
    canonical?: BoolFilter | boolean
    post_conditions?: BytesFilter | Buffer
    nonce?: IntFilter | number
    fee_rate?: BigIntFilter | bigint | number
    sponsored?: BoolFilter | boolean
    sponsor_address?: StringNullableFilter | string | null
    sponsor_nonce?: IntNullableFilter | number | null
    sender_address?: StringFilter | string
    origin_hash_mode?: IntFilter | number
    event_count?: IntFilter | number
    execution_cost_read_count?: BigIntFilter | bigint | number
    execution_cost_read_length?: BigIntFilter | bigint | number
    execution_cost_runtime?: BigIntFilter | bigint | number
    execution_cost_write_count?: BigIntFilter | bigint | number
    execution_cost_write_length?: BigIntFilter | bigint | number
    raw_tx?: BytesFilter | Buffer
    microblock_canonical?: BoolFilter | boolean
    microblock_sequence?: IntFilter | number
    microblock_hash?: BytesFilter | Buffer
    parent_index_block_hash?: BytesFilter | Buffer
    token_transfer_recipient_address?: StringNullableFilter | string | null
    token_transfer_amount?: BigIntNullableFilter | bigint | number | null
    token_transfer_memo?: BytesNullableFilter | Buffer | null
    smart_contract_clarity_version?: IntNullableFilter | number | null
    smart_contract_contract_id?: StringNullableFilter | string | null
    smart_contract_source_code?: StringNullableFilter | string | null
    contract_call_contract_id?: StringNullableFilter | string | null
    contract_call_function_name?: StringNullableFilter | string | null
    contract_call_function_args?: BytesNullableFilter | Buffer | null
    poison_microblock_header_1?: BytesNullableFilter | Buffer | null
    poison_microblock_header_2?: BytesNullableFilter | Buffer | null
    coinbase_payload?: BytesNullableFilter | Buffer | null
    coinbase_alt_recipient?: StringNullableFilter | string | null
  }

  export type txsOrderByWithRelationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    raw_result?: SortOrder
    index_block_hash?: SortOrder
    block_hash?: SortOrder
    block_height?: SortOrder
    parent_block_hash?: SortOrder
    burn_block_time?: SortOrder
    parent_burn_block_time?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    canonical?: SortOrder
    post_conditions?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsored?: SortOrder
    sponsor_address?: SortOrder
    sponsor_nonce?: SortOrder
    sender_address?: SortOrder
    origin_hash_mode?: SortOrder
    event_count?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
    raw_tx?: SortOrder
    microblock_canonical?: SortOrder
    microblock_sequence?: SortOrder
    microblock_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    token_transfer_recipient_address?: SortOrder
    token_transfer_amount?: SortOrder
    token_transfer_memo?: SortOrder
    smart_contract_clarity_version?: SortOrder
    smart_contract_contract_id?: SortOrder
    smart_contract_source_code?: SortOrder
    contract_call_contract_id?: SortOrder
    contract_call_function_name?: SortOrder
    contract_call_function_args?: SortOrder
    poison_microblock_header_1?: SortOrder
    poison_microblock_header_2?: SortOrder
    coinbase_payload?: SortOrder
    coinbase_alt_recipient?: SortOrder
  }

  export type txsWhereUniqueInput = {
    id?: number
    tx_id_index_block_hash_microblock_hash?: txsTx_idIndex_block_hashMicroblock_hashCompoundUniqueInput
  }

  export type txsOrderByWithAggregationInput = {
    id?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    raw_result?: SortOrder
    index_block_hash?: SortOrder
    block_hash?: SortOrder
    block_height?: SortOrder
    parent_block_hash?: SortOrder
    burn_block_time?: SortOrder
    parent_burn_block_time?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    canonical?: SortOrder
    post_conditions?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsored?: SortOrder
    sponsor_address?: SortOrder
    sponsor_nonce?: SortOrder
    sender_address?: SortOrder
    origin_hash_mode?: SortOrder
    event_count?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
    raw_tx?: SortOrder
    microblock_canonical?: SortOrder
    microblock_sequence?: SortOrder
    microblock_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    token_transfer_recipient_address?: SortOrder
    token_transfer_amount?: SortOrder
    token_transfer_memo?: SortOrder
    smart_contract_clarity_version?: SortOrder
    smart_contract_contract_id?: SortOrder
    smart_contract_source_code?: SortOrder
    contract_call_contract_id?: SortOrder
    contract_call_function_name?: SortOrder
    contract_call_function_args?: SortOrder
    poison_microblock_header_1?: SortOrder
    poison_microblock_header_2?: SortOrder
    coinbase_payload?: SortOrder
    coinbase_alt_recipient?: SortOrder
    _count?: txsCountOrderByAggregateInput
    _avg?: txsAvgOrderByAggregateInput
    _max?: txsMaxOrderByAggregateInput
    _min?: txsMinOrderByAggregateInput
    _sum?: txsSumOrderByAggregateInput
  }

  export type txsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<txsScalarWhereWithAggregatesInput>
    OR?: Enumerable<txsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<txsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    tx_id?: BytesWithAggregatesFilter | Buffer
    tx_index?: IntWithAggregatesFilter | number
    raw_result?: BytesWithAggregatesFilter | Buffer
    index_block_hash?: BytesWithAggregatesFilter | Buffer
    block_hash?: BytesWithAggregatesFilter | Buffer
    block_height?: IntWithAggregatesFilter | number
    parent_block_hash?: BytesWithAggregatesFilter | Buffer
    burn_block_time?: IntWithAggregatesFilter | number
    parent_burn_block_time?: IntWithAggregatesFilter | number
    type_id?: IntWithAggregatesFilter | number
    anchor_mode?: IntWithAggregatesFilter | number
    status?: IntWithAggregatesFilter | number
    canonical?: BoolWithAggregatesFilter | boolean
    post_conditions?: BytesWithAggregatesFilter | Buffer
    nonce?: IntWithAggregatesFilter | number
    fee_rate?: BigIntWithAggregatesFilter | bigint | number
    sponsored?: BoolWithAggregatesFilter | boolean
    sponsor_address?: StringNullableWithAggregatesFilter | string | null
    sponsor_nonce?: IntNullableWithAggregatesFilter | number | null
    sender_address?: StringWithAggregatesFilter | string
    origin_hash_mode?: IntWithAggregatesFilter | number
    event_count?: IntWithAggregatesFilter | number
    execution_cost_read_count?: BigIntWithAggregatesFilter | bigint | number
    execution_cost_read_length?: BigIntWithAggregatesFilter | bigint | number
    execution_cost_runtime?: BigIntWithAggregatesFilter | bigint | number
    execution_cost_write_count?: BigIntWithAggregatesFilter | bigint | number
    execution_cost_write_length?: BigIntWithAggregatesFilter | bigint | number
    raw_tx?: BytesWithAggregatesFilter | Buffer
    microblock_canonical?: BoolWithAggregatesFilter | boolean
    microblock_sequence?: IntWithAggregatesFilter | number
    microblock_hash?: BytesWithAggregatesFilter | Buffer
    parent_index_block_hash?: BytesWithAggregatesFilter | Buffer
    token_transfer_recipient_address?: StringNullableWithAggregatesFilter | string | null
    token_transfer_amount?: BigIntNullableWithAggregatesFilter | bigint | number | null
    token_transfer_memo?: BytesNullableWithAggregatesFilter | Buffer | null
    smart_contract_clarity_version?: IntNullableWithAggregatesFilter | number | null
    smart_contract_contract_id?: StringNullableWithAggregatesFilter | string | null
    smart_contract_source_code?: StringNullableWithAggregatesFilter | string | null
    contract_call_contract_id?: StringNullableWithAggregatesFilter | string | null
    contract_call_function_name?: StringNullableWithAggregatesFilter | string | null
    contract_call_function_args?: BytesNullableWithAggregatesFilter | Buffer | null
    poison_microblock_header_1?: BytesNullableWithAggregatesFilter | Buffer | null
    poison_microblock_header_2?: BytesNullableWithAggregatesFilter | Buffer | null
    coinbase_payload?: BytesNullableWithAggregatesFilter | Buffer | null
    coinbase_alt_recipient?: StringNullableWithAggregatesFilter | string | null
  }

  export type zonefilesWhereInput = {
    AND?: Enumerable<zonefilesWhereInput>
    OR?: Enumerable<zonefilesWhereInput>
    NOT?: Enumerable<zonefilesWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    zonefile?: StringFilter | string
    zonefile_hash?: StringFilter | string
    tx_id?: BytesNullableFilter | Buffer | null
    index_block_hash?: BytesNullableFilter | Buffer | null
  }

  export type zonefilesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    zonefile?: SortOrder
    zonefile_hash?: SortOrder
    tx_id?: SortOrder
    index_block_hash?: SortOrder
  }

  export type zonefilesWhereUniqueInput = {
    id?: number
    name_zonefile_hash_tx_id_index_block_hash?: zonefilesNameZonefile_hashTx_idIndex_block_hashCompoundUniqueInput
  }

  export type zonefilesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    zonefile?: SortOrder
    zonefile_hash?: SortOrder
    tx_id?: SortOrder
    index_block_hash?: SortOrder
    _count?: zonefilesCountOrderByAggregateInput
    _avg?: zonefilesAvgOrderByAggregateInput
    _max?: zonefilesMaxOrderByAggregateInput
    _min?: zonefilesMinOrderByAggregateInput
    _sum?: zonefilesSumOrderByAggregateInput
  }

  export type zonefilesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<zonefilesScalarWhereWithAggregatesInput>
    OR?: Enumerable<zonefilesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<zonefilesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    zonefile?: StringWithAggregatesFilter | string
    zonefile_hash?: StringWithAggregatesFilter | string
    tx_id?: BytesNullableWithAggregatesFilter | Buffer | null
    index_block_hash?: BytesNullableWithAggregatesFilter | Buffer | null
  }

  export type blocksCreateInput = {
    index_block_hash: Buffer
    block_hash: Buffer
    block_height: number
    burn_block_time: number
    burn_block_hash: Buffer
    burn_block_height: number
    miner_txid: Buffer
    parent_index_block_hash: Buffer
    parent_block_hash: Buffer
    parent_microblock_hash: Buffer
    parent_microblock_sequence: number
    canonical: boolean
    execution_cost_read_count: bigint | number
    execution_cost_read_length: bigint | number
    execution_cost_runtime: bigint | number
    execution_cost_write_count: bigint | number
    execution_cost_write_length: bigint | number
  }

  export type blocksUncheckedCreateInput = {
    index_block_hash: Buffer
    block_hash: Buffer
    block_height: number
    burn_block_time: number
    burn_block_hash: Buffer
    burn_block_height: number
    miner_txid: Buffer
    parent_index_block_hash: Buffer
    parent_block_hash: Buffer
    parent_microblock_hash: Buffer
    parent_microblock_sequence: number
    canonical: boolean
    execution_cost_read_count: bigint | number
    execution_cost_read_length: bigint | number
    execution_cost_runtime: bigint | number
    execution_cost_write_count: bigint | number
    execution_cost_write_length: bigint | number
  }

  export type blocksUpdateInput = {
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    burn_block_time?: IntFieldUpdateOperationsInput | number
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    miner_txid?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_microblock_sequence?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    execution_cost_read_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_read_length?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_runtime?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_length?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type blocksUncheckedUpdateInput = {
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    burn_block_time?: IntFieldUpdateOperationsInput | number
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    miner_txid?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_microblock_sequence?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    execution_cost_read_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_read_length?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_runtime?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_length?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type blocksCreateManyInput = {
    index_block_hash: Buffer
    block_hash: Buffer
    block_height: number
    burn_block_time: number
    burn_block_hash: Buffer
    burn_block_height: number
    miner_txid: Buffer
    parent_index_block_hash: Buffer
    parent_block_hash: Buffer
    parent_microblock_hash: Buffer
    parent_microblock_sequence: number
    canonical: boolean
    execution_cost_read_count: bigint | number
    execution_cost_read_length: bigint | number
    execution_cost_runtime: bigint | number
    execution_cost_write_count: bigint | number
    execution_cost_write_length: bigint | number
  }

  export type blocksUpdateManyMutationInput = {
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    burn_block_time?: IntFieldUpdateOperationsInput | number
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    miner_txid?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_microblock_sequence?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    execution_cost_read_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_read_length?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_runtime?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_length?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type blocksUncheckedUpdateManyInput = {
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    burn_block_time?: IntFieldUpdateOperationsInput | number
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    miner_txid?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_microblock_sequence?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    execution_cost_read_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_read_length?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_runtime?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_length?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type burnchain_rewardsCreateInput = {
    canonical: boolean
    burn_block_hash: Buffer
    burn_block_height: number
    burn_amount: Decimal | DecimalJsLike | number | string
    reward_recipient: string
    reward_amount: Decimal | DecimalJsLike | number | string
    reward_index: number
  }

  export type burnchain_rewardsUncheckedCreateInput = {
    id?: number
    canonical: boolean
    burn_block_hash: Buffer
    burn_block_height: number
    burn_amount: Decimal | DecimalJsLike | number | string
    reward_recipient: string
    reward_amount: Decimal | DecimalJsLike | number | string
    reward_index: number
  }

  export type burnchain_rewardsUpdateInput = {
    canonical?: BoolFieldUpdateOperationsInput | boolean
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    burn_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reward_recipient?: StringFieldUpdateOperationsInput | string
    reward_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reward_index?: IntFieldUpdateOperationsInput | number
  }

  export type burnchain_rewardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    burn_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reward_recipient?: StringFieldUpdateOperationsInput | string
    reward_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reward_index?: IntFieldUpdateOperationsInput | number
  }

  export type burnchain_rewardsCreateManyInput = {
    id?: number
    canonical: boolean
    burn_block_hash: Buffer
    burn_block_height: number
    burn_amount: Decimal | DecimalJsLike | number | string
    reward_recipient: string
    reward_amount: Decimal | DecimalJsLike | number | string
    reward_index: number
  }

  export type burnchain_rewardsUpdateManyMutationInput = {
    canonical?: BoolFieldUpdateOperationsInput | boolean
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    burn_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reward_recipient?: StringFieldUpdateOperationsInput | string
    reward_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reward_index?: IntFieldUpdateOperationsInput | number
  }

  export type burnchain_rewardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    burn_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reward_recipient?: StringFieldUpdateOperationsInput | string
    reward_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reward_index?: IntFieldUpdateOperationsInput | number
  }

  export type config_stateCreateInput = {
    id?: boolean
    bns_names_onchain_imported?: boolean
    bns_subdomains_imported?: boolean
    token_offering_imported?: boolean
  }

  export type config_stateUncheckedCreateInput = {
    id?: boolean
    bns_names_onchain_imported?: boolean
    bns_subdomains_imported?: boolean
    token_offering_imported?: boolean
  }

  export type config_stateUpdateInput = {
    id?: BoolFieldUpdateOperationsInput | boolean
    bns_names_onchain_imported?: BoolFieldUpdateOperationsInput | boolean
    bns_subdomains_imported?: BoolFieldUpdateOperationsInput | boolean
    token_offering_imported?: BoolFieldUpdateOperationsInput | boolean
  }

  export type config_stateUncheckedUpdateInput = {
    id?: BoolFieldUpdateOperationsInput | boolean
    bns_names_onchain_imported?: BoolFieldUpdateOperationsInput | boolean
    bns_subdomains_imported?: BoolFieldUpdateOperationsInput | boolean
    token_offering_imported?: BoolFieldUpdateOperationsInput | boolean
  }

  export type config_stateCreateManyInput = {
    id?: boolean
    bns_names_onchain_imported?: boolean
    bns_subdomains_imported?: boolean
    token_offering_imported?: boolean
  }

  export type config_stateUpdateManyMutationInput = {
    id?: BoolFieldUpdateOperationsInput | boolean
    bns_names_onchain_imported?: BoolFieldUpdateOperationsInput | boolean
    bns_subdomains_imported?: BoolFieldUpdateOperationsInput | boolean
    token_offering_imported?: BoolFieldUpdateOperationsInput | boolean
  }

  export type config_stateUncheckedUpdateManyInput = {
    id?: BoolFieldUpdateOperationsInput | boolean
    bns_names_onchain_imported?: BoolFieldUpdateOperationsInput | boolean
    bns_subdomains_imported?: BoolFieldUpdateOperationsInput | boolean
    token_offering_imported?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContractLogsCreateInput = {
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    contract_identifier: string
    topic: string
    value: Buffer
  }

  export type ContractLogsUncheckedCreateInput = {
    id?: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    contract_identifier: string
    topic: string
    value: Buffer
  }

  export type ContractLogsUpdateInput = {
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    contract_identifier?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    value?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type ContractLogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    contract_identifier?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    value?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type ContractLogsCreateManyInput = {
    id?: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    contract_identifier: string
    topic: string
    value: Buffer
  }

  export type ContractLogsUpdateManyMutationInput = {
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    contract_identifier?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    value?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type ContractLogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    contract_identifier?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    value?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type event_observer_requestsCreateInput = {
    id?: bigint | number
    receive_timestamp?: Date | string
    event_path: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type event_observer_requestsUncheckedCreateInput = {
    id?: bigint | number
    receive_timestamp?: Date | string
    event_path: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type event_observer_requestsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    receive_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_path?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type event_observer_requestsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    receive_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_path?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type event_observer_requestsCreateManyInput = {
    id?: bigint | number
    receive_timestamp?: Date | string
    event_path: string
    payload: JsonNullValueInput | InputJsonValue
  }

  export type event_observer_requestsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    receive_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_path?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type event_observer_requestsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    receive_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    event_path?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
  }

  export type faucet_requestsCreateInput = {
    currency: string
    address: string
    ip: string
    occurred_at: bigint | number
  }

  export type faucet_requestsUncheckedCreateInput = {
    id?: number
    currency: string
    address: string
    ip: string
    occurred_at: bigint | number
  }

  export type faucet_requestsUpdateInput = {
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    occurred_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type faucet_requestsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    occurred_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type faucet_requestsCreateManyInput = {
    id?: number
    currency: string
    address: string
    ip: string
    occurred_at: bigint | number
  }

  export type faucet_requestsUpdateManyMutationInput = {
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    occurred_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type faucet_requestsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    ip?: StringFieldUpdateOperationsInput | string
    occurred_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ft_eventsCreateInput = {
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    asset_identifier: string
    amount: Decimal | DecimalJsLike | number | string
    sender?: string | null
    recipient?: string | null
  }

  export type ft_eventsUncheckedCreateInput = {
    id?: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    asset_identifier: string
    amount: Decimal | DecimalJsLike | number | string
    sender?: string | null
    recipient?: string | null
  }

  export type ft_eventsUpdateInput = {
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    asset_identifier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ft_eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    asset_identifier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ft_eventsCreateManyInput = {
    id?: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    asset_identifier: string
    amount: Decimal | DecimalJsLike | number | string
    sender?: string | null
    recipient?: string | null
  }

  export type ft_eventsUpdateManyMutationInput = {
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    asset_identifier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ft_eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    asset_identifier?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ft_metadataCreateInput = {
    name: string
    token_uri: string
    description: string
    image_uri: string
    image_canonical_uri: string
    contract_id: string
    symbol: string
    decimals: number
    tx_id: Buffer
    sender_address: string
  }

  export type ft_metadataUncheckedCreateInput = {
    id?: number
    name: string
    token_uri: string
    description: string
    image_uri: string
    image_canonical_uri: string
    contract_id: string
    symbol: string
    decimals: number
    tx_id: Buffer
    sender_address: string
  }

  export type ft_metadataUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    token_uri?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_uri?: StringFieldUpdateOperationsInput | string
    image_canonical_uri?: StringFieldUpdateOperationsInput | string
    contract_id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    sender_address?: StringFieldUpdateOperationsInput | string
  }

  export type ft_metadataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    token_uri?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_uri?: StringFieldUpdateOperationsInput | string
    image_canonical_uri?: StringFieldUpdateOperationsInput | string
    contract_id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    sender_address?: StringFieldUpdateOperationsInput | string
  }

  export type ft_metadataCreateManyInput = {
    id?: number
    name: string
    token_uri: string
    description: string
    image_uri: string
    image_canonical_uri: string
    contract_id: string
    symbol: string
    decimals: number
    tx_id: Buffer
    sender_address: string
  }

  export type ft_metadataUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    token_uri?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_uri?: StringFieldUpdateOperationsInput | string
    image_canonical_uri?: StringFieldUpdateOperationsInput | string
    contract_id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    sender_address?: StringFieldUpdateOperationsInput | string
  }

  export type ft_metadataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    token_uri?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_uri?: StringFieldUpdateOperationsInput | string
    image_canonical_uri?: StringFieldUpdateOperationsInput | string
    contract_id?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    decimals?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    sender_address?: StringFieldUpdateOperationsInput | string
  }

  export type mempool_txsCreateInput = {
    pruned: boolean
    tx_id: Buffer
    type_id: number
    anchor_mode: number
    status: number
    post_conditions: Buffer
    nonce: number
    fee_rate: bigint | number
    sponsored: boolean
    sponsor_address?: string | null
    sponsor_nonce?: number | null
    sender_address: string
    origin_hash_mode: number
    raw_tx: Buffer
    receipt_time: number
    receipt_block_height: number
    token_transfer_recipient_address?: string | null
    token_transfer_amount?: bigint | number | null
    token_transfer_memo?: Buffer | null
    smart_contract_clarity_version?: number | null
    smart_contract_contract_id?: string | null
    smart_contract_source_code?: string | null
    contract_call_contract_id?: string | null
    contract_call_function_name?: string | null
    contract_call_function_args?: Buffer | null
    poison_microblock_header_1?: Buffer | null
    poison_microblock_header_2?: Buffer | null
    coinbase_payload?: Buffer | null
    coinbase_alt_recipient?: string | null
    tx_size?: number
  }

  export type mempool_txsUncheckedCreateInput = {
    id?: number
    pruned: boolean
    tx_id: Buffer
    type_id: number
    anchor_mode: number
    status: number
    post_conditions: Buffer
    nonce: number
    fee_rate: bigint | number
    sponsored: boolean
    sponsor_address?: string | null
    sponsor_nonce?: number | null
    sender_address: string
    origin_hash_mode: number
    raw_tx: Buffer
    receipt_time: number
    receipt_block_height: number
    token_transfer_recipient_address?: string | null
    token_transfer_amount?: bigint | number | null
    token_transfer_memo?: Buffer | null
    smart_contract_clarity_version?: number | null
    smart_contract_contract_id?: string | null
    smart_contract_source_code?: string | null
    contract_call_contract_id?: string | null
    contract_call_function_name?: string | null
    contract_call_function_args?: Buffer | null
    poison_microblock_header_1?: Buffer | null
    poison_microblock_header_2?: Buffer | null
    coinbase_payload?: Buffer | null
    coinbase_alt_recipient?: string | null
    tx_size?: number
  }

  export type mempool_txsUpdateInput = {
    pruned?: BoolFieldUpdateOperationsInput | boolean
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    type_id?: IntFieldUpdateOperationsInput | number
    anchor_mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    post_conditions?: BytesFieldUpdateOperationsInput | Buffer
    nonce?: IntFieldUpdateOperationsInput | number
    fee_rate?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsor_address?: NullableStringFieldUpdateOperationsInput | string | null
    sponsor_nonce?: NullableIntFieldUpdateOperationsInput | number | null
    sender_address?: StringFieldUpdateOperationsInput | string
    origin_hash_mode?: IntFieldUpdateOperationsInput | number
    raw_tx?: BytesFieldUpdateOperationsInput | Buffer
    receipt_time?: IntFieldUpdateOperationsInput | number
    receipt_block_height?: IntFieldUpdateOperationsInput | number
    token_transfer_recipient_address?: NullableStringFieldUpdateOperationsInput | string | null
    token_transfer_amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    token_transfer_memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    smart_contract_clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    smart_contract_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    smart_contract_source_code?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_args?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_1?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_2?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_payload?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_alt_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    tx_size?: IntFieldUpdateOperationsInput | number
  }

  export type mempool_txsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pruned?: BoolFieldUpdateOperationsInput | boolean
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    type_id?: IntFieldUpdateOperationsInput | number
    anchor_mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    post_conditions?: BytesFieldUpdateOperationsInput | Buffer
    nonce?: IntFieldUpdateOperationsInput | number
    fee_rate?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsor_address?: NullableStringFieldUpdateOperationsInput | string | null
    sponsor_nonce?: NullableIntFieldUpdateOperationsInput | number | null
    sender_address?: StringFieldUpdateOperationsInput | string
    origin_hash_mode?: IntFieldUpdateOperationsInput | number
    raw_tx?: BytesFieldUpdateOperationsInput | Buffer
    receipt_time?: IntFieldUpdateOperationsInput | number
    receipt_block_height?: IntFieldUpdateOperationsInput | number
    token_transfer_recipient_address?: NullableStringFieldUpdateOperationsInput | string | null
    token_transfer_amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    token_transfer_memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    smart_contract_clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    smart_contract_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    smart_contract_source_code?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_args?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_1?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_2?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_payload?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_alt_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    tx_size?: IntFieldUpdateOperationsInput | number
  }

  export type mempool_txsCreateManyInput = {
    id?: number
    pruned: boolean
    tx_id: Buffer
    type_id: number
    anchor_mode: number
    status: number
    post_conditions: Buffer
    nonce: number
    fee_rate: bigint | number
    sponsored: boolean
    sponsor_address?: string | null
    sponsor_nonce?: number | null
    sender_address: string
    origin_hash_mode: number
    raw_tx: Buffer
    receipt_time: number
    receipt_block_height: number
    token_transfer_recipient_address?: string | null
    token_transfer_amount?: bigint | number | null
    token_transfer_memo?: Buffer | null
    smart_contract_clarity_version?: number | null
    smart_contract_contract_id?: string | null
    smart_contract_source_code?: string | null
    contract_call_contract_id?: string | null
    contract_call_function_name?: string | null
    contract_call_function_args?: Buffer | null
    poison_microblock_header_1?: Buffer | null
    poison_microblock_header_2?: Buffer | null
    coinbase_payload?: Buffer | null
    coinbase_alt_recipient?: string | null
    tx_size?: number
  }

  export type mempool_txsUpdateManyMutationInput = {
    pruned?: BoolFieldUpdateOperationsInput | boolean
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    type_id?: IntFieldUpdateOperationsInput | number
    anchor_mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    post_conditions?: BytesFieldUpdateOperationsInput | Buffer
    nonce?: IntFieldUpdateOperationsInput | number
    fee_rate?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsor_address?: NullableStringFieldUpdateOperationsInput | string | null
    sponsor_nonce?: NullableIntFieldUpdateOperationsInput | number | null
    sender_address?: StringFieldUpdateOperationsInput | string
    origin_hash_mode?: IntFieldUpdateOperationsInput | number
    raw_tx?: BytesFieldUpdateOperationsInput | Buffer
    receipt_time?: IntFieldUpdateOperationsInput | number
    receipt_block_height?: IntFieldUpdateOperationsInput | number
    token_transfer_recipient_address?: NullableStringFieldUpdateOperationsInput | string | null
    token_transfer_amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    token_transfer_memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    smart_contract_clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    smart_contract_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    smart_contract_source_code?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_args?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_1?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_2?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_payload?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_alt_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    tx_size?: IntFieldUpdateOperationsInput | number
  }

  export type mempool_txsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pruned?: BoolFieldUpdateOperationsInput | boolean
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    type_id?: IntFieldUpdateOperationsInput | number
    anchor_mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    post_conditions?: BytesFieldUpdateOperationsInput | Buffer
    nonce?: IntFieldUpdateOperationsInput | number
    fee_rate?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsor_address?: NullableStringFieldUpdateOperationsInput | string | null
    sponsor_nonce?: NullableIntFieldUpdateOperationsInput | number | null
    sender_address?: StringFieldUpdateOperationsInput | string
    origin_hash_mode?: IntFieldUpdateOperationsInput | number
    raw_tx?: BytesFieldUpdateOperationsInput | Buffer
    receipt_time?: IntFieldUpdateOperationsInput | number
    receipt_block_height?: IntFieldUpdateOperationsInput | number
    token_transfer_recipient_address?: NullableStringFieldUpdateOperationsInput | string | null
    token_transfer_amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    token_transfer_memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    smart_contract_clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    smart_contract_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    smart_contract_source_code?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_args?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_1?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_2?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_payload?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_alt_recipient?: NullableStringFieldUpdateOperationsInput | string | null
    tx_size?: IntFieldUpdateOperationsInput | number
  }

  export type microblocksCreateInput = {
    id?: bigint | number
    receive_timestamp?: Date | string
    canonical: boolean
    microblock_canonical: boolean
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_parent_hash: Buffer
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    block_height: number
    parent_block_height: number
    parent_block_hash: Buffer
    parent_burn_block_height: number
    parent_burn_block_time: number
    parent_burn_block_hash: Buffer
    block_hash: Buffer
  }

  export type microblocksUncheckedCreateInput = {
    id?: bigint | number
    receive_timestamp?: Date | string
    canonical: boolean
    microblock_canonical: boolean
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_parent_hash: Buffer
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    block_height: number
    parent_block_height: number
    parent_block_hash: Buffer
    parent_burn_block_height: number
    parent_burn_block_time: number
    parent_burn_block_hash: Buffer
    block_hash: Buffer
  }

  export type microblocksUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    receive_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_parent_hash?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    parent_block_height?: IntFieldUpdateOperationsInput | number
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_burn_block_height?: IntFieldUpdateOperationsInput | number
    parent_burn_block_time?: IntFieldUpdateOperationsInput | number
    parent_burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type microblocksUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    receive_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_parent_hash?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    parent_block_height?: IntFieldUpdateOperationsInput | number
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_burn_block_height?: IntFieldUpdateOperationsInput | number
    parent_burn_block_time?: IntFieldUpdateOperationsInput | number
    parent_burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type microblocksCreateManyInput = {
    id?: bigint | number
    receive_timestamp?: Date | string
    canonical: boolean
    microblock_canonical: boolean
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_parent_hash: Buffer
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    block_height: number
    parent_block_height: number
    parent_block_hash: Buffer
    parent_burn_block_height: number
    parent_burn_block_time: number
    parent_burn_block_hash: Buffer
    block_hash: Buffer
  }

  export type microblocksUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    receive_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_parent_hash?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    parent_block_height?: IntFieldUpdateOperationsInput | number
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_burn_block_height?: IntFieldUpdateOperationsInput | number
    parent_burn_block_time?: IntFieldUpdateOperationsInput | number
    parent_burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type microblocksUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    receive_timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_parent_hash?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    parent_block_height?: IntFieldUpdateOperationsInput | number
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_burn_block_height?: IntFieldUpdateOperationsInput | number
    parent_burn_block_time?: IntFieldUpdateOperationsInput | number
    parent_burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type miner_rewardsCreateInput = {
    block_hash: Buffer
    index_block_hash: Buffer
    from_index_block_hash: Buffer
    mature_block_height: number
    canonical: boolean
    recipient: string
    miner_address?: string | null
    coinbase_amount: Decimal | DecimalJsLike | number | string
    tx_fees_anchored: Decimal | DecimalJsLike | number | string
    tx_fees_streamed_confirmed: Decimal | DecimalJsLike | number | string
    tx_fees_streamed_produced: Decimal | DecimalJsLike | number | string
  }

  export type miner_rewardsUncheckedCreateInput = {
    id?: number
    block_hash: Buffer
    index_block_hash: Buffer
    from_index_block_hash: Buffer
    mature_block_height: number
    canonical: boolean
    recipient: string
    miner_address?: string | null
    coinbase_amount: Decimal | DecimalJsLike | number | string
    tx_fees_anchored: Decimal | DecimalJsLike | number | string
    tx_fees_streamed_confirmed: Decimal | DecimalJsLike | number | string
    tx_fees_streamed_produced: Decimal | DecimalJsLike | number | string
  }

  export type miner_rewardsUpdateInput = {
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    from_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    mature_block_height?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    recipient?: StringFieldUpdateOperationsInput | string
    miner_address?: NullableStringFieldUpdateOperationsInput | string | null
    coinbase_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_anchored?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_confirmed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_produced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type miner_rewardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    from_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    mature_block_height?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    recipient?: StringFieldUpdateOperationsInput | string
    miner_address?: NullableStringFieldUpdateOperationsInput | string | null
    coinbase_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_anchored?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_confirmed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_produced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type miner_rewardsCreateManyInput = {
    id?: number
    block_hash: Buffer
    index_block_hash: Buffer
    from_index_block_hash: Buffer
    mature_block_height: number
    canonical: boolean
    recipient: string
    miner_address?: string | null
    coinbase_amount: Decimal | DecimalJsLike | number | string
    tx_fees_anchored: Decimal | DecimalJsLike | number | string
    tx_fees_streamed_confirmed: Decimal | DecimalJsLike | number | string
    tx_fees_streamed_produced: Decimal | DecimalJsLike | number | string
  }

  export type miner_rewardsUpdateManyMutationInput = {
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    from_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    mature_block_height?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    recipient?: StringFieldUpdateOperationsInput | string
    miner_address?: NullableStringFieldUpdateOperationsInput | string | null
    coinbase_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_anchored?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_confirmed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_produced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type miner_rewardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    from_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    mature_block_height?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    recipient?: StringFieldUpdateOperationsInput | string
    miner_address?: NullableStringFieldUpdateOperationsInput | string | null
    coinbase_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_anchored?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_confirmed?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tx_fees_streamed_produced?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type namesCreateInput = {
    name: string
    address: string
    registered_at: number
    expire_block: number
    zonefile_hash: string
    namespace_id: string
    grace_period?: string | null
    renewal_deadline?: number | null
    resolver?: string | null
    tx_id?: Buffer | null
    tx_index: number
    event_index?: number | null
    status?: string | null
    canonical?: boolean
    index_block_hash?: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
  }

  export type namesUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    registered_at: number
    expire_block: number
    zonefile_hash: string
    namespace_id: string
    grace_period?: string | null
    renewal_deadline?: number | null
    resolver?: string | null
    tx_id?: Buffer | null
    tx_index: number
    event_index?: number | null
    status?: string | null
    canonical?: boolean
    index_block_hash?: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
  }

  export type namesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    registered_at?: IntFieldUpdateOperationsInput | number
    expire_block?: IntFieldUpdateOperationsInput | number
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    namespace_id?: StringFieldUpdateOperationsInput | string
    grace_period?: NullableStringFieldUpdateOperationsInput | string | null
    renewal_deadline?: NullableIntFieldUpdateOperationsInput | number | null
    resolver?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tx_index?: IntFieldUpdateOperationsInput | number
    event_index?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type namesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    registered_at?: IntFieldUpdateOperationsInput | number
    expire_block?: IntFieldUpdateOperationsInput | number
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    namespace_id?: StringFieldUpdateOperationsInput | string
    grace_period?: NullableStringFieldUpdateOperationsInput | string | null
    renewal_deadline?: NullableIntFieldUpdateOperationsInput | number | null
    resolver?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tx_index?: IntFieldUpdateOperationsInput | number
    event_index?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type namesCreateManyInput = {
    id?: number
    name: string
    address: string
    registered_at: number
    expire_block: number
    zonefile_hash: string
    namespace_id: string
    grace_period?: string | null
    renewal_deadline?: number | null
    resolver?: string | null
    tx_id?: Buffer | null
    tx_index: number
    event_index?: number | null
    status?: string | null
    canonical?: boolean
    index_block_hash?: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
  }

  export type namesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    registered_at?: IntFieldUpdateOperationsInput | number
    expire_block?: IntFieldUpdateOperationsInput | number
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    namespace_id?: StringFieldUpdateOperationsInput | string
    grace_period?: NullableStringFieldUpdateOperationsInput | string | null
    renewal_deadline?: NullableIntFieldUpdateOperationsInput | number | null
    resolver?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tx_index?: IntFieldUpdateOperationsInput | number
    event_index?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type namesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    registered_at?: IntFieldUpdateOperationsInput | number
    expire_block?: IntFieldUpdateOperationsInput | number
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    namespace_id?: StringFieldUpdateOperationsInput | string
    grace_period?: NullableStringFieldUpdateOperationsInput | string | null
    renewal_deadline?: NullableIntFieldUpdateOperationsInput | number | null
    resolver?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tx_index?: IntFieldUpdateOperationsInput | number
    event_index?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type namespacesCreateInput = {
    namespace_id: string
    launched_at?: number | null
    address: string
    reveal_block: number
    ready_block: number
    buckets: string
    base: Decimal | DecimalJsLike | number | string
    coeff: Decimal | DecimalJsLike | number | string
    nonalpha_discount: number
    no_vowel_discount: number
    lifetime: number
    status?: string | null
    tx_id?: Buffer | null
    tx_index: number
    canonical?: boolean
    index_block_hash?: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
  }

  export type namespacesUncheckedCreateInput = {
    id?: number
    namespace_id: string
    launched_at?: number | null
    address: string
    reveal_block: number
    ready_block: number
    buckets: string
    base: Decimal | DecimalJsLike | number | string
    coeff: Decimal | DecimalJsLike | number | string
    nonalpha_discount: number
    no_vowel_discount: number
    lifetime: number
    status?: string | null
    tx_id?: Buffer | null
    tx_index: number
    canonical?: boolean
    index_block_hash?: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
  }

  export type namespacesUpdateInput = {
    namespace_id?: StringFieldUpdateOperationsInput | string
    launched_at?: NullableIntFieldUpdateOperationsInput | number | null
    address?: StringFieldUpdateOperationsInput | string
    reveal_block?: IntFieldUpdateOperationsInput | number
    ready_block?: IntFieldUpdateOperationsInput | number
    buckets?: StringFieldUpdateOperationsInput | string
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    coeff?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nonalpha_discount?: IntFieldUpdateOperationsInput | number
    no_vowel_discount?: IntFieldUpdateOperationsInput | number
    lifetime?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tx_index?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type namespacesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    namespace_id?: StringFieldUpdateOperationsInput | string
    launched_at?: NullableIntFieldUpdateOperationsInput | number | null
    address?: StringFieldUpdateOperationsInput | string
    reveal_block?: IntFieldUpdateOperationsInput | number
    ready_block?: IntFieldUpdateOperationsInput | number
    buckets?: StringFieldUpdateOperationsInput | string
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    coeff?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nonalpha_discount?: IntFieldUpdateOperationsInput | number
    no_vowel_discount?: IntFieldUpdateOperationsInput | number
    lifetime?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tx_index?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type namespacesCreateManyInput = {
    id?: number
    namespace_id: string
    launched_at?: number | null
    address: string
    reveal_block: number
    ready_block: number
    buckets: string
    base: Decimal | DecimalJsLike | number | string
    coeff: Decimal | DecimalJsLike | number | string
    nonalpha_discount: number
    no_vowel_discount: number
    lifetime: number
    status?: string | null
    tx_id?: Buffer | null
    tx_index: number
    canonical?: boolean
    index_block_hash?: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
  }

  export type namespacesUpdateManyMutationInput = {
    namespace_id?: StringFieldUpdateOperationsInput | string
    launched_at?: NullableIntFieldUpdateOperationsInput | number | null
    address?: StringFieldUpdateOperationsInput | string
    reveal_block?: IntFieldUpdateOperationsInput | number
    ready_block?: IntFieldUpdateOperationsInput | number
    buckets?: StringFieldUpdateOperationsInput | string
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    coeff?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nonalpha_discount?: IntFieldUpdateOperationsInput | number
    no_vowel_discount?: IntFieldUpdateOperationsInput | number
    lifetime?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tx_index?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type namespacesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    namespace_id?: StringFieldUpdateOperationsInput | string
    launched_at?: NullableIntFieldUpdateOperationsInput | number | null
    address?: StringFieldUpdateOperationsInput | string
    reveal_block?: IntFieldUpdateOperationsInput | number
    ready_block?: IntFieldUpdateOperationsInput | number
    buckets?: StringFieldUpdateOperationsInput | string
    base?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    coeff?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    nonalpha_discount?: IntFieldUpdateOperationsInput | number
    no_vowel_discount?: IntFieldUpdateOperationsInput | number
    lifetime?: IntFieldUpdateOperationsInput | number
    status?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    tx_index?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type nft_eventsCreateInput = {
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    asset_identifier: string
    value: Buffer
    sender?: string | null
    recipient?: string | null
  }

  export type nft_eventsUncheckedCreateInput = {
    id?: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    asset_identifier: string
    value: Buffer
    sender?: string | null
    recipient?: string | null
  }

  export type nft_eventsUpdateInput = {
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    asset_identifier?: StringFieldUpdateOperationsInput | string
    value?: BytesFieldUpdateOperationsInput | Buffer
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type nft_eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    asset_identifier?: StringFieldUpdateOperationsInput | string
    value?: BytesFieldUpdateOperationsInput | Buffer
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type nft_eventsCreateManyInput = {
    id?: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    asset_identifier: string
    value: Buffer
    sender?: string | null
    recipient?: string | null
  }

  export type nft_eventsUpdateManyMutationInput = {
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    asset_identifier?: StringFieldUpdateOperationsInput | string
    value?: BytesFieldUpdateOperationsInput | Buffer
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type nft_eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    asset_identifier?: StringFieldUpdateOperationsInput | string
    value?: BytesFieldUpdateOperationsInput | Buffer
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type nft_metadataCreateInput = {
    name: string
    token_uri: string
    description: string
    image_uri: string
    image_canonical_uri: string
    contract_id: string
    tx_id: Buffer
    sender_address: string
  }

  export type nft_metadataUncheckedCreateInput = {
    id?: number
    name: string
    token_uri: string
    description: string
    image_uri: string
    image_canonical_uri: string
    contract_id: string
    tx_id: Buffer
    sender_address: string
  }

  export type nft_metadataUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    token_uri?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_uri?: StringFieldUpdateOperationsInput | string
    image_canonical_uri?: StringFieldUpdateOperationsInput | string
    contract_id?: StringFieldUpdateOperationsInput | string
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    sender_address?: StringFieldUpdateOperationsInput | string
  }

  export type nft_metadataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    token_uri?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_uri?: StringFieldUpdateOperationsInput | string
    image_canonical_uri?: StringFieldUpdateOperationsInput | string
    contract_id?: StringFieldUpdateOperationsInput | string
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    sender_address?: StringFieldUpdateOperationsInput | string
  }

  export type nft_metadataCreateManyInput = {
    id?: number
    name: string
    token_uri: string
    description: string
    image_uri: string
    image_canonical_uri: string
    contract_id: string
    tx_id: Buffer
    sender_address: string
  }

  export type nft_metadataUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    token_uri?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_uri?: StringFieldUpdateOperationsInput | string
    image_canonical_uri?: StringFieldUpdateOperationsInput | string
    contract_id?: StringFieldUpdateOperationsInput | string
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    sender_address?: StringFieldUpdateOperationsInput | string
  }

  export type nft_metadataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    token_uri?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    image_uri?: StringFieldUpdateOperationsInput | string
    image_canonical_uri?: StringFieldUpdateOperationsInput | string
    contract_id?: StringFieldUpdateOperationsInput | string
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    sender_address?: StringFieldUpdateOperationsInput | string
  }

  export type pgmigrationsCreateInput = {
    name: string
    run_on: Date | string
  }

  export type pgmigrationsUncheckedCreateInput = {
    id?: number
    name: string
    run_on: Date | string
  }

  export type pgmigrationsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    run_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pgmigrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    run_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pgmigrationsCreateManyInput = {
    id?: number
    name: string
    run_on: Date | string
  }

  export type pgmigrationsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    run_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pgmigrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    run_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type pox2_eventsCreateInput = {
    id?: bigint | number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    stacker: string
    locked: Decimal | DecimalJsLike | number | string
    balance: Decimal | DecimalJsLike | number | string
    burnchain_unlock_height: bigint | number
    name: string
    pox_addr?: string | null
    pox_addr_raw?: Buffer | null
    first_cycle_locked?: Decimal | DecimalJsLike | number | string | null
    first_unlocked_cycle?: Decimal | DecimalJsLike | number | string | null
    lock_period?: Decimal | DecimalJsLike | number | string | null
    lock_amount?: Decimal | DecimalJsLike | number | string | null
    start_burn_height?: Decimal | DecimalJsLike | number | string | null
    unlock_burn_height?: Decimal | DecimalJsLike | number | string | null
    delegator?: string | null
    increase_by?: Decimal | DecimalJsLike | number | string | null
    total_locked?: Decimal | DecimalJsLike | number | string | null
    extend_count?: Decimal | DecimalJsLike | number | string | null
    reward_cycle?: Decimal | DecimalJsLike | number | string | null
    amount_ustx?: Decimal | DecimalJsLike | number | string | null
  }

  export type pox2_eventsUncheckedCreateInput = {
    id?: bigint | number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    stacker: string
    locked: Decimal | DecimalJsLike | number | string
    balance: Decimal | DecimalJsLike | number | string
    burnchain_unlock_height: bigint | number
    name: string
    pox_addr?: string | null
    pox_addr_raw?: Buffer | null
    first_cycle_locked?: Decimal | DecimalJsLike | number | string | null
    first_unlocked_cycle?: Decimal | DecimalJsLike | number | string | null
    lock_period?: Decimal | DecimalJsLike | number | string | null
    lock_amount?: Decimal | DecimalJsLike | number | string | null
    start_burn_height?: Decimal | DecimalJsLike | number | string | null
    unlock_burn_height?: Decimal | DecimalJsLike | number | string | null
    delegator?: string | null
    increase_by?: Decimal | DecimalJsLike | number | string | null
    total_locked?: Decimal | DecimalJsLike | number | string | null
    extend_count?: Decimal | DecimalJsLike | number | string | null
    reward_cycle?: Decimal | DecimalJsLike | number | string | null
    amount_ustx?: Decimal | DecimalJsLike | number | string | null
  }

  export type pox2_eventsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    stacker?: StringFieldUpdateOperationsInput | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    burnchain_unlock_height?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    pox_addr?: NullableStringFieldUpdateOperationsInput | string | null
    pox_addr_raw?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    first_cycle_locked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_unlocked_cycle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lock_period?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lock_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_burn_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unlock_burn_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delegator?: NullableStringFieldUpdateOperationsInput | string | null
    increase_by?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_locked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extend_count?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reward_cycle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_ustx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pox2_eventsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    stacker?: StringFieldUpdateOperationsInput | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    burnchain_unlock_height?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    pox_addr?: NullableStringFieldUpdateOperationsInput | string | null
    pox_addr_raw?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    first_cycle_locked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_unlocked_cycle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lock_period?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lock_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_burn_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unlock_burn_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delegator?: NullableStringFieldUpdateOperationsInput | string | null
    increase_by?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_locked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extend_count?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reward_cycle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_ustx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pox2_eventsCreateManyInput = {
    id?: bigint | number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    stacker: string
    locked: Decimal | DecimalJsLike | number | string
    balance: Decimal | DecimalJsLike | number | string
    burnchain_unlock_height: bigint | number
    name: string
    pox_addr?: string | null
    pox_addr_raw?: Buffer | null
    first_cycle_locked?: Decimal | DecimalJsLike | number | string | null
    first_unlocked_cycle?: Decimal | DecimalJsLike | number | string | null
    lock_period?: Decimal | DecimalJsLike | number | string | null
    lock_amount?: Decimal | DecimalJsLike | number | string | null
    start_burn_height?: Decimal | DecimalJsLike | number | string | null
    unlock_burn_height?: Decimal | DecimalJsLike | number | string | null
    delegator?: string | null
    increase_by?: Decimal | DecimalJsLike | number | string | null
    total_locked?: Decimal | DecimalJsLike | number | string | null
    extend_count?: Decimal | DecimalJsLike | number | string | null
    reward_cycle?: Decimal | DecimalJsLike | number | string | null
    amount_ustx?: Decimal | DecimalJsLike | number | string | null
  }

  export type pox2_eventsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    stacker?: StringFieldUpdateOperationsInput | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    burnchain_unlock_height?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    pox_addr?: NullableStringFieldUpdateOperationsInput | string | null
    pox_addr_raw?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    first_cycle_locked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_unlocked_cycle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lock_period?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lock_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_burn_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unlock_burn_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delegator?: NullableStringFieldUpdateOperationsInput | string | null
    increase_by?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_locked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extend_count?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reward_cycle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_ustx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pox2_eventsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    stacker?: StringFieldUpdateOperationsInput | string
    locked?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    burnchain_unlock_height?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    pox_addr?: NullableStringFieldUpdateOperationsInput | string | null
    pox_addr_raw?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    first_cycle_locked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    first_unlocked_cycle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lock_period?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    lock_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    start_burn_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unlock_burn_height?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    delegator?: NullableStringFieldUpdateOperationsInput | string | null
    increase_by?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total_locked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    extend_count?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reward_cycle?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    amount_ustx?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type pox_stateCreateInput = {
    id?: boolean
    pox_v1_unlock_height?: number
  }

  export type pox_stateUncheckedCreateInput = {
    id?: boolean
    pox_v1_unlock_height?: number
  }

  export type pox_stateUpdateInput = {
    id?: BoolFieldUpdateOperationsInput | boolean
    pox_v1_unlock_height?: IntFieldUpdateOperationsInput | number
  }

  export type pox_stateUncheckedUpdateInput = {
    id?: BoolFieldUpdateOperationsInput | boolean
    pox_v1_unlock_height?: IntFieldUpdateOperationsInput | number
  }

  export type pox_stateCreateManyInput = {
    id?: boolean
    pox_v1_unlock_height?: number
  }

  export type pox_stateUpdateManyMutationInput = {
    id?: BoolFieldUpdateOperationsInput | boolean
    pox_v1_unlock_height?: IntFieldUpdateOperationsInput | number
  }

  export type pox_stateUncheckedUpdateManyInput = {
    id?: BoolFieldUpdateOperationsInput | boolean
    pox_v1_unlock_height?: IntFieldUpdateOperationsInput | number
  }

  export type principal_stx_txsCreateInput = {
    principal: string
    tx_id: Buffer
    block_height: number
    index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    tx_index: number
    canonical: boolean
    microblock_canonical: boolean
  }

  export type principal_stx_txsUncheckedCreateInput = {
    id?: number
    principal: string
    tx_id: Buffer
    block_height: number
    index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    tx_index: number
    canonical: boolean
    microblock_canonical: boolean
  }

  export type principal_stx_txsUpdateInput = {
    principal?: StringFieldUpdateOperationsInput | string
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    tx_index?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type principal_stx_txsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    principal?: StringFieldUpdateOperationsInput | string
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    tx_index?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type principal_stx_txsCreateManyInput = {
    id?: number
    principal: string
    tx_id: Buffer
    block_height: number
    index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    tx_index: number
    canonical: boolean
    microblock_canonical: boolean
  }

  export type principal_stx_txsUpdateManyMutationInput = {
    principal?: StringFieldUpdateOperationsInput | string
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    tx_index?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type principal_stx_txsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    principal?: StringFieldUpdateOperationsInput | string
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    tx_index?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type reward_slot_holdersCreateInput = {
    canonical: boolean
    burn_block_hash: Buffer
    burn_block_height: number
    address: string
    slot_index: number
  }

  export type reward_slot_holdersUncheckedCreateInput = {
    id?: number
    canonical: boolean
    burn_block_hash: Buffer
    burn_block_height: number
    address: string
    slot_index: number
  }

  export type reward_slot_holdersUpdateInput = {
    canonical?: BoolFieldUpdateOperationsInput | boolean
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    slot_index?: IntFieldUpdateOperationsInput | number
  }

  export type reward_slot_holdersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    slot_index?: IntFieldUpdateOperationsInput | number
  }

  export type reward_slot_holdersCreateManyInput = {
    id?: number
    canonical: boolean
    burn_block_hash: Buffer
    burn_block_height: number
    address: string
    slot_index: number
  }

  export type reward_slot_holdersUpdateManyMutationInput = {
    canonical?: BoolFieldUpdateOperationsInput | boolean
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    slot_index?: IntFieldUpdateOperationsInput | number
  }

  export type reward_slot_holdersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    burn_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_height?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    slot_index?: IntFieldUpdateOperationsInput | number
  }

  export type smart_contractsCreateInput = {
    tx_id: Buffer
    canonical: boolean
    contract_id: string
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    clarity_version?: number | null
    source_code: string
    abi: JsonNullValueInput | InputJsonValue
  }

  export type smart_contractsUncheckedCreateInput = {
    id?: number
    tx_id: Buffer
    canonical: boolean
    contract_id: string
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    clarity_version?: number | null
    source_code: string
    abi: JsonNullValueInput | InputJsonValue
  }

  export type smart_contractsUpdateInput = {
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    canonical?: BoolFieldUpdateOperationsInput | boolean
    contract_id?: StringFieldUpdateOperationsInput | string
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    source_code?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
  }

  export type smart_contractsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    canonical?: BoolFieldUpdateOperationsInput | boolean
    contract_id?: StringFieldUpdateOperationsInput | string
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    source_code?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
  }

  export type smart_contractsCreateManyInput = {
    id?: number
    tx_id: Buffer
    canonical: boolean
    contract_id: string
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    clarity_version?: number | null
    source_code: string
    abi: JsonNullValueInput | InputJsonValue
  }

  export type smart_contractsUpdateManyMutationInput = {
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    canonical?: BoolFieldUpdateOperationsInput | boolean
    contract_id?: StringFieldUpdateOperationsInput | string
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    source_code?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
  }

  export type smart_contractsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    canonical?: BoolFieldUpdateOperationsInput | boolean
    contract_id?: StringFieldUpdateOperationsInput | string
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    source_code?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
  }

  export type stx_eventsCreateInput = {
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    amount: bigint | number
    sender?: string | null
    recipient?: string | null
    memo?: Buffer | null
  }

  export type stx_eventsUncheckedCreateInput = {
    id?: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    amount: bigint | number
    sender?: string | null
    recipient?: string | null
    memo?: Buffer | null
  }

  export type stx_eventsUpdateInput = {
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type stx_eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type stx_eventsCreateManyInput = {
    id?: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    asset_event_type_id: number
    amount: bigint | number
    sender?: string | null
    recipient?: string | null
    memo?: Buffer | null
  }

  export type stx_eventsUpdateManyMutationInput = {
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type stx_eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    asset_event_type_id?: IntFieldUpdateOperationsInput | number
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    sender?: NullableStringFieldUpdateOperationsInput | string | null
    recipient?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type stx_lock_eventsCreateInput = {
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    locked_amount: Decimal | DecimalJsLike | number | string
    unlock_height: number
    locked_address: string
    contract_name: string
  }

  export type stx_lock_eventsUncheckedCreateInput = {
    id?: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    locked_amount: Decimal | DecimalJsLike | number | string
    unlock_height: number
    locked_address: string
    contract_name: string
  }

  export type stx_lock_eventsUpdateInput = {
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    locked_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unlock_height?: IntFieldUpdateOperationsInput | number
    locked_address?: StringFieldUpdateOperationsInput | string
    contract_name?: StringFieldUpdateOperationsInput | string
  }

  export type stx_lock_eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    locked_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unlock_height?: IntFieldUpdateOperationsInput | number
    locked_address?: StringFieldUpdateOperationsInput | string
    contract_name?: StringFieldUpdateOperationsInput | string
  }

  export type stx_lock_eventsCreateManyInput = {
    id?: number
    event_index: number
    tx_id: Buffer
    tx_index: number
    block_height: number
    index_block_hash: Buffer
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
    canonical: boolean
    locked_amount: Decimal | DecimalJsLike | number | string
    unlock_height: number
    locked_address: string
    contract_name: string
  }

  export type stx_lock_eventsUpdateManyMutationInput = {
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    locked_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unlock_height?: IntFieldUpdateOperationsInput | number
    locked_address?: StringFieldUpdateOperationsInput | string
    contract_name?: StringFieldUpdateOperationsInput | string
  }

  export type stx_lock_eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_index?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    canonical?: BoolFieldUpdateOperationsInput | boolean
    locked_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unlock_height?: IntFieldUpdateOperationsInput | number
    locked_address?: StringFieldUpdateOperationsInput | string
    contract_name?: StringFieldUpdateOperationsInput | string
  }

  export type subdomainsCreateInput = {
    name: string
    namespace_id: string
    fully_qualified_subdomain: string
    owner: string
    zonefile_hash: string
    parent_zonefile_hash: string
    parent_zonefile_index: number
    tx_index: number
    block_height: number
    zonefile_offset?: number | null
    resolver?: string | null
    tx_id?: Buffer | null
    canonical?: boolean
    index_block_hash?: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
  }

  export type subdomainsUncheckedCreateInput = {
    id?: number
    name: string
    namespace_id: string
    fully_qualified_subdomain: string
    owner: string
    zonefile_hash: string
    parent_zonefile_hash: string
    parent_zonefile_index: number
    tx_index: number
    block_height: number
    zonefile_offset?: number | null
    resolver?: string | null
    tx_id?: Buffer | null
    canonical?: boolean
    index_block_hash?: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
  }

  export type subdomainsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    namespace_id?: StringFieldUpdateOperationsInput | string
    fully_qualified_subdomain?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    parent_zonefile_hash?: StringFieldUpdateOperationsInput | string
    parent_zonefile_index?: IntFieldUpdateOperationsInput | number
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    zonefile_offset?: NullableIntFieldUpdateOperationsInput | number | null
    resolver?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type subdomainsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    namespace_id?: StringFieldUpdateOperationsInput | string
    fully_qualified_subdomain?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    parent_zonefile_hash?: StringFieldUpdateOperationsInput | string
    parent_zonefile_index?: IntFieldUpdateOperationsInput | number
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    zonefile_offset?: NullableIntFieldUpdateOperationsInput | number | null
    resolver?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type subdomainsCreateManyInput = {
    id?: number
    name: string
    namespace_id: string
    fully_qualified_subdomain: string
    owner: string
    zonefile_hash: string
    parent_zonefile_hash: string
    parent_zonefile_index: number
    tx_index: number
    block_height: number
    zonefile_offset?: number | null
    resolver?: string | null
    tx_id?: Buffer | null
    canonical?: boolean
    index_block_hash?: Buffer | null
    parent_index_block_hash: Buffer
    microblock_hash: Buffer
    microblock_sequence: number
    microblock_canonical: boolean
  }

  export type subdomainsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    namespace_id?: StringFieldUpdateOperationsInput | string
    fully_qualified_subdomain?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    parent_zonefile_hash?: StringFieldUpdateOperationsInput | string
    parent_zonefile_index?: IntFieldUpdateOperationsInput | number
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    zonefile_offset?: NullableIntFieldUpdateOperationsInput | number | null
    resolver?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type subdomainsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    namespace_id?: StringFieldUpdateOperationsInput | string
    fully_qualified_subdomain?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    parent_zonefile_hash?: StringFieldUpdateOperationsInput | string
    parent_zonefile_index?: IntFieldUpdateOperationsInput | number
    tx_index?: IntFieldUpdateOperationsInput | number
    block_height?: IntFieldUpdateOperationsInput | number
    zonefile_offset?: NullableIntFieldUpdateOperationsInput | number | null
    resolver?: NullableStringFieldUpdateOperationsInput | string | null
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    canonical?: BoolFieldUpdateOperationsInput | boolean
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
  }

  export type token_metadata_queueCreateInput = {
    tx_id: Buffer
    contract_id: string
    contract_abi: string
    block_height: number
    processed: boolean
    retry_count?: number
  }

  export type token_metadata_queueUncheckedCreateInput = {
    queue_id?: number
    tx_id: Buffer
    contract_id: string
    contract_abi: string
    block_height: number
    processed: boolean
    retry_count?: number
  }

  export type token_metadata_queueUpdateInput = {
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    contract_id?: StringFieldUpdateOperationsInput | string
    contract_abi?: StringFieldUpdateOperationsInput | string
    block_height?: IntFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type token_metadata_queueUncheckedUpdateInput = {
    queue_id?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    contract_id?: StringFieldUpdateOperationsInput | string
    contract_abi?: StringFieldUpdateOperationsInput | string
    block_height?: IntFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type token_metadata_queueCreateManyInput = {
    queue_id?: number
    tx_id: Buffer
    contract_id: string
    contract_abi: string
    block_height: number
    processed: boolean
    retry_count?: number
  }

  export type token_metadata_queueUpdateManyMutationInput = {
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    contract_id?: StringFieldUpdateOperationsInput | string
    contract_abi?: StringFieldUpdateOperationsInput | string
    block_height?: IntFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type token_metadata_queueUncheckedUpdateManyInput = {
    queue_id?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    contract_id?: StringFieldUpdateOperationsInput | string
    contract_abi?: StringFieldUpdateOperationsInput | string
    block_height?: IntFieldUpdateOperationsInput | number
    processed?: BoolFieldUpdateOperationsInput | boolean
    retry_count?: IntFieldUpdateOperationsInput | number
  }

  export type token_offering_lockedCreateInput = {
    address: string
    value: bigint | number
    block: number
  }

  export type token_offering_lockedUncheckedCreateInput = {
    id?: number
    address: string
    value: bigint | number
    block: number
  }

  export type token_offering_lockedUpdateInput = {
    address?: StringFieldUpdateOperationsInput | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    block?: IntFieldUpdateOperationsInput | number
  }

  export type token_offering_lockedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    block?: IntFieldUpdateOperationsInput | number
  }

  export type token_offering_lockedCreateManyInput = {
    id?: number
    address: string
    value: bigint | number
    block: number
  }

  export type token_offering_lockedUpdateManyMutationInput = {
    address?: StringFieldUpdateOperationsInput | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    block?: IntFieldUpdateOperationsInput | number
  }

  export type token_offering_lockedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    value?: BigIntFieldUpdateOperationsInput | bigint | number
    block?: IntFieldUpdateOperationsInput | number
  }

  export type txsCreateInput = {
    tx_id: Buffer
    tx_index: number
    raw_result: Buffer
    index_block_hash: Buffer
    block_hash: Buffer
    block_height: number
    parent_block_hash: Buffer
    burn_block_time: number
    parent_burn_block_time: number
    type_id: number
    anchor_mode: number
    status: number
    canonical: boolean
    post_conditions: Buffer
    nonce: number
    fee_rate: bigint | number
    sponsored: boolean
    sponsor_address?: string | null
    sponsor_nonce?: number | null
    sender_address: string
    origin_hash_mode: number
    event_count: number
    execution_cost_read_count: bigint | number
    execution_cost_read_length: bigint | number
    execution_cost_runtime: bigint | number
    execution_cost_write_count: bigint | number
    execution_cost_write_length: bigint | number
    raw_tx: Buffer
    microblock_canonical: boolean
    microblock_sequence: number
    microblock_hash: Buffer
    parent_index_block_hash: Buffer
    token_transfer_recipient_address?: string | null
    token_transfer_amount?: bigint | number | null
    token_transfer_memo?: Buffer | null
    smart_contract_clarity_version?: number | null
    smart_contract_contract_id?: string | null
    smart_contract_source_code?: string | null
    contract_call_contract_id?: string | null
    contract_call_function_name?: string | null
    contract_call_function_args?: Buffer | null
    poison_microblock_header_1?: Buffer | null
    poison_microblock_header_2?: Buffer | null
    coinbase_payload?: Buffer | null
    coinbase_alt_recipient?: string | null
  }

  export type txsUncheckedCreateInput = {
    id?: number
    tx_id: Buffer
    tx_index: number
    raw_result: Buffer
    index_block_hash: Buffer
    block_hash: Buffer
    block_height: number
    parent_block_hash: Buffer
    burn_block_time: number
    parent_burn_block_time: number
    type_id: number
    anchor_mode: number
    status: number
    canonical: boolean
    post_conditions: Buffer
    nonce: number
    fee_rate: bigint | number
    sponsored: boolean
    sponsor_address?: string | null
    sponsor_nonce?: number | null
    sender_address: string
    origin_hash_mode: number
    event_count: number
    execution_cost_read_count: bigint | number
    execution_cost_read_length: bigint | number
    execution_cost_runtime: bigint | number
    execution_cost_write_count: bigint | number
    execution_cost_write_length: bigint | number
    raw_tx: Buffer
    microblock_canonical: boolean
    microblock_sequence: number
    microblock_hash: Buffer
    parent_index_block_hash: Buffer
    token_transfer_recipient_address?: string | null
    token_transfer_amount?: bigint | number | null
    token_transfer_memo?: Buffer | null
    smart_contract_clarity_version?: number | null
    smart_contract_contract_id?: string | null
    smart_contract_source_code?: string | null
    contract_call_contract_id?: string | null
    contract_call_function_name?: string | null
    contract_call_function_args?: Buffer | null
    poison_microblock_header_1?: Buffer | null
    poison_microblock_header_2?: Buffer | null
    coinbase_payload?: Buffer | null
    coinbase_alt_recipient?: string | null
  }

  export type txsUpdateInput = {
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    raw_result?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_time?: IntFieldUpdateOperationsInput | number
    parent_burn_block_time?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    anchor_mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    post_conditions?: BytesFieldUpdateOperationsInput | Buffer
    nonce?: IntFieldUpdateOperationsInput | number
    fee_rate?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsor_address?: NullableStringFieldUpdateOperationsInput | string | null
    sponsor_nonce?: NullableIntFieldUpdateOperationsInput | number | null
    sender_address?: StringFieldUpdateOperationsInput | string
    origin_hash_mode?: IntFieldUpdateOperationsInput | number
    event_count?: IntFieldUpdateOperationsInput | number
    execution_cost_read_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_read_length?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_runtime?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_length?: BigIntFieldUpdateOperationsInput | bigint | number
    raw_tx?: BytesFieldUpdateOperationsInput | Buffer
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    token_transfer_recipient_address?: NullableStringFieldUpdateOperationsInput | string | null
    token_transfer_amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    token_transfer_memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    smart_contract_clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    smart_contract_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    smart_contract_source_code?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_args?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_1?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_2?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_payload?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_alt_recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type txsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    raw_result?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_time?: IntFieldUpdateOperationsInput | number
    parent_burn_block_time?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    anchor_mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    post_conditions?: BytesFieldUpdateOperationsInput | Buffer
    nonce?: IntFieldUpdateOperationsInput | number
    fee_rate?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsor_address?: NullableStringFieldUpdateOperationsInput | string | null
    sponsor_nonce?: NullableIntFieldUpdateOperationsInput | number | null
    sender_address?: StringFieldUpdateOperationsInput | string
    origin_hash_mode?: IntFieldUpdateOperationsInput | number
    event_count?: IntFieldUpdateOperationsInput | number
    execution_cost_read_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_read_length?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_runtime?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_length?: BigIntFieldUpdateOperationsInput | bigint | number
    raw_tx?: BytesFieldUpdateOperationsInput | Buffer
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    token_transfer_recipient_address?: NullableStringFieldUpdateOperationsInput | string | null
    token_transfer_amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    token_transfer_memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    smart_contract_clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    smart_contract_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    smart_contract_source_code?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_args?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_1?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_2?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_payload?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_alt_recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type txsCreateManyInput = {
    id?: number
    tx_id: Buffer
    tx_index: number
    raw_result: Buffer
    index_block_hash: Buffer
    block_hash: Buffer
    block_height: number
    parent_block_hash: Buffer
    burn_block_time: number
    parent_burn_block_time: number
    type_id: number
    anchor_mode: number
    status: number
    canonical: boolean
    post_conditions: Buffer
    nonce: number
    fee_rate: bigint | number
    sponsored: boolean
    sponsor_address?: string | null
    sponsor_nonce?: number | null
    sender_address: string
    origin_hash_mode: number
    event_count: number
    execution_cost_read_count: bigint | number
    execution_cost_read_length: bigint | number
    execution_cost_runtime: bigint | number
    execution_cost_write_count: bigint | number
    execution_cost_write_length: bigint | number
    raw_tx: Buffer
    microblock_canonical: boolean
    microblock_sequence: number
    microblock_hash: Buffer
    parent_index_block_hash: Buffer
    token_transfer_recipient_address?: string | null
    token_transfer_amount?: bigint | number | null
    token_transfer_memo?: Buffer | null
    smart_contract_clarity_version?: number | null
    smart_contract_contract_id?: string | null
    smart_contract_source_code?: string | null
    contract_call_contract_id?: string | null
    contract_call_function_name?: string | null
    contract_call_function_args?: Buffer | null
    poison_microblock_header_1?: Buffer | null
    poison_microblock_header_2?: Buffer | null
    coinbase_payload?: Buffer | null
    coinbase_alt_recipient?: string | null
  }

  export type txsUpdateManyMutationInput = {
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    raw_result?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_time?: IntFieldUpdateOperationsInput | number
    parent_burn_block_time?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    anchor_mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    post_conditions?: BytesFieldUpdateOperationsInput | Buffer
    nonce?: IntFieldUpdateOperationsInput | number
    fee_rate?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsor_address?: NullableStringFieldUpdateOperationsInput | string | null
    sponsor_nonce?: NullableIntFieldUpdateOperationsInput | number | null
    sender_address?: StringFieldUpdateOperationsInput | string
    origin_hash_mode?: IntFieldUpdateOperationsInput | number
    event_count?: IntFieldUpdateOperationsInput | number
    execution_cost_read_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_read_length?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_runtime?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_length?: BigIntFieldUpdateOperationsInput | bigint | number
    raw_tx?: BytesFieldUpdateOperationsInput | Buffer
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    token_transfer_recipient_address?: NullableStringFieldUpdateOperationsInput | string | null
    token_transfer_amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    token_transfer_memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    smart_contract_clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    smart_contract_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    smart_contract_source_code?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_args?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_1?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_2?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_payload?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_alt_recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type txsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tx_id?: BytesFieldUpdateOperationsInput | Buffer
    tx_index?: IntFieldUpdateOperationsInput | number
    raw_result?: BytesFieldUpdateOperationsInput | Buffer
    index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_hash?: BytesFieldUpdateOperationsInput | Buffer
    block_height?: IntFieldUpdateOperationsInput | number
    parent_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    burn_block_time?: IntFieldUpdateOperationsInput | number
    parent_burn_block_time?: IntFieldUpdateOperationsInput | number
    type_id?: IntFieldUpdateOperationsInput | number
    anchor_mode?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    canonical?: BoolFieldUpdateOperationsInput | boolean
    post_conditions?: BytesFieldUpdateOperationsInput | Buffer
    nonce?: IntFieldUpdateOperationsInput | number
    fee_rate?: BigIntFieldUpdateOperationsInput | bigint | number
    sponsored?: BoolFieldUpdateOperationsInput | boolean
    sponsor_address?: NullableStringFieldUpdateOperationsInput | string | null
    sponsor_nonce?: NullableIntFieldUpdateOperationsInput | number | null
    sender_address?: StringFieldUpdateOperationsInput | string
    origin_hash_mode?: IntFieldUpdateOperationsInput | number
    event_count?: IntFieldUpdateOperationsInput | number
    execution_cost_read_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_read_length?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_runtime?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_count?: BigIntFieldUpdateOperationsInput | bigint | number
    execution_cost_write_length?: BigIntFieldUpdateOperationsInput | bigint | number
    raw_tx?: BytesFieldUpdateOperationsInput | Buffer
    microblock_canonical?: BoolFieldUpdateOperationsInput | boolean
    microblock_sequence?: IntFieldUpdateOperationsInput | number
    microblock_hash?: BytesFieldUpdateOperationsInput | Buffer
    parent_index_block_hash?: BytesFieldUpdateOperationsInput | Buffer
    token_transfer_recipient_address?: NullableStringFieldUpdateOperationsInput | string | null
    token_transfer_amount?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    token_transfer_memo?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    smart_contract_clarity_version?: NullableIntFieldUpdateOperationsInput | number | null
    smart_contract_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    smart_contract_source_code?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_contract_id?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_name?: NullableStringFieldUpdateOperationsInput | string | null
    contract_call_function_args?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_1?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    poison_microblock_header_2?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_payload?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    coinbase_alt_recipient?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type zonefilesCreateInput = {
    name: string
    zonefile: string
    zonefile_hash: string
    tx_id?: Buffer | null
    index_block_hash?: Buffer | null
  }

  export type zonefilesUncheckedCreateInput = {
    id?: number
    name: string
    zonefile: string
    zonefile_hash: string
    tx_id?: Buffer | null
    index_block_hash?: Buffer | null
  }

  export type zonefilesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    zonefile?: StringFieldUpdateOperationsInput | string
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type zonefilesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    zonefile?: StringFieldUpdateOperationsInput | string
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type zonefilesCreateManyInput = {
    id?: number
    name: string
    zonefile: string
    zonefile_hash: string
    tx_id?: Buffer | null
    index_block_hash?: Buffer | null
  }

  export type zonefilesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    zonefile?: StringFieldUpdateOperationsInput | string
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type zonefilesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    zonefile?: StringFieldUpdateOperationsInput | string
    zonefile_hash?: StringFieldUpdateOperationsInput | string
    tx_id?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    index_block_hash?: NullableBytesFieldUpdateOperationsInput | Buffer | null
  }

  export type BytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesFilter | Buffer
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type BigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type blocksCountOrderByAggregateInput = {
    index_block_hash?: SortOrder
    block_hash?: SortOrder
    block_height?: SortOrder
    burn_block_time?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    miner_txid?: SortOrder
    parent_index_block_hash?: SortOrder
    parent_block_hash?: SortOrder
    parent_microblock_hash?: SortOrder
    parent_microblock_sequence?: SortOrder
    canonical?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
  }

  export type blocksAvgOrderByAggregateInput = {
    block_height?: SortOrder
    burn_block_time?: SortOrder
    burn_block_height?: SortOrder
    parent_microblock_sequence?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
  }

  export type blocksMaxOrderByAggregateInput = {
    index_block_hash?: SortOrder
    block_hash?: SortOrder
    block_height?: SortOrder
    burn_block_time?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    miner_txid?: SortOrder
    parent_index_block_hash?: SortOrder
    parent_block_hash?: SortOrder
    parent_microblock_hash?: SortOrder
    parent_microblock_sequence?: SortOrder
    canonical?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
  }

  export type blocksMinOrderByAggregateInput = {
    index_block_hash?: SortOrder
    block_hash?: SortOrder
    block_height?: SortOrder
    burn_block_time?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    miner_txid?: SortOrder
    parent_index_block_hash?: SortOrder
    parent_block_hash?: SortOrder
    parent_microblock_hash?: SortOrder
    parent_microblock_sequence?: SortOrder
    canonical?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
  }

  export type blocksSumOrderByAggregateInput = {
    block_height?: SortOrder
    burn_block_time?: SortOrder
    burn_block_height?: SortOrder
    parent_microblock_sequence?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
  }

  export type BytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type BigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type burnchain_rewardsCountOrderByAggregateInput = {
    id?: SortOrder
    canonical?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    burn_amount?: SortOrder
    reward_recipient?: SortOrder
    reward_amount?: SortOrder
    reward_index?: SortOrder
  }

  export type burnchain_rewardsAvgOrderByAggregateInput = {
    id?: SortOrder
    burn_block_height?: SortOrder
    burn_amount?: SortOrder
    reward_amount?: SortOrder
    reward_index?: SortOrder
  }

  export type burnchain_rewardsMaxOrderByAggregateInput = {
    id?: SortOrder
    canonical?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    burn_amount?: SortOrder
    reward_recipient?: SortOrder
    reward_amount?: SortOrder
    reward_index?: SortOrder
  }

  export type burnchain_rewardsMinOrderByAggregateInput = {
    id?: SortOrder
    canonical?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    burn_amount?: SortOrder
    reward_recipient?: SortOrder
    reward_amount?: SortOrder
    reward_index?: SortOrder
  }

  export type burnchain_rewardsSumOrderByAggregateInput = {
    id?: SortOrder
    burn_block_height?: SortOrder
    burn_amount?: SortOrder
    reward_amount?: SortOrder
    reward_index?: SortOrder
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type config_stateCountOrderByAggregateInput = {
    id?: SortOrder
    bns_names_onchain_imported?: SortOrder
    bns_subdomains_imported?: SortOrder
    token_offering_imported?: SortOrder
  }

  export type config_stateMaxOrderByAggregateInput = {
    id?: SortOrder
    bns_names_onchain_imported?: SortOrder
    bns_subdomains_imported?: SortOrder
    token_offering_imported?: SortOrder
  }

  export type config_stateMinOrderByAggregateInput = {
    id?: SortOrder
    bns_names_onchain_imported?: SortOrder
    bns_subdomains_imported?: SortOrder
    token_offering_imported?: SortOrder
  }

  export type ContractLogsCountOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    contract_identifier?: SortOrder
    topic?: SortOrder
    value?: SortOrder
  }

  export type ContractLogsAvgOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
  }

  export type ContractLogsMaxOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    contract_identifier?: SortOrder
    topic?: SortOrder
    value?: SortOrder
  }

  export type ContractLogsMinOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    contract_identifier?: SortOrder
    topic?: SortOrder
    value?: SortOrder
  }

  export type ContractLogsSumOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }
  export type JsonFilter = 
    | PatchUndefined<
        Either<Required<JsonFilterBase>, Exclude<keyof Required<JsonFilterBase>, 'path'>>,
        Required<JsonFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase>, 'path'>>

  export type JsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type event_observer_requestsCountOrderByAggregateInput = {
    id?: SortOrder
    receive_timestamp?: SortOrder
    event_path?: SortOrder
    payload?: SortOrder
  }

  export type event_observer_requestsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type event_observer_requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    receive_timestamp?: SortOrder
    event_path?: SortOrder
  }

  export type event_observer_requestsMinOrderByAggregateInput = {
    id?: SortOrder
    receive_timestamp?: SortOrder
    event_path?: SortOrder
  }

  export type event_observer_requestsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }
  export type JsonWithAggregatesFilter = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase>, Exclude<keyof Required<JsonWithAggregatesFilterBase>, 'path'>>,
        Required<JsonWithAggregatesFilterBase>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase>, 'path'>>

  export type JsonWithAggregatesFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
    _count?: NestedIntFilter
    _min?: NestedJsonFilter
    _max?: NestedJsonFilter
  }

  export type faucet_requestsCountOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    ip?: SortOrder
    occurred_at?: SortOrder
  }

  export type faucet_requestsAvgOrderByAggregateInput = {
    id?: SortOrder
    occurred_at?: SortOrder
  }

  export type faucet_requestsMaxOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    ip?: SortOrder
    occurred_at?: SortOrder
  }

  export type faucet_requestsMinOrderByAggregateInput = {
    id?: SortOrder
    currency?: SortOrder
    address?: SortOrder
    ip?: SortOrder
    occurred_at?: SortOrder
  }

  export type faucet_requestsSumOrderByAggregateInput = {
    id?: SortOrder
    occurred_at?: SortOrder
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type ft_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    asset_identifier?: SortOrder
    amount?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
  }

  export type ft_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    asset_event_type_id?: SortOrder
    amount?: SortOrder
  }

  export type ft_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    asset_identifier?: SortOrder
    amount?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
  }

  export type ft_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    asset_identifier?: SortOrder
    amount?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
  }

  export type ft_eventsSumOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    asset_event_type_id?: SortOrder
    amount?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type ft_metadataCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token_uri?: SortOrder
    description?: SortOrder
    image_uri?: SortOrder
    image_canonical_uri?: SortOrder
    contract_id?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    tx_id?: SortOrder
    sender_address?: SortOrder
  }

  export type ft_metadataAvgOrderByAggregateInput = {
    id?: SortOrder
    decimals?: SortOrder
  }

  export type ft_metadataMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token_uri?: SortOrder
    description?: SortOrder
    image_uri?: SortOrder
    image_canonical_uri?: SortOrder
    contract_id?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    tx_id?: SortOrder
    sender_address?: SortOrder
  }

  export type ft_metadataMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token_uri?: SortOrder
    description?: SortOrder
    image_uri?: SortOrder
    image_canonical_uri?: SortOrder
    contract_id?: SortOrder
    symbol?: SortOrder
    decimals?: SortOrder
    tx_id?: SortOrder
    sender_address?: SortOrder
  }

  export type ft_metadataSumOrderByAggregateInput = {
    id?: SortOrder
    decimals?: SortOrder
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type BytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type mempool_txsCountOrderByAggregateInput = {
    id?: SortOrder
    pruned?: SortOrder
    tx_id?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    post_conditions?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsored?: SortOrder
    sponsor_address?: SortOrder
    sponsor_nonce?: SortOrder
    sender_address?: SortOrder
    origin_hash_mode?: SortOrder
    raw_tx?: SortOrder
    receipt_time?: SortOrder
    receipt_block_height?: SortOrder
    token_transfer_recipient_address?: SortOrder
    token_transfer_amount?: SortOrder
    token_transfer_memo?: SortOrder
    smart_contract_clarity_version?: SortOrder
    smart_contract_contract_id?: SortOrder
    smart_contract_source_code?: SortOrder
    contract_call_contract_id?: SortOrder
    contract_call_function_name?: SortOrder
    contract_call_function_args?: SortOrder
    poison_microblock_header_1?: SortOrder
    poison_microblock_header_2?: SortOrder
    coinbase_payload?: SortOrder
    coinbase_alt_recipient?: SortOrder
    tx_size?: SortOrder
  }

  export type mempool_txsAvgOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsor_nonce?: SortOrder
    origin_hash_mode?: SortOrder
    receipt_time?: SortOrder
    receipt_block_height?: SortOrder
    token_transfer_amount?: SortOrder
    smart_contract_clarity_version?: SortOrder
    tx_size?: SortOrder
  }

  export type mempool_txsMaxOrderByAggregateInput = {
    id?: SortOrder
    pruned?: SortOrder
    tx_id?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    post_conditions?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsored?: SortOrder
    sponsor_address?: SortOrder
    sponsor_nonce?: SortOrder
    sender_address?: SortOrder
    origin_hash_mode?: SortOrder
    raw_tx?: SortOrder
    receipt_time?: SortOrder
    receipt_block_height?: SortOrder
    token_transfer_recipient_address?: SortOrder
    token_transfer_amount?: SortOrder
    token_transfer_memo?: SortOrder
    smart_contract_clarity_version?: SortOrder
    smart_contract_contract_id?: SortOrder
    smart_contract_source_code?: SortOrder
    contract_call_contract_id?: SortOrder
    contract_call_function_name?: SortOrder
    contract_call_function_args?: SortOrder
    poison_microblock_header_1?: SortOrder
    poison_microblock_header_2?: SortOrder
    coinbase_payload?: SortOrder
    coinbase_alt_recipient?: SortOrder
    tx_size?: SortOrder
  }

  export type mempool_txsMinOrderByAggregateInput = {
    id?: SortOrder
    pruned?: SortOrder
    tx_id?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    post_conditions?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsored?: SortOrder
    sponsor_address?: SortOrder
    sponsor_nonce?: SortOrder
    sender_address?: SortOrder
    origin_hash_mode?: SortOrder
    raw_tx?: SortOrder
    receipt_time?: SortOrder
    receipt_block_height?: SortOrder
    token_transfer_recipient_address?: SortOrder
    token_transfer_amount?: SortOrder
    token_transfer_memo?: SortOrder
    smart_contract_clarity_version?: SortOrder
    smart_contract_contract_id?: SortOrder
    smart_contract_source_code?: SortOrder
    contract_call_contract_id?: SortOrder
    contract_call_function_name?: SortOrder
    contract_call_function_args?: SortOrder
    poison_microblock_header_1?: SortOrder
    poison_microblock_header_2?: SortOrder
    coinbase_payload?: SortOrder
    coinbase_alt_recipient?: SortOrder
    tx_size?: SortOrder
  }

  export type mempool_txsSumOrderByAggregateInput = {
    id?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsor_nonce?: SortOrder
    origin_hash_mode?: SortOrder
    receipt_time?: SortOrder
    receipt_block_height?: SortOrder
    token_transfer_amount?: SortOrder
    smart_contract_clarity_version?: SortOrder
    tx_size?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type BigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type BytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type microblocksCountOrderByAggregateInput = {
    id?: SortOrder
    receive_timestamp?: SortOrder
    canonical?: SortOrder
    microblock_canonical?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_parent_hash?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    block_height?: SortOrder
    parent_block_height?: SortOrder
    parent_block_hash?: SortOrder
    parent_burn_block_height?: SortOrder
    parent_burn_block_time?: SortOrder
    parent_burn_block_hash?: SortOrder
    block_hash?: SortOrder
  }

  export type microblocksAvgOrderByAggregateInput = {
    id?: SortOrder
    microblock_sequence?: SortOrder
    block_height?: SortOrder
    parent_block_height?: SortOrder
    parent_burn_block_height?: SortOrder
    parent_burn_block_time?: SortOrder
  }

  export type microblocksMaxOrderByAggregateInput = {
    id?: SortOrder
    receive_timestamp?: SortOrder
    canonical?: SortOrder
    microblock_canonical?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_parent_hash?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    block_height?: SortOrder
    parent_block_height?: SortOrder
    parent_block_hash?: SortOrder
    parent_burn_block_height?: SortOrder
    parent_burn_block_time?: SortOrder
    parent_burn_block_hash?: SortOrder
    block_hash?: SortOrder
  }

  export type microblocksMinOrderByAggregateInput = {
    id?: SortOrder
    receive_timestamp?: SortOrder
    canonical?: SortOrder
    microblock_canonical?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_parent_hash?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    block_height?: SortOrder
    parent_block_height?: SortOrder
    parent_block_hash?: SortOrder
    parent_burn_block_height?: SortOrder
    parent_burn_block_time?: SortOrder
    parent_burn_block_hash?: SortOrder
    block_hash?: SortOrder
  }

  export type microblocksSumOrderByAggregateInput = {
    id?: SortOrder
    microblock_sequence?: SortOrder
    block_height?: SortOrder
    parent_block_height?: SortOrder
    parent_burn_block_height?: SortOrder
    parent_burn_block_time?: SortOrder
  }

  export type miner_rewardsCountOrderByAggregateInput = {
    id?: SortOrder
    block_hash?: SortOrder
    index_block_hash?: SortOrder
    from_index_block_hash?: SortOrder
    mature_block_height?: SortOrder
    canonical?: SortOrder
    recipient?: SortOrder
    miner_address?: SortOrder
    coinbase_amount?: SortOrder
    tx_fees_anchored?: SortOrder
    tx_fees_streamed_confirmed?: SortOrder
    tx_fees_streamed_produced?: SortOrder
  }

  export type miner_rewardsAvgOrderByAggregateInput = {
    id?: SortOrder
    mature_block_height?: SortOrder
    coinbase_amount?: SortOrder
    tx_fees_anchored?: SortOrder
    tx_fees_streamed_confirmed?: SortOrder
    tx_fees_streamed_produced?: SortOrder
  }

  export type miner_rewardsMaxOrderByAggregateInput = {
    id?: SortOrder
    block_hash?: SortOrder
    index_block_hash?: SortOrder
    from_index_block_hash?: SortOrder
    mature_block_height?: SortOrder
    canonical?: SortOrder
    recipient?: SortOrder
    miner_address?: SortOrder
    coinbase_amount?: SortOrder
    tx_fees_anchored?: SortOrder
    tx_fees_streamed_confirmed?: SortOrder
    tx_fees_streamed_produced?: SortOrder
  }

  export type miner_rewardsMinOrderByAggregateInput = {
    id?: SortOrder
    block_hash?: SortOrder
    index_block_hash?: SortOrder
    from_index_block_hash?: SortOrder
    mature_block_height?: SortOrder
    canonical?: SortOrder
    recipient?: SortOrder
    miner_address?: SortOrder
    coinbase_amount?: SortOrder
    tx_fees_anchored?: SortOrder
    tx_fees_streamed_confirmed?: SortOrder
    tx_fees_streamed_produced?: SortOrder
  }

  export type miner_rewardsSumOrderByAggregateInput = {
    id?: SortOrder
    mature_block_height?: SortOrder
    coinbase_amount?: SortOrder
    tx_fees_anchored?: SortOrder
    tx_fees_streamed_confirmed?: SortOrder
    tx_fees_streamed_produced?: SortOrder
  }

  export type namesNameTx_idIndex_block_hashMicroblock_hashEvent_indexCompoundUniqueInput = {
    name: string
    tx_id: Buffer
    index_block_hash: Buffer
    microblock_hash: Buffer
    event_index: number
  }

  export type namesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    registered_at?: SortOrder
    expire_block?: SortOrder
    zonefile_hash?: SortOrder
    namespace_id?: SortOrder
    grace_period?: SortOrder
    renewal_deadline?: SortOrder
    resolver?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    event_index?: SortOrder
    status?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type namesAvgOrderByAggregateInput = {
    id?: SortOrder
    registered_at?: SortOrder
    expire_block?: SortOrder
    renewal_deadline?: SortOrder
    tx_index?: SortOrder
    event_index?: SortOrder
    microblock_sequence?: SortOrder
  }

  export type namesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    registered_at?: SortOrder
    expire_block?: SortOrder
    zonefile_hash?: SortOrder
    namespace_id?: SortOrder
    grace_period?: SortOrder
    renewal_deadline?: SortOrder
    resolver?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    event_index?: SortOrder
    status?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type namesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    registered_at?: SortOrder
    expire_block?: SortOrder
    zonefile_hash?: SortOrder
    namespace_id?: SortOrder
    grace_period?: SortOrder
    renewal_deadline?: SortOrder
    resolver?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    event_index?: SortOrder
    status?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type namesSumOrderByAggregateInput = {
    id?: SortOrder
    registered_at?: SortOrder
    expire_block?: SortOrder
    renewal_deadline?: SortOrder
    tx_index?: SortOrder
    event_index?: SortOrder
    microblock_sequence?: SortOrder
  }

  export type namespacesNamespace_idTx_idIndex_block_hashMicroblock_hashCompoundUniqueInput = {
    namespace_id: string
    tx_id: Buffer
    index_block_hash: Buffer
    microblock_hash: Buffer
  }

  export type namespacesCountOrderByAggregateInput = {
    id?: SortOrder
    namespace_id?: SortOrder
    launched_at?: SortOrder
    address?: SortOrder
    reveal_block?: SortOrder
    ready_block?: SortOrder
    buckets?: SortOrder
    base?: SortOrder
    coeff?: SortOrder
    nonalpha_discount?: SortOrder
    no_vowel_discount?: SortOrder
    lifetime?: SortOrder
    status?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type namespacesAvgOrderByAggregateInput = {
    id?: SortOrder
    launched_at?: SortOrder
    reveal_block?: SortOrder
    ready_block?: SortOrder
    base?: SortOrder
    coeff?: SortOrder
    nonalpha_discount?: SortOrder
    no_vowel_discount?: SortOrder
    lifetime?: SortOrder
    tx_index?: SortOrder
    microblock_sequence?: SortOrder
  }

  export type namespacesMaxOrderByAggregateInput = {
    id?: SortOrder
    namespace_id?: SortOrder
    launched_at?: SortOrder
    address?: SortOrder
    reveal_block?: SortOrder
    ready_block?: SortOrder
    buckets?: SortOrder
    base?: SortOrder
    coeff?: SortOrder
    nonalpha_discount?: SortOrder
    no_vowel_discount?: SortOrder
    lifetime?: SortOrder
    status?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type namespacesMinOrderByAggregateInput = {
    id?: SortOrder
    namespace_id?: SortOrder
    launched_at?: SortOrder
    address?: SortOrder
    reveal_block?: SortOrder
    ready_block?: SortOrder
    buckets?: SortOrder
    base?: SortOrder
    coeff?: SortOrder
    nonalpha_discount?: SortOrder
    no_vowel_discount?: SortOrder
    lifetime?: SortOrder
    status?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type namespacesSumOrderByAggregateInput = {
    id?: SortOrder
    launched_at?: SortOrder
    reveal_block?: SortOrder
    ready_block?: SortOrder
    base?: SortOrder
    coeff?: SortOrder
    nonalpha_discount?: SortOrder
    no_vowel_discount?: SortOrder
    lifetime?: SortOrder
    tx_index?: SortOrder
    microblock_sequence?: SortOrder
  }

  export type nft_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    asset_identifier?: SortOrder
    value?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
  }

  export type nft_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    asset_event_type_id?: SortOrder
  }

  export type nft_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    asset_identifier?: SortOrder
    value?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
  }

  export type nft_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    asset_identifier?: SortOrder
    value?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
  }

  export type nft_eventsSumOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    asset_event_type_id?: SortOrder
  }

  export type nft_metadataCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token_uri?: SortOrder
    description?: SortOrder
    image_uri?: SortOrder
    image_canonical_uri?: SortOrder
    contract_id?: SortOrder
    tx_id?: SortOrder
    sender_address?: SortOrder
  }

  export type nft_metadataAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type nft_metadataMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token_uri?: SortOrder
    description?: SortOrder
    image_uri?: SortOrder
    image_canonical_uri?: SortOrder
    contract_id?: SortOrder
    tx_id?: SortOrder
    sender_address?: SortOrder
  }

  export type nft_metadataMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token_uri?: SortOrder
    description?: SortOrder
    image_uri?: SortOrder
    image_canonical_uri?: SortOrder
    contract_id?: SortOrder
    tx_id?: SortOrder
    sender_address?: SortOrder
  }

  export type nft_metadataSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pgmigrationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    run_on?: SortOrder
  }

  export type pgmigrationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type pgmigrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    run_on?: SortOrder
  }

  export type pgmigrationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    run_on?: SortOrder
  }

  export type pgmigrationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type pox2_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    stacker?: SortOrder
    locked?: SortOrder
    balance?: SortOrder
    burnchain_unlock_height?: SortOrder
    name?: SortOrder
    pox_addr?: SortOrder
    pox_addr_raw?: SortOrder
    first_cycle_locked?: SortOrder
    first_unlocked_cycle?: SortOrder
    lock_period?: SortOrder
    lock_amount?: SortOrder
    start_burn_height?: SortOrder
    unlock_burn_height?: SortOrder
    delegator?: SortOrder
    increase_by?: SortOrder
    total_locked?: SortOrder
    extend_count?: SortOrder
    reward_cycle?: SortOrder
    amount_ustx?: SortOrder
  }

  export type pox2_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    locked?: SortOrder
    balance?: SortOrder
    burnchain_unlock_height?: SortOrder
    first_cycle_locked?: SortOrder
    first_unlocked_cycle?: SortOrder
    lock_period?: SortOrder
    lock_amount?: SortOrder
    start_burn_height?: SortOrder
    unlock_burn_height?: SortOrder
    increase_by?: SortOrder
    total_locked?: SortOrder
    extend_count?: SortOrder
    reward_cycle?: SortOrder
    amount_ustx?: SortOrder
  }

  export type pox2_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    stacker?: SortOrder
    locked?: SortOrder
    balance?: SortOrder
    burnchain_unlock_height?: SortOrder
    name?: SortOrder
    pox_addr?: SortOrder
    pox_addr_raw?: SortOrder
    first_cycle_locked?: SortOrder
    first_unlocked_cycle?: SortOrder
    lock_period?: SortOrder
    lock_amount?: SortOrder
    start_burn_height?: SortOrder
    unlock_burn_height?: SortOrder
    delegator?: SortOrder
    increase_by?: SortOrder
    total_locked?: SortOrder
    extend_count?: SortOrder
    reward_cycle?: SortOrder
    amount_ustx?: SortOrder
  }

  export type pox2_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    stacker?: SortOrder
    locked?: SortOrder
    balance?: SortOrder
    burnchain_unlock_height?: SortOrder
    name?: SortOrder
    pox_addr?: SortOrder
    pox_addr_raw?: SortOrder
    first_cycle_locked?: SortOrder
    first_unlocked_cycle?: SortOrder
    lock_period?: SortOrder
    lock_amount?: SortOrder
    start_burn_height?: SortOrder
    unlock_burn_height?: SortOrder
    delegator?: SortOrder
    increase_by?: SortOrder
    total_locked?: SortOrder
    extend_count?: SortOrder
    reward_cycle?: SortOrder
    amount_ustx?: SortOrder
  }

  export type pox2_eventsSumOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    locked?: SortOrder
    balance?: SortOrder
    burnchain_unlock_height?: SortOrder
    first_cycle_locked?: SortOrder
    first_unlocked_cycle?: SortOrder
    lock_period?: SortOrder
    lock_amount?: SortOrder
    start_burn_height?: SortOrder
    unlock_burn_height?: SortOrder
    increase_by?: SortOrder
    total_locked?: SortOrder
    extend_count?: SortOrder
    reward_cycle?: SortOrder
    amount_ustx?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type pox_stateCountOrderByAggregateInput = {
    id?: SortOrder
    pox_v1_unlock_height?: SortOrder
  }

  export type pox_stateAvgOrderByAggregateInput = {
    pox_v1_unlock_height?: SortOrder
  }

  export type pox_stateMaxOrderByAggregateInput = {
    id?: SortOrder
    pox_v1_unlock_height?: SortOrder
  }

  export type pox_stateMinOrderByAggregateInput = {
    id?: SortOrder
    pox_v1_unlock_height?: SortOrder
  }

  export type pox_stateSumOrderByAggregateInput = {
    pox_v1_unlock_height?: SortOrder
  }

  export type principal_stx_txsPrincipalTx_idIndex_block_hashMicroblock_hashCompoundUniqueInput = {
    principal: string
    tx_id: Buffer
    index_block_hash: Buffer
    microblock_hash: Buffer
  }

  export type principal_stx_txsCountOrderByAggregateInput = {
    id?: SortOrder
    principal?: SortOrder
    tx_id?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    tx_index?: SortOrder
    canonical?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type principal_stx_txsAvgOrderByAggregateInput = {
    id?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    tx_index?: SortOrder
  }

  export type principal_stx_txsMaxOrderByAggregateInput = {
    id?: SortOrder
    principal?: SortOrder
    tx_id?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    tx_index?: SortOrder
    canonical?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type principal_stx_txsMinOrderByAggregateInput = {
    id?: SortOrder
    principal?: SortOrder
    tx_id?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    tx_index?: SortOrder
    canonical?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type principal_stx_txsSumOrderByAggregateInput = {
    id?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    tx_index?: SortOrder
  }

  export type reward_slot_holdersCountOrderByAggregateInput = {
    id?: SortOrder
    canonical?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    address?: SortOrder
    slot_index?: SortOrder
  }

  export type reward_slot_holdersAvgOrderByAggregateInput = {
    id?: SortOrder
    burn_block_height?: SortOrder
    slot_index?: SortOrder
  }

  export type reward_slot_holdersMaxOrderByAggregateInput = {
    id?: SortOrder
    canonical?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    address?: SortOrder
    slot_index?: SortOrder
  }

  export type reward_slot_holdersMinOrderByAggregateInput = {
    id?: SortOrder
    canonical?: SortOrder
    burn_block_hash?: SortOrder
    burn_block_height?: SortOrder
    address?: SortOrder
    slot_index?: SortOrder
  }

  export type reward_slot_holdersSumOrderByAggregateInput = {
    id?: SortOrder
    burn_block_height?: SortOrder
    slot_index?: SortOrder
  }

  export type smart_contractsCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    canonical?: SortOrder
    contract_id?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    clarity_version?: SortOrder
    source_code?: SortOrder
    abi?: SortOrder
  }

  export type smart_contractsAvgOrderByAggregateInput = {
    id?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    clarity_version?: SortOrder
  }

  export type smart_contractsMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    canonical?: SortOrder
    contract_id?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    clarity_version?: SortOrder
    source_code?: SortOrder
  }

  export type smart_contractsMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    canonical?: SortOrder
    contract_id?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    clarity_version?: SortOrder
    source_code?: SortOrder
  }

  export type smart_contractsSumOrderByAggregateInput = {
    id?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    clarity_version?: SortOrder
  }

  export type stx_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    amount?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    memo?: SortOrder
  }

  export type stx_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    asset_event_type_id?: SortOrder
    amount?: SortOrder
  }

  export type stx_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    amount?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    memo?: SortOrder
  }

  export type stx_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    asset_event_type_id?: SortOrder
    amount?: SortOrder
    sender?: SortOrder
    recipient?: SortOrder
    memo?: SortOrder
  }

  export type stx_eventsSumOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    asset_event_type_id?: SortOrder
    amount?: SortOrder
  }

  export type stx_lock_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    locked_amount?: SortOrder
    unlock_height?: SortOrder
    locked_address?: SortOrder
    contract_name?: SortOrder
  }

  export type stx_lock_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    locked_amount?: SortOrder
    unlock_height?: SortOrder
  }

  export type stx_lock_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    locked_amount?: SortOrder
    unlock_height?: SortOrder
    locked_address?: SortOrder
    contract_name?: SortOrder
  }

  export type stx_lock_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
    canonical?: SortOrder
    locked_amount?: SortOrder
    unlock_height?: SortOrder
    locked_address?: SortOrder
    contract_name?: SortOrder
  }

  export type stx_lock_eventsSumOrderByAggregateInput = {
    id?: SortOrder
    event_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    microblock_sequence?: SortOrder
    locked_amount?: SortOrder
    unlock_height?: SortOrder
  }

  export type subdomainsFully_qualified_subdomainTx_idIndex_block_hashMicroblock_hashCompoundUniqueInput = {
    fully_qualified_subdomain: string
    tx_id: Buffer
    index_block_hash: Buffer
    microblock_hash: Buffer
  }

  export type subdomainsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    namespace_id?: SortOrder
    fully_qualified_subdomain?: SortOrder
    owner?: SortOrder
    zonefile_hash?: SortOrder
    parent_zonefile_hash?: SortOrder
    parent_zonefile_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    zonefile_offset?: SortOrder
    resolver?: SortOrder
    tx_id?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type subdomainsAvgOrderByAggregateInput = {
    id?: SortOrder
    parent_zonefile_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    zonefile_offset?: SortOrder
    microblock_sequence?: SortOrder
  }

  export type subdomainsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    namespace_id?: SortOrder
    fully_qualified_subdomain?: SortOrder
    owner?: SortOrder
    zonefile_hash?: SortOrder
    parent_zonefile_hash?: SortOrder
    parent_zonefile_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    zonefile_offset?: SortOrder
    resolver?: SortOrder
    tx_id?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type subdomainsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    namespace_id?: SortOrder
    fully_qualified_subdomain?: SortOrder
    owner?: SortOrder
    zonefile_hash?: SortOrder
    parent_zonefile_hash?: SortOrder
    parent_zonefile_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    zonefile_offset?: SortOrder
    resolver?: SortOrder
    tx_id?: SortOrder
    canonical?: SortOrder
    index_block_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    microblock_hash?: SortOrder
    microblock_sequence?: SortOrder
    microblock_canonical?: SortOrder
  }

  export type subdomainsSumOrderByAggregateInput = {
    id?: SortOrder
    parent_zonefile_index?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    zonefile_offset?: SortOrder
    microblock_sequence?: SortOrder
  }

  export type token_metadata_queueCountOrderByAggregateInput = {
    queue_id?: SortOrder
    tx_id?: SortOrder
    contract_id?: SortOrder
    contract_abi?: SortOrder
    block_height?: SortOrder
    processed?: SortOrder
    retry_count?: SortOrder
  }

  export type token_metadata_queueAvgOrderByAggregateInput = {
    queue_id?: SortOrder
    block_height?: SortOrder
    retry_count?: SortOrder
  }

  export type token_metadata_queueMaxOrderByAggregateInput = {
    queue_id?: SortOrder
    tx_id?: SortOrder
    contract_id?: SortOrder
    contract_abi?: SortOrder
    block_height?: SortOrder
    processed?: SortOrder
    retry_count?: SortOrder
  }

  export type token_metadata_queueMinOrderByAggregateInput = {
    queue_id?: SortOrder
    tx_id?: SortOrder
    contract_id?: SortOrder
    contract_abi?: SortOrder
    block_height?: SortOrder
    processed?: SortOrder
    retry_count?: SortOrder
  }

  export type token_metadata_queueSumOrderByAggregateInput = {
    queue_id?: SortOrder
    block_height?: SortOrder
    retry_count?: SortOrder
  }

  export type token_offering_lockedCountOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    block?: SortOrder
  }

  export type token_offering_lockedAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    block?: SortOrder
  }

  export type token_offering_lockedMaxOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    block?: SortOrder
  }

  export type token_offering_lockedMinOrderByAggregateInput = {
    id?: SortOrder
    address?: SortOrder
    value?: SortOrder
    block?: SortOrder
  }

  export type token_offering_lockedSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    block?: SortOrder
  }

  export type txsTx_idIndex_block_hashMicroblock_hashCompoundUniqueInput = {
    tx_id: Buffer
    index_block_hash: Buffer
    microblock_hash: Buffer
  }

  export type txsCountOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    raw_result?: SortOrder
    index_block_hash?: SortOrder
    block_hash?: SortOrder
    block_height?: SortOrder
    parent_block_hash?: SortOrder
    burn_block_time?: SortOrder
    parent_burn_block_time?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    canonical?: SortOrder
    post_conditions?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsored?: SortOrder
    sponsor_address?: SortOrder
    sponsor_nonce?: SortOrder
    sender_address?: SortOrder
    origin_hash_mode?: SortOrder
    event_count?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
    raw_tx?: SortOrder
    microblock_canonical?: SortOrder
    microblock_sequence?: SortOrder
    microblock_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    token_transfer_recipient_address?: SortOrder
    token_transfer_amount?: SortOrder
    token_transfer_memo?: SortOrder
    smart_contract_clarity_version?: SortOrder
    smart_contract_contract_id?: SortOrder
    smart_contract_source_code?: SortOrder
    contract_call_contract_id?: SortOrder
    contract_call_function_name?: SortOrder
    contract_call_function_args?: SortOrder
    poison_microblock_header_1?: SortOrder
    poison_microblock_header_2?: SortOrder
    coinbase_payload?: SortOrder
    coinbase_alt_recipient?: SortOrder
  }

  export type txsAvgOrderByAggregateInput = {
    id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    burn_block_time?: SortOrder
    parent_burn_block_time?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsor_nonce?: SortOrder
    origin_hash_mode?: SortOrder
    event_count?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
    microblock_sequence?: SortOrder
    token_transfer_amount?: SortOrder
    smart_contract_clarity_version?: SortOrder
  }

  export type txsMaxOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    raw_result?: SortOrder
    index_block_hash?: SortOrder
    block_hash?: SortOrder
    block_height?: SortOrder
    parent_block_hash?: SortOrder
    burn_block_time?: SortOrder
    parent_burn_block_time?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    canonical?: SortOrder
    post_conditions?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsored?: SortOrder
    sponsor_address?: SortOrder
    sponsor_nonce?: SortOrder
    sender_address?: SortOrder
    origin_hash_mode?: SortOrder
    event_count?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
    raw_tx?: SortOrder
    microblock_canonical?: SortOrder
    microblock_sequence?: SortOrder
    microblock_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    token_transfer_recipient_address?: SortOrder
    token_transfer_amount?: SortOrder
    token_transfer_memo?: SortOrder
    smart_contract_clarity_version?: SortOrder
    smart_contract_contract_id?: SortOrder
    smart_contract_source_code?: SortOrder
    contract_call_contract_id?: SortOrder
    contract_call_function_name?: SortOrder
    contract_call_function_args?: SortOrder
    poison_microblock_header_1?: SortOrder
    poison_microblock_header_2?: SortOrder
    coinbase_payload?: SortOrder
    coinbase_alt_recipient?: SortOrder
  }

  export type txsMinOrderByAggregateInput = {
    id?: SortOrder
    tx_id?: SortOrder
    tx_index?: SortOrder
    raw_result?: SortOrder
    index_block_hash?: SortOrder
    block_hash?: SortOrder
    block_height?: SortOrder
    parent_block_hash?: SortOrder
    burn_block_time?: SortOrder
    parent_burn_block_time?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    canonical?: SortOrder
    post_conditions?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsored?: SortOrder
    sponsor_address?: SortOrder
    sponsor_nonce?: SortOrder
    sender_address?: SortOrder
    origin_hash_mode?: SortOrder
    event_count?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
    raw_tx?: SortOrder
    microblock_canonical?: SortOrder
    microblock_sequence?: SortOrder
    microblock_hash?: SortOrder
    parent_index_block_hash?: SortOrder
    token_transfer_recipient_address?: SortOrder
    token_transfer_amount?: SortOrder
    token_transfer_memo?: SortOrder
    smart_contract_clarity_version?: SortOrder
    smart_contract_contract_id?: SortOrder
    smart_contract_source_code?: SortOrder
    contract_call_contract_id?: SortOrder
    contract_call_function_name?: SortOrder
    contract_call_function_args?: SortOrder
    poison_microblock_header_1?: SortOrder
    poison_microblock_header_2?: SortOrder
    coinbase_payload?: SortOrder
    coinbase_alt_recipient?: SortOrder
  }

  export type txsSumOrderByAggregateInput = {
    id?: SortOrder
    tx_index?: SortOrder
    block_height?: SortOrder
    burn_block_time?: SortOrder
    parent_burn_block_time?: SortOrder
    type_id?: SortOrder
    anchor_mode?: SortOrder
    status?: SortOrder
    nonce?: SortOrder
    fee_rate?: SortOrder
    sponsor_nonce?: SortOrder
    origin_hash_mode?: SortOrder
    event_count?: SortOrder
    execution_cost_read_count?: SortOrder
    execution_cost_read_length?: SortOrder
    execution_cost_runtime?: SortOrder
    execution_cost_write_count?: SortOrder
    execution_cost_write_length?: SortOrder
    microblock_sequence?: SortOrder
    token_transfer_amount?: SortOrder
    smart_contract_clarity_version?: SortOrder
  }

  export type zonefilesNameZonefile_hashTx_idIndex_block_hashCompoundUniqueInput = {
    name: string
    zonefile_hash: string
    tx_id: Buffer
    index_block_hash: Buffer
  }

  export type zonefilesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    zonefile?: SortOrder
    zonefile_hash?: SortOrder
    tx_id?: SortOrder
    index_block_hash?: SortOrder
  }

  export type zonefilesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type zonefilesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    zonefile?: SortOrder
    zonefile_hash?: SortOrder
    tx_id?: SortOrder
    index_block_hash?: SortOrder
  }

  export type zonefilesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    zonefile?: SortOrder
    zonefile_hash?: SortOrder
    tx_id?: SortOrder
    index_block_hash?: SortOrder
  }

  export type zonefilesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NestedBytesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesFilter | Buffer
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBigIntFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntFilter | bigint | number
  }

  export type NestedBytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Enumerable<Buffer>
    notIn?: Enumerable<Buffer>
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedBigIntWithAggregatesFilter = {
    equals?: bigint | number
    in?: Enumerable<bigint> | Enumerable<number>
    notIn?: Enumerable<bigint> | Enumerable<number>
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntWithAggregatesFilter | bigint | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedBigIntFilter
    _min?: NestedBigIntFilter
    _max?: NestedBigIntFilter
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }
  export type NestedJsonFilter = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase>, Exclude<keyof Required<NestedJsonFilterBase>, 'path'>>,
        Required<NestedJsonFilterBase>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase>, 'path'>>

  export type NestedJsonFilterBase = {
    equals?: InputJsonValue | JsonNullValueFilter
    path?: Array<string>
    string_contains?: string
    string_starts_with?: string
    string_ends_with?: string
    array_contains?: InputJsonValue | null
    array_starts_with?: InputJsonValue | null
    array_ends_with?: InputJsonValue | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonNullValueFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBigIntNullableFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableFilter | bigint | number | null
  }

  export type NestedBytesNullableFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableFilter | Buffer | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter = {
    equals?: bigint | number | null
    in?: Enumerable<bigint> | Enumerable<number> | null
    notIn?: Enumerable<bigint> | Enumerable<number> | null
    lt?: bigint | number
    lte?: bigint | number
    gt?: bigint | number
    gte?: bigint | number
    not?: NestedBigIntNullableWithAggregatesFilter | bigint | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedBigIntNullableFilter
    _min?: NestedBigIntNullableFilter
    _max?: NestedBigIntNullableFilter
  }

  export type NestedBytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Enumerable<Buffer> | null
    notIn?: Enumerable<Buffer> | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableFilter | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string | null
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}